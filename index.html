<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>TerraRun | Карта</title>

    <!-- Подключение Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Подключение Leaflet JS и CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- Подключение Turf.js для гео-анализа -->
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
    
    <!-- Подключение плагина Leaflet.TextPath для текста вдоль линии -->
    <script src="https://unpkg.com/leaflet-textpath/leaflet.textpath.js"></script>
    
    <!-- Подключение Telegram Web App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- Подключение Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <!-- Подключение QR Code Generator -->
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

    <!-- Иконочные шрифты -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">


    <style>
        :root {
            --bg-color: #f3f4f6;
            --secondary-bg-color: #ffffff;
            --text-color: #1f2937;
            --hint-color: #6b7280;
            --button-color: #3b82f6;
            --button-text-color: #ffffff;
            --destructive-color: #ef4444;
            --success-color: #28a745;
            --star-color: #facc15;
            --border-color: #e5e7eb;
        }

        /* Адаптация под безопасные зоны iOS */
        body {
            padding-top: constant(safe-area-inset-top);
            padding-top: env(safe-area-inset-top);
            padding-bottom: constant(safe-area-inset-bottom);
            padding-bottom: env(safe-area-inset-bottom);
        }

        body {
            overscroll-behavior: none;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            font-family: 'Inter', sans-serif;
        }
        #map, .mini-map, #detail-mini-map {
            z-index: 10;
            background-color: var(--bg-color);
        }
        #map {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 80px; /* Высота навбара */
        }
        .view {
            display: none;
            height: calc(100vh - 80px - env(safe-area-inset-bottom));
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            transition: opacity 0.3s ease-in-out;
            background-color: var(--bg-color);
        }
        .view.active {
            display: block;
        }
        .nav-btn.active i, .nav-btn.active span {
            color: var(--button-color);
        }
        .nav-btn span {
             color: var(--hint-color);
        }
        .nav-btn i {
             color: var(--hint-color);
        }
        .card-bg {
            background-color: var(--secondary-bg-color);
        }
        #bottom-navbar {
            height: calc(80px + env(safe-area-inset-bottom));
            padding-bottom: env(safe-area-inset-bottom);
            background-color: color-mix(in srgb, var(--secondary-bg-color) 80%, transparent);
            border-top: 1px solid var(--border-color);
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .avatar-marker {
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 15px rgba(0,0,0,0.4);
            background-size: cover;
            background-position: center;
            transition: transform 0.2s ease-in-out, left 0.5s linear, top 0.5s linear;
        }
        .avatar-marker:hover {
            transform: scale(1.1);
        }
        .current-user-marker {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 2px 15px rgba(0,0,0,0.4), 0 0 0 0 color-mix(in srgb, var(--button-color) 70%, transparent); }
            70% { box-shadow: 0 2px 15px rgba(0,0,0,0.4), 0 0 0 15px color-mix(in srgb, var(--button-color) 0%, transparent); }
            100% { box-shadow: 0 2px 15px rgba(0,0,0,0.4), 0 0 0 0 color-mix(in srgb, var(--button-color) 0%, transparent); }
        }
        .like-btn.liked i {
            color: var(--destructive-color);
            font-weight: 900; /* Solid heart */
        }
        #initial-loader {
            background-color: var(--bg-color);
        }
        /* Стили для верхней панели на карте */
        #map-top-panel {
            position: fixed;
            top: calc(1rem + env(safe-area-inset-top));
            left: 0;
            right: 0;
            z-index: 20;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0 1rem;
            pointer-events: none; /* Позволяет кликать сквозь контейнер */
        }
        #mode-switcher {
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 9999px;
            padding: 0.25rem;
            display: flex;
            gap: 0.25rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            pointer-events: all; /* Включаем клики для самого свитчера */
        }
        #map-controls-right {
            pointer-events: all; /* Включаем клики для кнопок справа */
        }
        .mode-btn {
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--hint-color);
            transition: all 0.2s ease-in-out;
            border: none;
            background-color: transparent;
        }
        .mode-btn.active {
            background-color: var(--button-color);
            color: var(--button-text-color);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        /* Стили для модальных окон */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0,0,0,0.4);
            display: flex;
            z-index: 50;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        
        /* Модальное окно сверху вниз */
        #simple-post-modal {
            align-items: flex-start;
        }
        #simple-post-content {
            transform: translateY(-100%);
            transition: transform 0.3s ease-in-out;
        }
        #simple-post-modal.visible #simple-post-content {
            transform: translateY(0);
        }

        /* Модальное окно снизу вверх (Bottom Sheet) */
        .bottom-sheet-modal {
            align-items: flex-end;
        }
        .bottom-sheet-content {
            width: 100%;
            background-color: var(--secondary-bg-color);
            border-radius: 1.5rem 1.5rem 0 0;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform 0.3s ease-in-out;
        }
        .bottom-sheet-modal.visible .bottom-sheet-content {
            transform: translateY(0);
        }
        .grabber {
            width: 3rem;
            height: 0.375rem;
            background-color: #d1d5db;
            border-radius: 9999px;
            margin: 0.75rem auto;
            flex-shrink: 0;
            cursor: grab;
        }
        
        /* Стили для табов в профиле */
        .profile-tab {
            flex-grow: 1;
            text-align: center;
            padding: 0.75rem 0.5rem;
            font-weight: 600;
            color: var(--hint-color);
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }
        .profile-tab.active {
            color: var(--button-color);
            border-bottom-color: var(--button-color);
        }
        .profile-tab-content {
            display: none;
        }
        .profile-tab-content.active {
            display: block;
        }
        
        /* Стили для комментариев в модальном окне деталей */
        #detail-comments-section {
            border-top: 1px solid var(--border-color);
            padding: 1rem;
        }
        #detail-comment-input-form {
            padding: 0.5rem 1rem 1rem;
            border-top: 1px solid var(--border-color);
            background-color: var(--secondary-bg-color);
        }

        /* Скелетная загрузка */
        .skeleton {
            background-color: #e2e8f0;
            border-radius: 0.5rem;
            animation: pulse-bg 1.5s infinite;
        }
        @keyframes pulse-bg {
            50% { background-color: #cbd5e1; }
        }
    </style>
</head>
<body class="font-sans antialiased overflow-hidden">
    
    <!-- Начальный загрузчик -->
    <div id="initial-loader" class="fixed inset-0 flex flex-col items-center justify-center z-50">
        <svg class="animate-spin h-10 w-10 mb-4" style="color: var(--button-color);" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
        <p id="loader-text" class="text-lg font-semibold" style="color: var(--text-color);">Загрузка TerraRun...</p>
    </div>

    <!-- Экран-заглушка / Ошибка -->
    <div id="fallback-screen" class="fixed inset-0 flex items-center justify-center p-4 z-40 hidden">
        <div id="fallback-content" class="text-center card-bg p-8 rounded-2xl shadow-lg max-w-sm"></div>
    </div>

    <!-- Основной контейнер приложения -->
    <div id="app-container" class="hidden">
        <!-- Вид 1: Карта -->
        <div id="map-view" class="view active">
            <div id="map"></div>
            
            <!-- Панель управления на карте -->
            <div id="map-top-panel">
                <div class="w-12"></div> <!-- Пустой див для баланса слева -->
                
                <div class="flex-grow flex justify-center">
                     <div id="mode-switcher" class="hidden">
                         <button id="mode-capture" class="mode-btn active">Захват</button>
                         <button id="mode-spots" class="mode-btn">Споты</button>
                         <button id="mode-routes" class="mode-btn">Маршруты</button>
                     </div>
                </div>

                <div id="map-controls-right" class="flex flex-col items-end gap-2">
                    <button id="request-geo-btn" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-full shadow-lg flex items-center gap-2 pointer-events-all">
                        <i class="fa-solid fa-location-arrow h-5 w-5"></i>
                        <span id="request-geo-text">Дать доступ к гео</span>
                        <svg id="request-geo-loader" class="animate-spin h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                    </button>
                    <button id="recenter-btn" class="hidden bg-white/80 backdrop-blur-md p-3 rounded-full shadow-lg pointer-events-all">
                        <i class="fa-solid fa-location-crosshairs h-6 w-6 text-gray-700"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- Вид 2: Лента -->
        <div id="feed-view" class="view p-4 fade-in">
            <div class="flex justify-between items-center mb-6 px-2">
                <h1 class="text-3xl font-bold">Лента</h1>
                <button id="create-simple-post-btn" class="p-2 rounded-full hover:bg-gray-200" style="background-color: var(--secondary-bg-color);">
                    <i class="fa-solid fa-plus h-7 w-7" style="color: var(--button-color);"></i>
                </button>
            </div>
            <div id="feed-container" class="space-y-4"></div>
        </div>

        <!-- Вид 3: Топ пользователей -->
        <div id="top-view" class="view p-4 fade-in">
            <div class="flex justify-between items-center mb-6 px-2">
                <h1 class="text-3xl font-bold">Топ Бегунов</h1>
                <button id="scan-qr-btn" class="p-2 rounded-full hover:bg-gray-200" style="background-color: var(--secondary-bg-color);">
                    <i class="fa-solid fa-qrcode h-7 w-7" style="color: var(--hint-color);"></i>
                </button>
            </div>
            <div id="leaderboard" class="space-y-3"></div>
        </div>

        <!-- Вид 4: Профиль -->
        <div id="profile-view" class="view p-4 fade-in">
            <h1 class="text-3xl font-bold mb-6 px-2">Профиль</h1>
            <div class="card-bg rounded-2xl shadow-lg p-6 flex flex-col items-center space-y-4">
                <div id="profile-avatar-wrapper" class="w-24 h-24 rounded-full border-4 flex-shrink-0">
                    <img src="https://placehold.co/96x96/E2E8F0/4A5568?text=?" id="profile-avatar-img" class="w-full h-full rounded-full object-cover" alt="avatar">
                </div>
                <div class="text-center">
                    <h2 id="profile-name" class="text-2xl font-bold">Загрузка...</h2>
                    <p class="text-sm mt-2" style="color: var(--hint-color);">Общая площадь</p>
                    <p id="profile-area" class="text-3xl font-bold" style="color: var(--button-color);">0 м²</p>
                </div>
                <div class="w-full pt-4 mt-4 border-t" style="border-color: var(--border-color);">
                    <div class="grid grid-cols-4 gap-2 text-center">
                        <button id="invite-friend-btn" class="flex flex-col items-center space-y-1 transition-opacity hover:opacity-70">
                            <div class="p-3 rounded-full" style="background-color: color-mix(in srgb, var(--button-color) 15%, transparent);"><i class="fa-solid fa-user-plus h-6 w-6" style="color: var(--button-color);"></i></div>
                            <span class="text-xs font-medium" style="color: var(--hint-color);">Пригласить</span>
                        </button>
                        <button id="share-profile-btn" class="flex flex-col items-center space-y-1 transition-opacity hover:opacity-70">
                            <div class="p-3 rounded-full" style="background-color: color-mix(in srgb, var(--button-color) 15%, transparent);"><i class="fa-solid fa-arrow-up-from-bracket h-6 w-6" style="color: var(--button-color);"></i></div>
                            <span class="text-xs font-medium" style="color: var(--hint-color);">Поделиться</span>
                        </button>
                        <button id="show-qr-btn" class="flex flex-col items-center space-y-1 transition-opacity hover:opacity-70">
                            <div class="p-3 rounded-full" style="background-color: color-mix(in srgb, var(--button-color) 15%, transparent);"><i class="fa-solid fa-qrcode h-6 w-6" style="color: var(--button-color);"></i></div>
                            <span class="text-xs font-medium" style="color: var(--hint-color);">Мой QR</span>
                        </button>
                        <button id="donate-btn" class="flex flex-col items-center space-y-1 transition-opacity hover:opacity-70">
                            <div class="p-3 rounded-full" style="background-color: color-mix(in srgb, var(--success-color) 15%, transparent);"><i class="fa-solid fa-heart h-6 w-6" style="color: var(--success-color);"></i></div>
                            <span class="text-xs font-medium" style="color: var(--hint-color);">Поддержать</span>
                        </button>
                    </div>
                </div>
            </div>
             <!-- Табы -->
            <div class="flex border-b mt-6 sticky top-0 z-10" style="background-color: var(--bg-color);">
                <div id="profile-tab-posts" class="profile-tab active" onclick="switchMainProfileTab('posts')">Посты</div>
                <div id="profile-tab-spots" class="profile-tab" onclick="switchMainProfileTab('spots')">Споты</div>
                <div id="profile-tab-routes" class="profile-tab" onclick="switchMainProfileTab('routes')">Маршруты</div>
            </div>

            <div id="profile-content-posts" class="profile-tab-content active mt-4 space-y-4"></div>
            <div id="profile-content-spots" class="profile-tab-content mt-4 space-y-4"></div>
            <div id="profile-content-routes" class="profile-tab-content mt-4 space-y-4"></div>
        </div>
    </div>

    <!-- Нижний навбар -->
    <nav id="bottom-navbar" class="hidden fixed bottom-0 left-0 right-0 backdrop-blur-md flex justify-around items-center z-20">
        <button class="nav-btn active flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('map-view')"><i class="fa-solid fa-map-location-dot h-7 w-7"></i><span>Карта</span></button>
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('feed-view')"><i class="fa-solid fa-newspaper h-7 w-7"></i><span>Лента</span></button>
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('top-view')"><i class="fa-solid fa-ranking-star h-7 w-7"></i><span>Топ</span></button>
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('profile-view')"><i class="fa-solid fa-user h-7 w-7"></i><span>Профиль</span></button>
    </nav>
    
    <!-- Модальное окно создания простого поста (сверху вниз, 45%) -->
    <div id="simple-post-modal" class="modal-overlay" onclick="if(event.target === this) hideSimplePostModal()">
        <div id="simple-post-content" class="card-bg rounded-b-2xl shadow-2xl p-6 w-full max-w-lg space-y-4" style="height: 45vh;">
            <div class="flex justify-between items-center">
                <h2 class="text-2xl font-bold">Новый пост</h2>
                <button onclick="hideSimplePostModal()" class="p-2 rounded-full hover:bg-gray-200"><i class="fa-solid fa-times"></i></button>
            </div>
            <p style="color: var(--hint-color);">Поделитесь своими мыслями с сообществом.</p>
            <textarea id="simple-post-details" class="mt-1 block w-full h-1/3 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500" placeholder="Что у вас нового?"></textarea>
            <div id="simple-post-filename" class="text-sm text-gray-500 truncate"></div>
            <div class="flex justify-between items-center pt-4">
                 <label for="simple-post-photo-input" class="cursor-pointer p-2 rounded-full hover:bg-gray-200">
                     <i class="fa-solid fa-paperclip h-7 w-7" style="color: var(--hint-color);"></i>
                     <input id="simple-post-photo-input" type="file" class="sr-only" accept="image/*">
                 </label>
                <button onclick="handleSimplePostSave()" class="text-white font-bold py-2 px-6 rounded-full transition-all" style="background-color: var(--button-color);">Опубликовать</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно создания Спота/Маршрута/Поста (снизу вверх, 75%) -->
    <div id="creation-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideCreationModal()">
        <div class="bottom-sheet-content" style="height: 75%; max-height: calc(100vh - env(safe-area-inset-top) - 1rem);">
            <div class="grabber" onclick="hideCreationModal()"></div>
            <div id="creation-modal-body" class="flex-grow overflow-y-auto p-4 space-y-4">
                <h2 id="creation-modal-title" class="text-2xl font-bold"></h2>
                <p id="creation-modal-description" style="color: var(--hint-color);"></p>
                <div>
                    <label for="creation-modal-name" class="block text-sm font-medium">Название</label>
                    <input type="text" id="creation-modal-name" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500" placeholder="Например, 'Красивый вид'">
                </div>
                <div id="creation-modal-details-section">
                    <label for="creation-modal-details" class="block text-sm font-medium">Описание</label>
                    <textarea id="creation-modal-details" rows="3" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500" placeholder="Опишите это место или маршрут..."></textarea>
                </div>
                <div id="creation-modal-photo-section">
                    <label for="creation-modal-photo-input" class="block text-sm font-medium">Фото</label>
                    <div class="mt-1 flex justify-center px-6 pt-5 pb-6 border-2 border-gray-300 border-dashed rounded-md">
                        <div class="space-y-1 text-center">
                            <img id="creation-modal-photo-preview" src="" alt="Предпросмотр фото" class="hidden mx-auto h-24 w-auto mb-4 rounded">
                            <i id="creation-modal-photo-icon" class="fa-solid fa-image mx-auto h-12 w-12 text-gray-400"></i>
                            <div class="flex text-sm text-gray-600">
                                <label for="creation-modal-photo-input" class="relative cursor-pointer rounded-md font-medium" style="color: var(--button-color);">
                                    <span>Загрузите файл</span>
                                    <input id="creation-modal-photo-input" type="file" class="sr-only" accept="image/*">
                                </label>
                                <p class="pl-1">или перетащите</p>
                            </div>
                            <p class="text-xs text-gray-500">PNG, JPG до 10MB</p>
                        </div>
                    </div>
                </div>
                <div class="flex justify-end space-x-3 pt-4">
                    <button onclick="hideCreationModal()" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-full transition-all">Отмена</button>
                    <button id="save-creation-btn" class="text-white font-bold py-2 px-4 rounded-full transition-all" style="background-color: var(--button-color);">Сохранить</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно деталей (выдвигается снизу) -->
    <div id="detail-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideDetailModal()">
        <div class="bottom-sheet-content" style="height: 90%; max-height: calc(100vh - env(safe-area-inset-top) - 1rem);">
            <div class="grabber" onclick="hideDetailModal()"></div>
            <div id="detail-modal-body" class="flex-grow overflow-y-auto"></div>
        </div>
    </div>

    <!-- Модальное окно с комментариями (ДЛЯ ПОСТОВ) -->
    <div id="comments-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideCommentsModal()">
        <div class="bottom-sheet-content" style="height: 75%;">
             <div class="grabber" onclick="hideCommentsModal()"></div>
             <h2 id="comments-modal-title" class="text-xl font-bold px-4 pb-2 flex-shrink-0">Комментарии</h2>
            <div id="comments-modal-body" class="flex-grow overflow-y-auto p-4"></div>
            <div id="comment-input-container" class="flex-shrink-0 p-2 border-t" style="background-color: var(--secondary-bg-color); border-color: var(--border-color);">
                <div id="reply-indicator" class="hidden text-xs px-2 pb-1 flex justify-between items-center" style="color: var(--hint-color);">
                    <span id="reply-indicator-text"></span>
                    <button onclick="cancelReply()" class="font-bold text-xl">&times;</button>
                </div>
                <div class="flex items-center space-x-2">
                    <textarea id="main-comment-input" class="w-full p-2 border rounded-lg focus:ring-blue-500 focus:border-blue-500 flex-grow" rows="1" placeholder="Написать комментарий..."></textarea>
                    <button id="main-comment-send-btn" onclick="postComment()" class="flex-shrink-0 text-white rounded-full p-2 hover:opacity-80 disabled:opacity-50" style="background-color: var(--button-color);">
                        <i class="fa-solid fa-paper-plane h-6 w-6"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно для QR-кода -->
    <div id="qr-modal" class="modal-overlay justify-center items-center p-4" onclick="if(event.target === this) hideQrModal()">
        <div class="card-bg rounded-2xl shadow-2xl p-6 w-full max-w-xs fade-in space-y-4 flex flex-col items-center">
            <h2 class="text-2xl font-bold">Мой QR-код</h2>
            <div id="qrcode" class="p-2 bg-white rounded-lg"></div>
            <p class="text-center text-sm" style="color: var(--hint-color);">Покажите этот код другу, чтобы он отсканировал его в приложении.</p>
            <button onclick="hideQrModal()" class="w-full mt-4 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-full transition-all">Закрыть</button>
        </div>
    </div>

    <script type="module">
        // --- КОНФИГУРАЦИЯ И КОНСТАНТЫ ---
        const SUPABASE_URL = 'https://jsnahjtoqwuwbjdmisuj.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpzbmFoanRvcXd1d2JqZG1pc3VqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMzOTQxMDQsImV4cCI6MjA2ODk3MDEwNH0.M3TWsNJppj1f-Cmj6nGCAUswy1HZgBLW8yJZfTwkrpI';
        const MAPBOX_ACCESS_TOKEN = 'pk.eyJ1IjoieXVuZ3JlemFjIiwiYSI6ImNtOW10ZzJ6bDBjNHUyanI3ejc5eXo1d2MifQ._tryk9cXjfReUGLGnNkm6Q';
        const MAP_TILE_URL = 'https://api.mapbox.com/styles/v1/mapbox/streets-v12/tiles/512/{z}/{x}/{y}?access_token={accessToken}';
        const BOT_USERNAME = 'TerraRunBot'; // Имя вашего бота

        // --- ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ И СОСТОЯНИЕ ---
        const tg = window.Telegram.WebApp;
        let map;
        let supabase;
        let telegramUser = null;
        let locationWatchId = null;
        let scrollToPostId = null; // NEW: Для диплинков на посты
        
        // Состояние режимов
        let currentMode = 'capture'; // 'capture', 'spots', 'routes'
        let isRunning = false; // Для режимов 'capture' и 'routes'
        let lastKnownLocation = null;
        
        // Данные режимов
        let currentRunPath = [];
        let currentPathPolyline = null;
        let userTerritory = null;
        let userColor = '#3b82f6';
        let currentUserMarker = null;
        
        let allUserLayers = {};
        let allSpots = [];
        let allRoutes = [];
        let territoriesLayerGroup = L.layerGroup();
        let spotMarkersLayer = L.layerGroup();
        let routePolylinesLayer = L.layerGroup();

        let allProfilesData = [];
        let currentEditContext = {}; // Для модалки создания/редактирования
        let currentDetailContext = {}; // Для модалки деталей
        let currentReplyTarget = { type: null, id: null, parentCommentId: null };
        
        // --- ЭЛЕМЕНТЫ DOM ---
        const initialLoader = document.getElementById('initial-loader');
        const loaderText = document.getElementById('loader-text');
        const fallbackScreen = document.getElementById('fallback-screen');
        const fallbackContent = document.getElementById('fallback-content');
        const appContainer = document.getElementById('app-container');
        const bottomNavbar = document.getElementById('bottom-navbar');
        const modeSwitcher = document.getElementById('mode-switcher');
        
        // Модальные окна
        const detailModal = document.getElementById('detail-modal');
        const commentsModal = document.getElementById('comments-modal');
        const simplePostModal = document.getElementById('simple-post-modal');
        const creationModal = document.getElementById('creation-modal');
        const qrModal = document.getElementById('qr-modal');

        const leaderboardDiv = document.getElementById('leaderboard');
        const feedContainer = document.getElementById('feed-container');
        const profileName = document.getElementById('profile-name');
        const profileAreaDisplay = document.getElementById('profile-area');
        const profileAvatarImg = document.getElementById('profile-avatar-img');
        const profileAvatarWrapper = document.getElementById('profile-avatar-wrapper');
        const recenterBtn = document.getElementById('recenter-btn');
        const requestGeoBtn = document.getElementById('request-geo-btn');
        const scanQrBtn = document.getElementById('scan-qr-btn');
        const inviteFriendBtn = document.getElementById('invite-friend-btn');
        const shareProfileBtn = document.getElementById('share-profile-btn');
        const donateBtn = document.getElementById('donate-btn');
        const showQrBtn = document.getElementById('show-qr-btn');
        const createSimplePostBtn = document.getElementById('create-simple-post-btn');

        // --- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ---

        /**
         * Осветляет или затемняет цвет в формате hex.
         * @param {string} color - Строка цвета в формате hex (например, "#RRGGBB").
         * @param {number} percent - Процент для осветления (положительный) или затемнения (отрицательный).
         * @returns {string} Новая строка цвета в формате hex.
         */
        function shadeColor(color, percent) {
            if (!color || color.length !== 7) {
                return '#e5e7eb'; // Возвращаем значение по умолчанию, если цвет недействителен
            }
            let R = parseInt(color.substring(1, 3), 16);
            let G = parseInt(color.substring(3, 5), 16);
            let B = parseInt(color.substring(5, 7), 16);

            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);

            R = (R < 255) ? R : 255;
            G = (G < 255) ? G : 255;
            B = (B < 255) ? B : 255;
            
            R = (R > 0) ? R : 0;
            G = (G > 0) ? G : 0;
            B = (B > 0) ? B : 0;

            const RR = ((R.toString(16).length === 1) ? "0" + R.toString(16) : R.toString(16));
            const GG = ((G.toString(16).length === 1) ? "0" + G.toString(16) : G.toString(16));
            const BB = ((B.toString(16).length === 1) ? "0" + B.toString(16) : B.toString(16));

            return "#" + RR + GG + BB;
        }

        /**
         * Генерирует диплинк и открывает диалог "Поделиться" в Telegram.
         * @param {'post' | 'route' | 'spot' | 'user'} type - Тип контента.
         * @param {number | string} id - ID контента.
         * @param {string} text - Текст для сообщения.
         */
        function shareContent(type, id, text) {
            tg.HapticFeedback.impactOccurred('light');
            // UPDATED: Используем startapp для прямого открытия Mini App
            const url = `https://t.me/${BOT_USERNAME}?startapp=${type}_${id}`;
            tg.openTelegramLink(`https://t.me/share/url?url=${encodeURIComponent(url)}&text=${encodeURIComponent(text)}`);
        }

        // --- ФУНКЦИИ UI ---
        function showView(viewId) {
            tg.HapticFeedback.selectionChanged();
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(viewId).classList.add('active');
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`button[onclick="showView('${viewId}')"]`).classList.add('active');
            
            const isMapView = viewId === 'map-view';
            
            if (isMapView) {
                updateMainButton();
                tg.MainButton.show();
            } else {
                tg.MainButton.hide();
            }

            // Показываем свитчер только если есть гео и мы на карте
            modeSwitcher.classList.toggle('hidden', !isMapView || !lastKnownLocation);
            
            if (isMapView) {
                setTimeout(() => map?.invalidateSize(), 100);
            }
        }

        async function setMode(newMode) {
            if (currentMode === newMode) return;
            
            if (isRunning) {
                showCustomAlert("Сначала завершите текущую активность (захват или запись маршрута).");
                return;
            }

            tg.HapticFeedback.selectionChanged();
            currentMode = newMode;
            
            // Сохраняем режим в облачное хранилище Telegram
            tg.CloudStorage.setItem('currentMode', newMode);

            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.id === `mode-${newMode}`);
            });

            map.off('click');
            
            if (map.hasLayer(territoriesLayerGroup)) map.removeLayer(territoriesLayerGroup);
            if (map.hasLayer(spotMarkersLayer)) map.removeLayer(spotMarkersLayer);
            if (map.hasLayer(routePolylinesLayer)) map.removeLayer(routePolylinesLayer);

            switch (newMode) {
                case 'capture':
                    map.addLayer(territoriesLayerGroup);
                    break;
                case 'spots':
                    map.addLayer(spotMarkersLayer);
                    map.on('click', handleMapClickForSpot);
                    break;
                case 'routes':
                    map.addLayer(routePolylinesLayer);
                    break;
            }
            updateMainButton();
        }

        function updateMainButton() {
            if (!lastKnownLocation) {
                tg.MainButton.setText("Определение геолокации...");
                tg.MainButton.disable();
                return;
            }
            
            tg.MainButton.enable();
            tg.MainButton.offClick(mainButtonHandler); // Удаляем предыдущий обработчик

            switch (currentMode) {
                case 'capture':
                    if (isRunning) {
                        tg.MainButton.setText("Остановить захват");
                        tg.MainButton.setParams({ color: 'var(--destructive-color)' });
                    } else {
                        tg.MainButton.setText("Начать захват");
                        tg.MainButton.setParams({ color: 'var(--button-color)' });
                    }
                    break;
                case 'spots':
                    tg.MainButton.setText("Добавить спот здесь");
                    tg.MainButton.setParams({ color: 'var(--button-color)' });
                    break;
                case 'routes':
                    if (isRunning) {
                        tg.MainButton.setText("Завершить и сохранить маршрут");
                        tg.MainButton.setParams({ color: 'var(--destructive-color)' });
                    } else {
                        tg.MainButton.setText("Начать запись маршрута");
                        tg.MainButton.setParams({ color: 'var(--button-color)' });
                    }
                    break;
            }
            tg.MainButton.onClick(mainButtonHandler);
        }
        
        async function mainButtonHandler() {
            tg.MainButton.showProgress();
            try {
                switch (currentMode) {
                    case 'capture':
                        isRunning ? await stopRun() : startRun();
                        break;
                    case 'spots':
                        if(lastKnownLocation) {
                            handleMapClickForSpot({latlng: L.latLng(lastKnownLocation)});
                        } else {
                            showCustomAlert("Определяем ваше местоположение...");
                        }
                        break;
                    case 'routes':
                        isRunning ? await stopRouteRecording() : startRouteRecording();
                        break;
                }
            } finally {
                tg.MainButton.hideProgress();
            }
        }
        
        function generateColorFromId(id) {
            const strId = String(id);
            let hash = 0;
            for (let i = 0; i < strId.length; i++) {
                hash = strId.charCodeAt(i) + ((hash << 5) - hash);
            }
            const h = hash % 360;
            return `hsl(${h}, 80%, 65%)`;
        }

        // --- ЛОГИКА МОДАЛЬНЫХ ОКОН ---
        
        function showSimplePostModal() {
            document.getElementById('simple-post-details').value = '';
            document.getElementById('simple-post-photo-input').value = '';
            document.getElementById('simple-post-filename').textContent = '';
            simplePostModal.classList.add('visible');
            tg.BackButton.show();
        }

        function hideSimplePostModal() {
            simplePostModal.classList.remove('visible');
            tg.BackButton.hide();
        }
        
        function showCreationModal(type, context = {}) {
            currentEditContext = { type, ...context };
            const title = document.getElementById('creation-modal-title');
            const description = document.getElementById('creation-modal-description');
            const nameInput = document.getElementById('creation-modal-name');
            const detailsInput = document.getElementById('creation-modal-details');
            const detailsSection = document.getElementById('creation-modal-details-section');
            const photoSection = document.getElementById('creation-modal-photo-section');
            
            nameInput.value = '';
            detailsInput.value = '';
            document.getElementById('creation-modal-photo-input').value = '';
            document.getElementById('creation-modal-photo-preview').classList.add('hidden');
            document.getElementById('creation-modal-photo-icon').classList.remove('hidden');

            // Скрываем все секции по умолчанию
            detailsSection.style.display = 'none';
            photoSection.style.display = 'none';

            if (type === 'spot') {
                title.textContent = 'Создать новый спот';
                description.textContent = 'Отметьте интересное место на карте для других.';
                detailsSection.style.display = 'block';
                photoSection.style.display = 'block';
            } else if (type === 'route') {
                title.textContent = 'Сохранить новый маршрут';
                description.textContent = 'Дайте название и описание вашему маршруту.';
                detailsSection.style.display = 'block';
            } else if (type === 'post') {
                title.textContent = 'Новое достижение!';
                description.textContent = `Вы захватили ${context.area_captured_formatted}. Дайте название вашей новой территории.`;
                photoSection.style.display = 'block';
            }
            
            creationModal.classList.add('visible');
            tg.BackButton.show();
        }

        function hideCreationModal() {
            creationModal.classList.remove('visible');
            tg.BackButton.hide();
            currentEditContext = {};
        }

        function handleSave() {
            const { type } = currentEditContext;
            if (type === 'spot') saveSpot();
            else if (type === 'route') saveRoute();
            else if (type === 'post') handlePostSubmission();
        }
        
        function showDetailModal(type, id) {
             currentDetailContext = { type, id };
             tg.HapticFeedback.impactOccurred('medium');
             tg.BackButton.show();
             
             detailModal.classList.add('visible');
             loadDetailContent();
        }
        
        function hideDetailModal() {
            tg.BackButton.hide();
            detailModal.classList.remove('visible');
            currentDetailContext = {};
        }

        async function loadDetailContent() {
            const { type, id } = currentDetailContext;
            const body = document.getElementById('detail-modal-body');
            
            body.innerHTML = `<div class="text-center p-8"><svg class="animate-spin mx-auto h-8 w-8 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></div>`;

            const commentsHtml = `
                <div id="detail-comments-section" class="mt-4">
                    <h3 class="text-xl font-bold px-4">Комментарии</h3>
                    <div id="detail-comments-list" class="p-4 space-y-4">
                         <p class="text-center text-gray-500">Загрузка комментариев...</p>
                    </div>
                </div>
                <div id="detail-comment-input-form" class="flex-shrink-0 p-2 border-t" style="background-color: var(--secondary-bg-color); border-color: var(--border-color);">
                     <div id="detail-reply-indicator" class="hidden text-xs px-2 pb-1 flex justify-between items-center" style="color: var(--hint-color);">
                         <span id="detail-reply-indicator-text"></span>
                         <button onclick="cancelDetailReply()" class="font-bold text-xl">&times;</button>
                     </div>
                    <div class="flex items-center space-x-2">
                        <textarea id="detail-comment-input" class="w-full p-2 border rounded-lg focus:ring-blue-500 focus:border-blue-500 flex-grow" rows="1" placeholder="Написать комментарий..."></textarea>
                        <button onclick="postDetailComment()" class="flex-shrink-0 text-white rounded-full p-2 hover:opacity-80 disabled:opacity-50" style="background-color: var(--button-color);">
                           <i class="fa-solid fa-paper-plane h-6 w-6"></i>
                        </button>
                    </div>
                </div>
            `;

            if (type === 'spot') {
                const { data: spot, error } = await supabase.from('spots').select('*, profiles(id, name, photo_url), location_wkt:location::text').eq('id', id).single();
                if (error || !spot) {
                    body.innerHTML = `<p class="text-red-500 text-center p-4">Не удалось загрузить детали спота.</p>`;
                    return;
                }
                const author = spot.profiles || { name: 'Аноним', photo_url: null };
                const avatar = author.photo_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${author.name.charAt(0)}`;
                body.innerHTML = `
                    <div class="space-y-4 pb-4">
                        ${spot.photo_url ? `<img src="${spot.photo_url}" class="w-full h-64 object-cover" alt="Spot photo">` : ''}
                        <div class="px-4">
                            <div class="flex justify-between items-start">
                                <h2 class="text-3xl font-bold flex-1">${spot.name}</h2>
                                <button onclick="shareContent('spot', ${spot.id}, 'Смотри какой спот я нашел в TerraRun!')" class="p-2 rounded-full hover:bg-gray-200 ml-2 flex-shrink-0">
                                    <i class="fa-solid fa-arrow-up-from-bracket h-6 w-6" style="color: var(--hint-color);"></i>
                                </button>
                            </div>
                            <div class="flex items-center space-x-3 mt-2 cursor-pointer" onclick="showDetailModal('user', ${spot.user_id})">
                                <img src="${avatar}" class="w-8 h-8 rounded-full" alt="author avatar">
                                <span class="font-semibold text-sm">Автор: ${author.name}</span>
                            </div>
                            <p class="mt-4" style="color: var(--text-color);">${spot.description}</p>
                        </div>
                    </div>
                    ${commentsHtml}
                `;
                loadAndRenderComments(type, id, 'detail-comments-list');
            } else if (type === 'route') {
                const { data: route, error } = await supabase.from('routes').select('*, profiles(id, name, photo_url), path_wkt:path::text').eq('id', id).single();
                if (error || !route) {
                    body.innerHTML = `<p class="text-red-500 text-center p-4">Не удалось загрузить детали маршрута.</p>`;
                    return;
                }
                const author = route.profiles || { name: 'Аноним', photo_url: null };
                const avatar = author.photo_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${author.name.charAt(0)}`;
                body.innerHTML = `
                    <div class="space-y-4 pb-4">
                        <div id="detail-mini-map" class="h-64 w-full bg-gray-200"></div>
                        <div class="px-4">
                             <div class="flex justify-between items-start">
                                <h2 class="text-3xl font-bold flex-1">${route.name}</h2>
                                <button onclick="shareContent('route', ${route.id}, 'Зацени мой маршрут в TerraRun!')" class="p-2 rounded-full hover:bg-gray-200 ml-2 flex-shrink-0">
                                    <i class="fa-solid fa-arrow-up-from-bracket h-6 w-6" style="color: var(--hint-color);"></i>
                                </button>
                            </div>
                            <div class="flex items-center space-x-3 mt-2 cursor-pointer" onclick="showDetailModal('user', ${route.user_id})">
                                <img src="${avatar}" class="w-8 h-8 rounded-full" alt="author avatar">
                                <span class="font-semibold text-sm">Автор: ${author.name}</span>
                            </div>
                            ${route.description ? `<p class="mt-4" style="color: var(--text-color);">${route.description}</p>` : ''}
                        </div>
                    </div>
                     ${commentsHtml}
                `;
                setTimeout(() => {
                    const mapContainer = document.getElementById('detail-mini-map');
                    const routeGeoJson = parseWKT(route.path_wkt);
                    if (mapContainer && !mapContainer._leaflet_id && routeGeoJson) {
                        const miniMap = L.map(mapContainer, { zoomControl: false, attributionControl: false, dragging: false, scrollWheelZoom: false, doubleClickZoom: false });
                        L.tileLayer(MAP_TILE_URL, { maxZoom: 19, accessToken: MAPBOX_ACCESS_TOKEN, tileSize: 512, zoomOffset: -1 }).addTo(miniMap);
                        const routeLayer = L.geoJSON(routeGeoJson, { style: { color: '#ff7800', weight: 3 } }).addTo(miniMap);
                        miniMap.fitBounds(routeLayer.getBounds(), { padding: [10, 10] });
                    }
                }, 100);
                 loadAndRenderComments(type, id, 'detail-comments-list');
            } else if (type === 'user') {
                const [profileRes, postsRes, spotsRes, routesRes] = await Promise.all([
                    supabase.from('profiles').select('*').eq('id', id).single(),
                    supabase.from('posts').select('*').eq('user_id', id).order('created_at', { ascending: false }),
                    supabase.from('spots').select('*, location_wkt:location::text').eq('user_id', id).order('created_at', { ascending: false }),
                    supabase.from('routes').select('*, path_wkt:path::text').eq('user_id', id).order('created_at', { ascending: false })
                ]);

                if (profileRes.error) {
                    body.innerHTML = `<p class="text-red-500 text-center">Не удалось загрузить профиль.</p>`;
                    return;
                }
                const profile = profileRes.data;
                const posts = postsRes.data || [];
                const spots = spotsRes.data || [];
                const routes = routesRes.data || [];

                const postIds = posts.map(p => p.id);
                const likesByPost = {};
                const commentsByPost = {};
                if (postIds.length > 0) {
                    const { data: likes } = await supabase.from('likes').select('*').in('post_id', postIds);
                    const { data: comments } = await supabase.from('comments').select('id, post_id').in('post_id', postIds);
                    if(likes) likes.forEach(like => (likesByPost[like.post_id] = likesByPost[like.post_id] || []).push(like));
                    if(comments) comments.forEach(comment => (commentsByPost[comment.post_id] = commentsByPost[comment.post_id] || []).push(comment));
                }

                const avatar = profile.photo_url || `https://placehold.co/80x80/E5E7EB/4B5563?text=${profile.name.charAt(0)}`;
                const area = profile.area || 0;
                const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;

                body.innerHTML = `
                    <div class="p-4">
                        <div class="flex items-start space-x-4">
                            <img src="${avatar}" class="w-20 h-20 rounded-full" alt="avatar">
                            <div class="flex-1">
                                <h2 class="text-2xl font-bold">${profile.name}</h2>
                                <p class="text-sm" style="color: var(--hint-color);">Общая площадь</p>
                                <p class="text-xl font-bold" style="color: var(--button-color);">${formattedArea}</p>
                            </div>
                             <button onclick="shareContent('user', ${profile.id}, 'Смотри мой профиль в TerraRun!')" class="p-2 rounded-full hover:bg-gray-200 flex-shrink-0">
                                <i class="fa-solid fa-arrow-up-from-bracket h-6 w-6" style="color: var(--hint-color);"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div class="flex border-b mt-4 px-4">
                        <div id="tab-posts" class="profile-tab active" onclick="switchProfileTab('posts')">Посты (${posts.length})</div>
                        <div id="tab-spots" class="profile-tab" onclick="switchProfileTab('spots')">Споты (${spots.length})</div>
                        <div id="tab-routes" class="profile-tab" onclick="switchProfileTab('routes')">Маршруты (${routes.length})</div>
                    </div>

                    <div id="content-posts" class="profile-tab-content active p-4 space-y-4">
                        ${posts.length > 0 ? posts.map(p => generatePostHTML(p, likesByPost[p.id] || [], commentsByPost[p.id] || [])).join('') : '<p class="text-center text-gray-500 py-4">У пользователя нет постов.</p>'}
                    </div>
                    <div id="content-spots" class="profile-tab-content p-4 space-y-4">
                        ${spots.length > 0 ? spots.map(generateMiniSpotHTML).join('') : '<p class="text-center text-gray-500 py-4">У пользователя нет спотов.</p>'}
                    </div>
                    <div id="content-routes" class="profile-tab-content p-4 space-y-4">
                         ${routes.length > 0 ? routes.map(generateMiniRouteHTML).join('') : '<p class="text-center text-gray-500 py-4">У пользователя нет маршрутов.</p>'}
                    </div>
                `;

                setTimeout(() => {
                    posts.forEach(post => {
                        if (post.territory_captured) {
                            const mapContainer = body.querySelector(`#mini-map-${post.id}`);
                            if (mapContainer && !mapContainer._leaflet_id) {
                                const miniMap = L.map(mapContainer, { zoomControl: false, attributionControl: false, dragging: false, scrollWheelZoom: false, doubleClickZoom: false });
                                L.tileLayer(MAP_TILE_URL, { maxZoom: 19, accessToken: MAPBOX_ACCESS_TOKEN, tileSize: 512, zoomOffset: -1 }).addTo(miniMap);
                                const territoryLayer = L.geoJSON(post.territory_captured, { style: { color: post.user_color, weight: 2, opacity: 0.8, fillColor: post.user_color, fillOpacity: 0.5 } }).addTo(miniMap);
                                miniMap.fitBounds(territoryLayer.getBounds(), { padding: [10, 10] });
                            }
                        }
                    });
                }, 100);
            }
        }
        
        function switchProfileTab(tabName) {
            document.querySelectorAll('#detail-modal .profile-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('#detail-modal .profile-tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`tab-${tabName}`).classList.add('active');
            document.getElementById(`content-${tabName}`).classList.add('active');
        }

        function generateMiniSpotHTML(spot) {
             return `<div class="card-bg rounded-lg p-3 shadow-sm cursor-pointer hover:bg-gray-100" onclick="navigateToMapObject('spot', ${spot.id})">
                         <p class="font-semibold">${spot.name}</p>
                         <p class="text-sm text-gray-600 truncate">${spot.description}</p>
                         <p class="text-xs text-gray-400">${new Date(spot.created_at).toLocaleDateString()}</p>
                     </div>`;
        }
        function generateMiniRouteHTML(route) {
             return `<div class="card-bg rounded-lg p-3 shadow-sm cursor-pointer hover:bg-gray-100" onclick="navigateToMapObject('route', ${route.id})">
                         <p class="font-semibold">${route.name}</p>
                         <p class="text-xs text-gray-400">${new Date(route.created_at).toLocaleDateString()}</p>
                     </div>`;
        }

        function navigateToMapObject(type, id) {
            hideDetailModal(); 
            showView('map-view');
            setMode(type === 'spot' ? 'spots' : 'routes'); 

            let target;
            if (type === 'spot') {
                target = allSpots.find(s => s.id === id);
                const geoJson = parseWKT(target?.location_wkt);
                if (geoJson) {
                    const coords = geoJson.coordinates;
                    map.flyTo([coords[1], coords[0]], 17);
                }
            } else if (type === 'route') {
                target = allRoutes.find(r => r.id === id);
                const geoJson = parseWKT(target?.path_wkt);
                if (geoJson) {
                    const coords = geoJson.coordinates.map(p => [p[1], p[0]]);
                    if (coords.length >= 2) {
                        const polyline = L.polyline(coords);
                        map.flyToBounds(polyline.getBounds(), { padding: [50, 50] });
                    }
                }
            }
        }

        /**
         * Улучшенная функция для парсинга WKT-строк в GeoJSON.
         * @param {string | null} wkt - Строка в формате Well-Known Text.
         * @returns {object | null} GeoJSON-объект или null в случае ошибки.
         */
        function parseWKT(wkt) {
            if (!wkt || typeof wkt !== 'string') {
                return null;
            }
            
            try {
                // Пытаемся распарсить как JSON (если это уже GeoJSON)
                if (wkt.trim().startsWith('{')) {
                    const parsed = JSON.parse(wkt);
                    if (parsed.type && parsed.coordinates) {
                        return parsed;
                    }
                }

                const match = wkt.match(/(POINT|LINESTRING|POLYGON|MULTIPOLYGON)\s*\((.+)\)/i);
                if (!match) {
                    return null;
                }

                const type = match[1].toUpperCase();
                let content = match[2];

                if (type === 'POINT') {
                    const coords = content.match(/-?\d+(\.\d+)?/g);
                    if (!coords || coords.length < 2) return null;
                    return { type: 'Point', coordinates: [parseFloat(coords[0]), parseFloat(coords[1])] };
                }

                if (type === 'LINESTRING') {
                    const coordPairs = content.split(',');
                    const coordinates = coordPairs.map(pair => {
                        const nums = pair.trim().match(/-?\d+(\.\d+)?/g);
                        if (!nums || nums.length < 2) return null;
                        return [parseFloat(nums[0]), parseFloat(nums[1])];
                    }).filter(p => p !== null);

                    if (coordinates.length < 2) return null;
                    return { type: 'LineString', coordinates: coordinates };
                }
                
                if (type === 'POLYGON' || type === 'MULTIPOLYGON') {
                    // Упрощенный парсер для внешнего кольца
                    const ringMatch = content.match(/\((.+?)\)/);
                    if (!ringMatch) return null;
                    const coordPairs = ringMatch[1].split(',');
                     const coordinates = coordPairs.map(pair => {
                        const nums = pair.trim().match(/-?\d+(\.\d+)?/g);
                        if (!nums || nums.length < 2) return null;
                        return [parseFloat(nums[0]), parseFloat(nums[1])];
                    }).filter(p => p !== null);
                    if (type === 'POLYGON') {
                        return { type: 'Polygon', coordinates: [coordinates] };
                    }
                    if (type === 'MULTIPOLYGON') {
                        return { type: 'MultiPolygon', coordinates: [[coordinates]] };
                    }
                }

            } catch (e) {
                console.error("Failed to parse WKT or JSON:", wkt, e);
                return null;
            }
            return null;
        }

        // --- ОСНОВНАЯ ЛОГИКА И ИНИЦИАЛИЗАЦИЯ ---
        async function main() {
            try {
                tg.ready();
                tg.expand();
                applyTheme(tg.themeParams);
                setupStaticEventListeners();

                if (!tg.initDataUnsafe?.user) {
                    showFallbackScreen('Требуется Telegram', 'Это приложение предназначено для работы исключительно внутри Telegram.', false);
                    return;
                }
                telegramUser = tg.initDataUnsafe.user;
                
                loaderText.textContent = 'Подключение к базе данных...';
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                
                loaderText.textContent = 'Загрузка данных...';
                // Инициализируем карту с координатами по умолчанию (например, Москва)
                initMap({ latitude: 55.751244, longitude: 37.618423 });
                
                await upsertUserProfile();
                updateUI();
                
                await Promise.all([
                    fetchAllProfilesAndDraw(),
                    renderFeed(),
                    loadInitialMapData(),
                    renderMyProfileContent()
                ]);

                listenToRealtimeChanges();
                setupDynamicEventListeners();
                handleStartParam(); // Обработка параметра start

                initialLoader.classList.add('hidden');
                appContainer.classList.remove('hidden');
                bottomNavbar.classList.remove('hidden');
                
                // Загружаем последний использованный режим из облачного хранилища
                tg.CloudStorage.getItem('currentMode', (error, value) => {
                    if (error) {
                        console.error("CloudStorage error:", error);
                        setMode('capture');
                        return;
                    }
                    setMode(value || 'capture');
                });

            } catch (error) {
                console.error("Критическая ошибка инициализации:", error);
                let message = error.message || "Не удалось запустить приложение. Пожалуйста, попробуйте перезагрузить его.";
                showFallbackScreen("Ошибка инициализации", message, true);
            }
        }

        function initMap(coords) {
            if (map) return;
            const latLng = [coords.latitude, coords.longitude];
            // Устанавливаем более низкий зум по умолчанию
            map = L.map('map', { zoomControl: false, attributionControl: false }).setView(latLng, 5);
            
            L.tileLayer(MAP_TILE_URL, {
                maxZoom: 19,
                tileSize: 512,
                zoomOffset: -1,
                accessToken: MAPBOX_ACCESS_TOKEN
            }).addTo(map);
            
            setTimeout(() => map?.invalidateSize(), 100);
        }

        function updateUI() {
            const name = telegramUser.first_name.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            profileName.textContent = name;
            
            if (telegramUser.photo_url) {
                profileAvatarImg.src = telegramUser.photo_url;
            } else {
                const initial = name.charAt(0).toUpperCase();
                profileAvatarImg.src = `https://placehold.co/96x96/E2E8F0/4A5568?text=${initial}`;
            }
            profileAvatarWrapper.style.borderColor = userColor;
            updateMainButton();
            refreshAllStats();
            renderMyProfileContent();
        }
        
        function updateCurrentUserMarker(latLng) {
            if (!map) return;
            const userAvatarUrl = telegramUser.photo_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${telegramUser.first_name.charAt(0)}`;
            const icon = L.divIcon({
                html: `<div class="avatar-marker current-user-marker" style="background-image: url(${userAvatarUrl}); width: 40px; height: 40px; border-color: ${userColor};"></div>`,
                className: '',
                iconSize: [40, 40],
                iconAnchor: [20, 20]
            });
            
            if (currentUserMarker) {
                currentUserMarker.setLatLng(latLng);
            } else {
                currentUserMarker = L.marker(latLng, { icon: icon, zIndexOffset: 1000 }).addTo(map);
            }
        }
        
        // --- Логика геолокации ---
        function handleGeoRequest() {
            const geoBtn = document.getElementById('request-geo-btn');
            const geoLoader = document.getElementById('request-geo-loader');
            const geoText = document.getElementById('request-geo-text');

            geoText.textContent = 'Ждем ответа...';
            geoLoader.classList.remove('hidden');
            geoBtn.disabled = true;
            
            // Запрашиваем разрешение и первую геолокацию
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    tg.HapticFeedback.notificationOccurred('success');
                    const latLng = [position.coords.latitude, position.coords.longitude];
                    lastKnownLocation = latLng;
                    
                    map.flyTo(latLng, 16);
                    updateCurrentUserMarker(latLng);

                    geoBtn.classList.add('hidden');
                    recenterBtn.classList.remove('hidden');
                    modeSwitcher.classList.remove('hidden');
                    
                    updateMainButton(); // Активируем главную кнопку
                    
                    // Запускаем постоянное отслеживание
                    startWatchingLocation();
                },
                (error) => {
                    tg.HapticFeedback.notificationOccurred('error');
                    console.error("Geolocation error:", error);
                    showCustomAlert("Не удалось получить геолокацию. Проверьте разрешения в настройках вашего устройства.");
                    geoText.textContent = 'Дать доступ к гео';
                    geoLoader.classList.add('hidden');
                    geoBtn.disabled = false;
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        }
        
        function startWatchingLocation() {
            if (locationWatchId) {
                navigator.geolocation.clearWatch(locationWatchId);
            }
            locationWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    const latLng = [position.coords.latitude, position.coords.longitude];
                    lastKnownLocation = latLng;
                    updateCurrentUserMarker(latLng);

                    if (isRunning && currentPathPolyline) {
                        const newPoint = [latLng[1], latLng[0]]; // lng, lat
                        currentRunPath.push(newPoint);
                        currentPathPolyline.addLatLng(latLng);
                    }
                },
                (error) => {
                    console.warn("Ошибка отслеживания геолокации:", error.message);
                },
                { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
            );
        }


        // --- ЛОГИКА РЕЖИМОВ ---
        
        function startRun() {
            if (!lastKnownLocation) {
                showCustomAlert("Сначала определите свое местоположение."); return;
            }
            isRunning = true;
            tg.HapticFeedback.impactOccurred('heavy');
            tg.isClosingConfirmationEnabled = true;
            updateMainButton();
            
            currentRunPath = [ [lastKnownLocation[1], lastKnownLocation[0]] ];
            if (currentPathPolyline) map.removeLayer(currentPathPolyline);
            currentPathPolyline = L.polyline([], { color: 'var(--destructive-color)', weight: 5, opacity: 0.9 }).addTo(map);
            currentPathPolyline.addLatLng(lastKnownLocation);
        }
        async function stopRun() {
            return new Promise(resolve => {
                showCustomConfirm("Завершить пробежку и захватить территорию?", async () => {
                    isRunning = false;
                    tg.HapticFeedback.notificationOccurred('success');
                    tg.isClosingConfirmationEnabled = false;
                    updateMainButton();
                    if (currentRunPath.length > 3) {
                        await processRunPath();
                    } else {
                        showCustomAlert('Слишком короткий маршрут для захвата.');
                    }
                    if (currentPathPolyline) {
                        map.removeLayer(currentPathPolyline);
                        currentPathPolyline = null;
                    }
                    resolve();
                });
            });
        }
        
        function handleMapClickForSpot(e) {
            const { lat, lng } = e.latlng;
            const locationWKT = `POINT(${lng} ${lat})`;
            showCustomConfirm("Создать новый спот в этом месте?", () => {
                showCreationModal('spot', { location: locationWKT });
            });
        }

        async function saveSpot() {
            const { location } = currentEditContext;
            const name = document.getElementById('creation-modal-name').value.trim();
            const description = document.getElementById('creation-modal-details').value.trim();
            const file = document.getElementById('creation-modal-photo-input').files[0];

            if (!name || !description) {
                showCustomAlert("Название и описание обязательны."); return;
            }
            
            let photoUrl = null;
            if (file) {
                const filePath = `${telegramUser.id}/spots/${Date.now()}_${file.name}`;
                const { data, error } = await supabase.storage.from('photo').upload(filePath, file);
                if (error) { console.error("Ошибка загрузки фото:", error); showCustomAlert("Ошибка загрузки фото."); return; }
                const { data: urlData } = supabase.storage.from('photo').getPublicUrl(data.path);
                photoUrl = urlData.publicUrl;
            }
            
            const { error } = await supabase.rpc('create_spot', {
                user_id_in: telegramUser.id,
                name_in: name,
                description_in: description,
                photo_url_in: photoUrl,
                location_wkt_in: location
            });

            if (error) {
                console.error("Ошибка сохранения спота:", error); showCustomAlert("Не удалось сохранить спот.");
            } else {
                showCustomAlert("Спот успешно создан!");
                hideCreationModal();
            }
        }
        
        function addSpotToMap(spot) {
            try {
                const wkt = spot.location_wkt || spot.location;
                const geoJsonPoint = parseWKT(wkt);

                if (!geoJsonPoint || geoJsonPoint.type !== 'Point') {
                    console.warn(`Не удалось обработать геолокацию спота ${spot.id}:`, wkt);
                    return;
                }

                const spotLayer = L.geoJSON(geoJsonPoint, {
                    pointToLayer: (feature, latlng) => L.marker(latlng)
                }).on('click', () => showDetailModal('spot', spot.id));
                
                spotMarkersLayer.addLayer(spotLayer);
            } catch (e) {
                console.error(`Ошибка при добавлении спота ${spot.id} на карту.`, e, spot);
            }
        }

        function startRouteRecording() {
            if (!lastKnownLocation) {
                showCustomAlert("Сначала определите свое местоположение."); return;
            }
            isRunning = true;
            tg.HapticFeedback.impactOccurred('heavy');
            tg.isClosingConfirmationEnabled = true;
            updateMainButton();
            
            currentRunPath = [ [lastKnownLocation[1], lastKnownLocation[0]] ];
            if (currentPathPolyline) map.removeLayer(currentPathPolyline);
            currentPathPolyline = L.polyline([], { color: 'var(--button-color)', weight: 5, opacity: 0.9 }).addTo(map);
            currentPathPolyline.addLatLng(lastKnownLocation);
        }

        async function stopRouteRecording() {
             return new Promise(resolve => {
                isRunning = false;
                tg.HapticFeedback.notificationOccurred('success');
                tg.isClosingConfirmationEnabled = false;
                updateMainButton();
                
                if (currentRunPath.length < 2) {
                    showCustomAlert("Слишком короткий маршрут.");
                    if (currentPathPolyline) map.removeLayer(currentPathPolyline);
                    currentPathPolyline = null;
                    resolve();
                    return;
                }
                
                const pathCoordinates = currentRunPath.map(p => `${p[0]} ${p[1]}`).join(', ');
                const pathWKT = `LINESTRING(${pathCoordinates})`;
                showCreationModal('route', { path: pathWKT });

                if (currentPathPolyline) {
                    map.removeLayer(currentPathPolyline);
                    currentPathPolyline = null;
                }
                resolve();
            });
        }

        async function saveRoute() {
            const { path } = currentEditContext;
            const name = document.getElementById('creation-modal-name').value.trim();
            const description = document.getElementById('creation-modal-details').value.trim();
            
            if (!name) { showCustomAlert("Название обязательно."); return; }

            const { error } = await supabase.rpc('create_route', {
                user_id_in: telegramUser.id,
                name_in: name,
                description_in: description,
                path_wkt_in: path
            });

            if (error) {
                console.error("Ошибка сохранения маршрута:", error); showCustomAlert("Не удалось сохранить маршрут.");
            } else {
                showCustomAlert("Маршрут сохранен!");
                hideCreationModal();
            }
        }
        
        function addRouteToMap(route) {
            try {
                const wkt = route.path_wkt || route.path;
                const geoJsonLine = parseWKT(wkt);

                if (!geoJsonLine || geoJsonLine.type !== 'LineString' || !Array.isArray(geoJsonLine.coordinates) || geoJsonLine.coordinates.length < 2) {
                    console.warn(`Не удалось обработать путь для маршрута ${route.id}:`, wkt);
                    return;
                }

                const routeLayer = L.geoJSON(geoJsonLine, {
                    style: { color: '#ff7800', weight: 3 }
                }).on('click', () => showDetailModal('route', route.id));
                routePolylinesLayer.addLayer(routeLayer);
            } catch (e) {
                console.error(`Ошибка при добавлении маршрута ${route.id} на карту.`, e, route);
            }
        }

        // --- ЗАГРУЗКА ДАННЫХ ---
        async function loadInitialMapData() {
            const { data: spots, error: spotsError } = await supabase.from('spots').select('*, location_wkt:location::text');
            if (spotsError) {
                console.error("Ошибка загрузки спотов:", spotsError);
            } else {
                allSpots = spots;
                spotMarkersLayer.clearLayers();
                allSpots.forEach(addSpotToMap);
            }

            const { data: routes, error: routesError } = await supabase.from('routes').select('*, path_wkt:path::text');
            if (routesError) {
                console.error("Ошибка загрузки маршрутов:", routesError);
            } else {
                allRoutes = routes;
                routePolylinesLayer.clearLayers();
                allRoutes.forEach(addRouteToMap);
            }
        }

        // --- SUPABASE и ОБРАБОТЧИКИ ---
        function listenToRealtimeChanges() {
            supabase.channel('public-changes')
              .on('postgres_changes', { event: '*', schema: 'public', table: 'profiles' }, fetchAllProfilesAndDraw)
              .on('postgres_changes', { event: '*', schema: 'public', table: 'posts' }, () => { renderFeed(); renderMyProfileContent(); })
              .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'likes' }, renderFeed)
              .on('postgres_changes', { event: 'DELETE', schema: 'public', table: 'likes' }, renderFeed)
              .on('postgres_changes', { event: '*', schema: 'public', table: 'comments' }, (payload) => {
                  if (commentsModal.classList.contains('visible') && currentReplyTarget.type === 'post') {
                      const changedPostId = payload.new?.post_id || payload.old?.post_id;
                      if (changedPostId && changedPostId === currentReplyTarget.id) {
                          showPostComments(currentReplyTarget.id);
                      }
                  }
                  if (detailModal.classList.contains('visible') && (currentDetailContext.type === 'spot' || currentDetailContext.type === 'route')) {
                      const changedParentId = payload.new?.spot_id || payload.new?.route_id || payload.old?.spot_id || payload.old?.route_id;
                      if (changedParentId === currentDetailContext.id) {
                          loadAndRenderComments(currentDetailContext.type, currentDetailContext.id, 'detail-comments-list');
                      }
                  }
                  renderFeed();
              })
              .on('postgres_changes', { event: '*', schema: 'public', table: 'spots' }, () => { loadInitialMapData(); renderMyProfileContent(); })
              .on('postgres_changes', { event: '*', schema: 'public', table: 'routes' }, () => { loadInitialMapData(); renderMyProfileContent(); })
              .subscribe();
        }

        function setupStaticEventListeners() {
            tg.onEvent('themeChanged', () => applyTheme(tg.themeParams));
            tg.onEvent('backButtonClicked', () => {
                if (commentsModal.classList.contains('visible')) {
                    hideCommentsModal();
                } else if (detailModal.classList.contains('visible')) {
                    hideDetailModal();
                } else if (creationModal.classList.contains('visible')) {
                    hideCreationModal();
                } else if (simplePostModal.classList.contains('visible')) {
                    hideSimplePostModal();
                } else if (qrModal.classList.contains('visible')) {
                    hideQrModal();
                }
            });
            tg.onEvent('qrTextReceived', (data) => {
                if (data.data) {
                    try {
                        const url = new URL(data.data);
                        const startPayload = url.searchParams.get('startapp'); // UPDATED
                        if (startPayload) {
                            // Передаем весь payload в обработчик
                            handleStartParam({ start_param: startPayload });
                        }
                    } catch (e) {
                        console.error("Invalid QR code data", e);
                        showCustomAlert("Неверный QR-код.");
                    }
                }
            });
            // NEW: Settings Button
            tg.SettingsButton.onClick(() => {
                tg.HapticFeedback.impactOccurred('light');
                tg.openTelegramLink(`https://t.me/${BOT_USERNAME}`);
            });
        }

        function setupDynamicEventListeners() {
            document.getElementById('mode-capture').addEventListener('click', () => setMode('capture'));
            document.getElementById('mode-spots').addEventListener('click', () => setMode('spots'));
            document.getElementById('mode-routes').addEventListener('click', () => setMode('routes'));
            
            document.getElementById('save-creation-btn').addEventListener('click', handleSave);
            
            document.getElementById('creation-modal-photo-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const preview = document.getElementById('creation-modal-photo-preview');
                    preview.src = URL.createObjectURL(file);
                    preview.classList.remove('hidden');
                    document.getElementById('creation-modal-photo-icon').classList.add('hidden');
                }
            });
            document.getElementById('simple-post-photo-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    document.getElementById('simple-post-filename').textContent = file.name;
                }
            });

            requestGeoBtn.addEventListener('click', handleGeoRequest);

            recenterBtn.addEventListener('click', () => {
                tg.HapticFeedback.impactOccurred('medium');
                if (lastKnownLocation) map.flyTo(lastKnownLocation, 16);
            });
            
            scanQrBtn.addEventListener('click', () => {
                tg.HapticFeedback.impactOccurred('light');
                tg.showScanQrPopup({ text: 'Наведите на QR-код другого игрока' });
            });

            // UPDATED: Replaced invite button with share button logic
            inviteFriendBtn.addEventListener('click', () => {
                 shareContent('user', telegramUser.id, 'Присоединяйся ко мне в TerraRun и давай захватывать территории вместе!');
            });
            shareProfileBtn.addEventListener('click', () => {
                shareContent('user', telegramUser.id, 'Зацени мой профиль и территории в TerraRun!');
            });
            
            createSimplePostBtn.addEventListener('click', showSimplePostModal);
            
            showQrBtn.addEventListener('click', showQrModal);
            donateBtn.addEventListener('click', () => {
                // Замените 'YOUR_PAYMENT_PROVIDER_TOKEN' на ваш реальный токен
                tg.openInvoice('YOUR_PAYMENT_PROVIDER_TOKEN', (status) => {
                    if (status === 'paid') {
                        showCustomAlert('Спасибо за вашу поддержку!');
                    } else if (status === 'failed') {
                        showCustomAlert('Не удалось обработать платеж.');
                    }
                });
            });

            document.body.addEventListener('click', (event) => {
                const button = event.target.closest('button[data-action], div[data-action]');
                if (!button) return;

                const action = button.dataset.action;
                const id = button.dataset.id || button.dataset.postId;

                if (!action || !id) return;

                if (action === 'like') {
                    toggleLike(button, id);
                } else if (action === 'comment' || action === 'show-post-comments') {
                    showPostComments(id);
                }
            });
        }
        
        function showFallbackScreen(title, message, showRetryButton = false) {
            fallbackContent.innerHTML = `
                <h1 class="text-2xl font-bold mb-4 ${showRetryButton ? 'text-red-500' : ''}">${title}</h1>
                <p class="mb-6" style="color: var(--hint-color);">${message}</p>
                ${showRetryButton ? `<button onclick="window.location.reload()" class="font-bold py-3 px-6 rounded-full" style="background-color: var(--button-color); color: var(--button-text-color);">Попробовать снова</button>` : ''}
            `;
            initialLoader.classList.add('hidden');
            fallbackScreen.classList.remove('hidden');
        }

        function applyTheme(themeParams) {
             document.documentElement.style.setProperty('--bg-color', themeParams.bg_color || '#f3f4f6');
             document.documentElement.style.setProperty('--secondary-bg-color', themeParams.secondary_bg_color || '#ffffff');
             document.documentElement.style.setProperty('--text-color', themeParams.text_color || '#1f2937');
             document.documentElement.style.setProperty('--hint-color', themeParams.hint_color || '#6b7280');
             document.documentElement.style.setProperty('--button-color', themeParams.button_color || '#3b82f6');
             document.documentElement.style.setProperty('--button-text-color', themeParams.button_text_color || '#ffffff');
             document.documentElement.style.setProperty('--border-color', themeParams.bg_color ? shadeColor(themeParams.bg_color, -10) : '#e5e7eb');
             tg.setHeaderColor(themeParams.secondary_bg_color || '#ffffff');
             tg.setBackgroundColor(themeParams.bg_color || '#f3f4f6');
        }
        
        async function upsertUserProfile() {
            if (!telegramUser) throw new Error("Пользователь Telegram не определен для upsertUserProfile.");

            const { data, error } = await supabase.from('profiles').select('*').eq('id', telegramUser.id).single();
            
            if (error && error.code !== 'PGRST116') {
                console.error("Ошибка получения профиля:", error); 
                throw error; 
            } 
            
            if (data) {
                userColor = data.color;
                userTerritory = parseWKT(data.territory_wkt) || parseWKT(data.territory) || data.territory;
            } else {
                userColor = generateColorFromId(telegramUser.id);
                const { error: insertError } = await supabase.from('profiles').insert({ 
                    id: telegramUser.id, 
                    name: telegramUser.first_name, 
                    color: userColor, 
                    area: 0, 
                    photo_url: telegramUser.photo_url || null, 
                    territory: null 
                });
                if (insertError) { 
                    console.error("Ошибка создания профиля:", insertError); 
                    throw insertError; 
                }
            }
        }
        
        async function processRunPath() {
            const startPoint = currentRunPath[0];
            const endPoint = currentRunPath[currentRunPath.length - 1];
            const distance = turf.distance(turf.point(startPoint), turf.point(endPoint), { units: 'meters' });
            if (distance > 50) {
                showCustomAlert('Маршрут не замкнут. Вернитесь к точке старта (в радиус 50м) для захвата.');
                return;
            }
            currentRunPath.push(startPoint);
            const line = turf.lineString(currentRunPath);
            const polygonized = turf.polygonize(line);
            if (polygonized.features.length === 0) {
                showCustomAlert('Не удалось сформировать замкнутую территорию. Вероятно, маршрут пересекал сам себя.');
                return;
            }
            let newCapture = polygonized.features[0];
            if (polygonized.features.length > 1) {
                try {
                    newCapture = turf.union(...polygonized.features);
                } catch (e) {
                    console.error("Turf union error:", e);
                }
            }
            await updateTerritory(newCapture);
        }

        async function updateTerritory(newCapture) {
            try {
                let combinedTerritory = userTerritory ? turf.union(userTerritory, newCapture) : newCapture;
                userTerritory = turf.cleanCoords(combinedTerritory);
                
                await saveUserData();
                refreshAllStats();
                tg.HapticFeedback.notificationOccurred('success');
                const area = turf.area(newCapture);
                const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;
                showCreationModal('post', { 
                    captureData: newCapture,
                    area_captured: area,
                    area_captured_formatted: formattedArea
                });
            } catch (error) {
                console.error("Ошибка в updateTerritory:", error);
                showCustomAlert("Ошибка обработки территории.");
            }
        }

        async function saveUserData() {
            let area = userTerritory ? turf.area(userTerritory) : 0;
            const userData = { id: telegramUser.id, name: telegramUser.first_name, photo_url: telegramUser.photo_url || null, color: userColor, territory: userTerritory, area: area, updated_at: new Date().toISOString() };
            const { error } = await supabase.from('profiles').upsert(userData);
            if (error) console.error('Error saving user data:', error);
        }

        async function handlePostSubmission() {
            const { captureData, area_captured } = currentEditContext;
            const title = document.getElementById('creation-modal-name').value.trim();
            
            if (!title) { showCustomAlert("Пожалуйста, введите название."); return; }

            let photoUrl = null;
            const file = document.getElementById('creation-modal-photo-input').files[0];
            if (file) {
                const filePath = `${telegramUser.id}/${Date.now()}_${file.name}`;
                const { data, error } = await supabase.storage.from('photo').upload(filePath, file);
                if (error) { console.error("Error uploading photo:", error); showCustomAlert("Не удалось загрузить фото."); return; }
                photoUrl = supabase.storage.from('photo').getPublicUrl(data.path).data.publicUrl;
            }

            const postData = {
                user_id: telegramUser.id,
                title: title,
                description: null,
                photo_url: photoUrl,
                territory_captured: captureData,
                area_captured: area_captured,
                user_name: telegramUser.first_name,
                user_avatar_url: telegramUser.photo_url,
                user_color: userColor
            };

            const { error: postError } = await supabase.from('posts').insert(postData);
            
            if (postError) {
                console.error("Error saving post:", postError); showCustomAlert("Не удалось сохранить пост.");
            } else {
                showCustomAlert("Пост успешно опубликован!");
                hideCreationModal();
            }
        }
        
        async function handleSimplePostSave() {
            const description = document.getElementById('simple-post-details').value.trim();
            if (!description) {
                showCustomAlert("Пожалуйста, введите текст поста.");
                return;
            }

            let photoUrl = null;
            const file = document.getElementById('simple-post-photo-input').files[0];
            if (file) {
                const filePath = `${telegramUser.id}/posts/${Date.now()}_${file.name}`;
                const { data, error } = await supabase.storage.from('photo').upload(filePath, file);
                if (error) { console.error("Error uploading photo:", error); showCustomAlert("Не удалось загрузить фото."); return; }
                photoUrl = supabase.storage.from('photo').getPublicUrl(data.path).data.publicUrl;
            }

            const postData = {
                user_id: telegramUser.id,
                title: description.substring(0, 50) + (description.length > 50 ? '...' : ''),
                description: description,
                photo_url: photoUrl,
                user_name: telegramUser.first_name,
                user_avatar_url: telegramUser.photo_url,
                user_color: userColor
            };

            const { error: postError } = await supabase.from('posts').insert(postData);
            
            if (postError) {
                console.error("Error saving post:", postError); showCustomAlert("Не удалось сохранить пост.");
            } else {
                showCustomAlert("Пост успешно опубликован!");
                hideSimplePostModal();
            }
        }


        async function fetchAllProfilesAndDraw() {
            let { data: profiles, error } = await supabase.from('profiles').select('*, territory_wkt:territory::text');
            if (error) { console.error("Error fetching profiles:", error); return; }
            allProfilesData = profiles;
            
            territoriesLayerGroup.clearLayers();
            allUserLayers = {};

            profiles.forEach(profile => {
                if (telegramUser && profile.id === telegramUser.id) {
                    userTerritory = parseWKT(profile.territory_wkt) || profile.territory;
                    userColor = profile.color;
                    refreshAllStats();
                }
                const userLayerGroup = L.layerGroup();
                const territoryGeoJson = parseWKT(profile.territory_wkt || profile.territory);
                if (territoryGeoJson) {
                    L.geoJSON(territoryGeoJson, { style: { color: profile.color, weight: 2, opacity: 0.8, fillColor: profile.color, fillOpacity: 0.4 } }).addTo(userLayerGroup);
                }
                userLayerGroup.addTo(territoriesLayerGroup);
                allUserLayers[profile.id] = userLayerGroup;
            });
            updateLeaderboard(profiles);
        }

        function updateLeaderboard(profiles) {
            profiles.sort((a, b) => (b.area || 0) - (a.area || 0));
            leaderboardDiv.innerHTML = profiles.map((u, index) => {
                const isCurrentUser = telegramUser && u.id === telegramUser.id;
                const name = u.name.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                const displayName = isCurrentUser ? `${name} (Вы)` : name;
                const avatar = u.photo_url || `https://placehold.co/50x50/E5E7EB/4B5563?text=${name.charAt(0)}`;
                const area = u.area || 0;
                const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;
                return `<div class="card-bg rounded-xl shadow-md p-4 flex items-center space-x-4 cursor-pointer hover:bg-gray-50 transition" onclick="showDetailModal('user', ${u.id})">
                            <span class="text-xl font-bold w-8" style="color: var(--hint-color);">${index + 1}</span>
                            <img src="${avatar}" class="w-12 h-12 rounded-full" alt="avatar">
                            <div class="flex-grow">
                                <p class="font-bold">${displayName}</p>
                                <p class="text-sm" style="color: var(--hint-color);">${formattedArea}</p>
                            </div>
                        </div>`
            }).join('');
        }

        function refreshAllStats() {
            let area = 0;
            if (userTerritory) {
                try {
                    area = turf.area(userTerritory);
                } catch(e) {
                    console.warn("Could not calculate area for user territory", e);
                    area = 0;
                }
            }
            if (isNaN(area)) area = 0;
            const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;
            profileAreaDisplay.textContent = formattedArea;
        }

        async function renderFeed() {
            const { data: posts, error: postsError } = await supabase.from('posts').select('*').order('created_at', { ascending: false });
            if (postsError) { console.error("Error fetching posts:", postsError); return; }
            const postIds = posts.map(p => p.id);
            if (postIds.length === 0) {
                feedContainer.innerHTML = '<p class="text-center text-gray-500">В ленте пока нет постов.</p>';
                return;
            }
            const { data: likes, error: likesError } = await supabase.from('likes').select('*').in('post_id', postIds);
            const { data: comments, error: commentsError } = await supabase.from('comments').select('id, post_id').in('post_id', postIds);
            if (likesError || commentsError) { console.error("Error fetching activity:", likesError, commentsError); return; }
            const likesByPost = likes.reduce((acc, like) => { (acc[like.post_id] = acc[like.post_id] || []).push(like); return acc; }, {});
            const commentsByPost = comments.reduce((acc, comment) => { (acc[comment.post_id] = acc[comment.post_id] || []).push(comment); return acc; }, {});
            
            const feedHTML = posts.map(post => generatePostHTML(post, likesByPost[post.id] || [], commentsByPost[post.id] || [])).join('');
            feedContainer.innerHTML = feedHTML || '<p class="text-center text-gray-500">В ленте пока нет постов.</p>';
            
            posts.forEach(post => {
                if (post.territory_captured) {
                    const mapContainer = document.getElementById(`mini-map-${post.id}`);
                    if (mapContainer && !mapContainer._leaflet_id) {
                        const miniMap = L.map(mapContainer, { zoomControl: false, attributionControl: false, dragging: false, scrollWheelZoom: false, doubleClickZoom: false });
                        L.tileLayer(MAP_TILE_URL, { maxZoom: 19, accessToken: MAPBOX_ACCESS_TOKEN, tileSize: 512, zoomOffset: -1 }).addTo(miniMap);
                        const territoryLayer = L.geoJSON(post.territory_captured, { style: { color: post.user_color, weight: 2, opacity: 0.8, fillColor: post.user_color, fillOpacity: 0.5 } }).addTo(miniMap);
                        miniMap.fitBounds(territoryLayer.getBounds(), { padding: [10, 10] });
                    }
                }
            });

            // NEW: Логика для прокрутки к посту из диплинка
            if (scrollToPostId) {
                const postElement = document.getElementById(`post-${scrollToPostId}`);
                if (postElement) {
                    // Даем время на отрисовку, особенно для карт
                    setTimeout(() => {
                        postElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Добавляем временную подсветку
                        postElement.style.transition = 'background-color 0.5s ease';
                        postElement.style.backgroundColor = 'color-mix(in srgb, var(--button-color) 15%, transparent)';
                        setTimeout(() => {
                            postElement.style.backgroundColor = '';
                        }, 2500); // Подсветка на 2.5 секунды
                    }, 200); // Небольшая задержка
                }
                scrollToPostId = null; // Сбрасываем ID после использования
            }
        }
        
        function generatePostHTML(post, likes, comments) {
            const avatar = post.user_avatar_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${post.user_name.charAt(0)}`;
            const area = post.area_captured || 0;
            const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;
            const userHasLiked = telegramUser && likes.some(like => like.user_id === telegramUser.id);
            return `<div class="card-bg rounded-2xl shadow-lg overflow-hidden" id="post-${post.id}">
                        <div class="p-4">
                            <div class="flex items-center space-x-3 cursor-pointer" onclick="showDetailModal('user', ${post.user_id})"><img src="${avatar}" class="w-10 h-10 rounded-full" alt="avatar"><div><p class="font-bold">${post.user_name}</p><p class="text-xs" style="color: var(--hint-color);">${new Date(post.created_at).toLocaleString('ru-RU')}</p></div></div>
                            <p class="mt-4 font-semibold">${post.title.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</p>
                            ${post.description ? `<p class="mt-2 text-sm" style="color: var(--text-color);">${post.description.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</p>` : ''}
                        </div>
                        ${post.photo_url ? `<img src="${post.photo_url}" class="w-full h-64 object-cover" alt="Post photo">` : ''}
                        ${post.territory_captured ? `<div id="mini-map-${post.id}" class="h-48 w-full mini-map"></div>` : ''}
                        <div class="p-4">
                            ${post.area_captured ? `<p class="font-semibold">Захвачено: <span class="font-bold" style="color: var(--button-color);">${formattedArea}</span></p>` : ''}
                            <div class="flex items-center justify-between mt-3">
                                <div class="flex items-center space-x-6" style="color: var(--hint-color);">
                                    <button class="like-btn flex items-center space-x-1 hover:text-red-500 transition ${userHasLiked ? 'liked' : ''}" data-action="like" data-post-id="${post.id}">
                                        <i class="fa-${userHasLiked ? 'solid' : 'regular'} fa-heart h-6 w-6"></i>
                                        <span data-likes-count>${likes.length}</span>
                                    </button>
                                    <button class="flex items-center space-x-1 hover:text-blue-500 transition" data-action="comment" data-post-id="${post.id}">
                                        <i class="fa-regular fa-comment h-6 w-6"></i>
                                        <span>${comments.length}</span>
                                    </button>
                                </div>
                                <button class="flex items-center space-x-1 hover:text-blue-500 transition" onclick="shareContent('post', ${post.id}, 'Оцени мой пост в TerraRun!')" style="color: var(--hint-color);">
                                    <i class="fa-solid fa-arrow-up-from-bracket h-5 w-5"></i>
                                </button>
                            </div>
                        </div>
                    </div>`;
        }

        async function toggleLike(buttonElement, postId) {
            if (!telegramUser) {
                showCustomAlert('Пользователь не определен. Попробуйте перезагрузить приложение.');
                return;
            }
            tg.HapticFeedback.impactOccurred('light');
            
            const hasLiked = buttonElement.classList.contains('liked');
            const countSpan = buttonElement.querySelector('[data-likes-count]');
            const icon = buttonElement.querySelector('i');
            let currentCount = parseInt(countSpan.textContent, 10);

            buttonElement.classList.toggle('liked');
            icon.classList.toggle('fa-solid', !hasLiked);
            icon.classList.toggle('fa-regular', hasLiked);
            countSpan.textContent = hasLiked ? currentCount - 1 : currentCount + 1;

            try {
                if (hasLiked) {
                    await supabase.from('likes').delete().match({ post_id: postId, user_id: telegramUser.id });
                } else {
                    await supabase.from('likes').insert({ post_id: postId, user_id: telegramUser.id });
                }
            } catch (error) {
                console.error("Ошибка лайка:", error);
                buttonElement.classList.toggle('liked');
                icon.classList.toggle('fa-solid');
                icon.classList.toggle('fa-regular');
                countSpan.textContent = currentCount;
                showCustomAlert('Не удалось поставить лайк. Попробуйте снова.');
            }
        }
        
        // --- СИСТЕМА КОММЕНТАРИЕВ ---

        async function fetchComments(type, id) {
            let query = supabase.from('comments').select('*, profiles(id, name, photo_url)');
            if (type === 'post') {
                query = query.eq('post_id', id);
            } else if (type === 'spot') {
                query = query.eq('spot_id', id);
            } else if (type === 'route') {
                query = query.eq('route_id', id);
            }
            const { data, error } = await query.order('created_at', { ascending: true });
            return { data, error };
        }
        
        async function showPostComments(postId) {
            tg.HapticFeedback.impactOccurred('medium');
            tg.BackButton.show();
            currentReplyTarget = { type: 'post', id: postId, parentCommentId: null };
            cancelReply();
            
            const modalBody = document.getElementById('comments-modal-body');
            modalBody.innerHTML = '<div class="text-center p-8"><svg class="animate-spin mx-auto h-8 w-8 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></div>';
            commentsModal.classList.add('visible');
            
            const { data: comments, error } = await fetchComments('post', postId);
            if (error) { modalBody.innerHTML = `<p class="text-center p-4 text-red-500">Ошибка загрузки комментариев</p>`; return; }

            renderCommentTree(comments, modalBody);
        }

        async function loadAndRenderComments(type, id, containerId) {
             const container = document.getElementById(containerId);
             if (!container) return;
             container.innerHTML = '<p class="text-center text-gray-500">Загрузка комментариев...</p>';
             
             const { data: comments, error } = await fetchComments(type, id);
             if (error) { container.innerHTML = `<p class="text-center p-4 text-red-500">Ошибка загрузки комментариев</p>`; return; }

             renderCommentTree(comments, container, 'detail');
        }

        function renderCommentTree(comments, container, context = 'post') {
            const commentsByParent = comments.reduce((acc, comment) => { (acc[comment.parent_comment_id || 'root'] = acc[comment.parent_comment_id || 'root'] || []).push(comment); return acc; }, {});
            const rootComments = commentsByParent['root'] || [];
            container.innerHTML = rootComments.length ? rootComments.map(c => generateCommentHTML(c, commentsByParent, context)).join('') : '<p class="text-center text-gray-500 py-4">Нет комментариев</p>';
        }

        function hideCommentsModal() {
            tg.BackButton.hide();
            commentsModal.classList.remove('visible');
        }

        function generateCommentHTML(comment, commentsByParent, context = 'post') {
            const replies = commentsByParent[comment.id] || [];
            const profileName = comment.profiles ? comment.profiles.name : 'Аноним';
            const avatar = comment.profiles ? (comment.profiles.photo_url || `https://placehold.co/32x32/E5E7EB/4B5563?text=${profileName.charAt(0)}`) : 'https://placehold.co/32x32';
            const replyFn = context === 'post' ? 'setReplyMode' : 'setDetailReplyMode';
            const parentId = comment.post_id || comment.spot_id || comment.route_id;

            return `<div class="flex items-start space-x-3 mt-4">
                        <img src="${avatar}" class="w-8 h-8 rounded-full">
                        <div class="flex-1">
                            <div class="rounded-lg p-2" style="background-color: var(--bg-color);">
                                <p class="font-bold text-sm">${profileName}</p>
                                <p class="text-sm">${comment.content}</p>
                            </div>
                            <div class="text-xs mt-1">
                                <button onclick="${replyFn}('${parentId}', ${comment.id}, '${profileName.replace(/'/g, "\\'")}')" class="font-medium" style="color: var(--hint-color);">Ответить</button>
                            </div>
                            <div class="pl-4 border-l-2">${replies.map(reply => generateCommentHTML(reply, commentsByParent, context)).join('')}</div>
                        </div>
                    </div>`;
        }
        
        function setReplyMode(postId, parentCommentId, parentAuthorName) {
            currentReplyTarget = { type: 'post', id: postId, parentCommentId };
            document.getElementById('reply-indicator-text').textContent = `Ответ: ${parentAuthorName}`;
            document.getElementById('reply-indicator').classList.remove('hidden');
            document.getElementById('main-comment-input').focus();
        }

        function cancelReply() {
            currentReplyTarget.parentCommentId = null;
            document.getElementById('reply-indicator').classList.add('hidden');
        }

        async function postComment() {
            const { type, id, parentCommentId } = currentReplyTarget;
            if (!id || !telegramUser) return;
            const inputElement = document.getElementById('main-comment-input');
            const content = inputElement.value.trim();
            if (!content) return;
            
            const commentData = { 
                post_id: id,
                user_id: telegramUser.id, 
                parent_comment_id: parentCommentId, 
                content: content 
            };
            const { error } = await supabase.from('comments').insert(commentData);
            if (error) { showCustomAlert('Ошибка отправки'); } else { inputElement.value = ''; cancelReply(); }
        }

        function setDetailReplyMode(id, parentCommentId, parentAuthorName) {
            currentDetailContext.replyTo = { parentCommentId };
            document.getElementById('detail-reply-indicator-text').textContent = `Ответ: ${parentAuthorName}`;
            document.getElementById('detail-reply-indicator').classList.remove('hidden');
            document.getElementById('detail-comment-input').focus();
        }
        
        function cancelDetailReply() {
            currentDetailContext.replyTo = null;
            document.getElementById('detail-reply-indicator').classList.add('hidden');
        }

        async function postDetailComment() {
            const { type, id, replyTo } = currentDetailContext;
            if (!id || !telegramUser) return;
            const inputElement = document.getElementById('detail-comment-input');
            const content = inputElement.value.trim();
            if (!content) return;

            const parentCommentId = replyTo ? replyTo.parentCommentId : null;

            const commentData = {
                user_id: telegramUser.id,
                parent_comment_id: parentCommentId,
                content: content
            };
            if (type === 'spot') {
                commentData.spot_id = id;
            } else if (type === 'route') {
                commentData.route_id = id;
            }

            const { error } = await supabase.from('comments').insert(commentData);

            if (error) { 
                showCustomAlert('Ошибка отправки комментария.'); 
                console.error("Comment post error:", error);
            } else { 
                inputElement.value = ''; 
                cancelDetailReply();
                loadAndRenderComments(type, id, 'detail-comments-list');
            }
        }


        function switchMainProfileTab(tabName) {
            document.querySelectorAll('#profile-view .profile-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('#profile-view .profile-tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`profile-tab-${tabName}`).classList.add('active');
            document.getElementById(`profile-content-${tabName}`).classList.add('active');
        }

        async function renderMyProfileContent() {
            if (!telegramUser) return;
            const userId = telegramUser.id;

            const [postsRes, spotsRes, routesRes] = await Promise.all([
                supabase.from('posts').select('*').eq('user_id', userId).order('created_at', { ascending: false }),
                supabase.from('spots').select('*, location_wkt:location::text').eq('user_id', userId).order('created_at', { ascending: false }),
                supabase.from('routes').select('*, path_wkt:path::text').eq('user_id', userId).order('created_at', { ascending: false })
            ]);

            const posts = postsRes.data || [];
            const postIds = posts.map(p => p.id);
            const likesByPost = {};
            const commentsByPost = {};
            if (postIds.length > 0) {
                const { data: likes } = await supabase.from('likes').select('*').in('post_id', postIds);
                const { data: comments } = await supabase.from('comments').select('id, post_id').in('post_id', postIds);
                if(likes) likes.forEach(like => (likesByPost[like.post_id] = likesByPost[like.post_id] || []).push(like));
                if(comments) comments.forEach(comment => (commentsByPost[comment.post_id] = commentsByPost[comment.post_id] || []).push(comment));
            }
            const postsContainer = document.getElementById('profile-content-posts');
            postsContainer.innerHTML = posts.length > 0 ? posts.map(p => generatePostHTML(p, likesByPost[p.id] || [], commentsByPost[p.id] || [])).join('') : '<p class="text-center text-gray-500 py-4">У вас нет постов.</p>';
            document.getElementById('profile-tab-posts').textContent = `Посты (${posts.length})`;

            const spots = spotsRes.data || [];
            const spotsContainer = document.getElementById('profile-content-spots');
            spotsContainer.innerHTML = spots.length > 0 ? spots.map(generateMiniSpotHTML).join('') : '<p class="text-center text-gray-500 py-4">У вас нет спотов.</p>';
            document.getElementById('profile-tab-spots').textContent = `Споты (${spots.length})`;

            const routes = routesRes.data || [];
            const routesContainer = document.getElementById('profile-content-routes');
            routesContainer.innerHTML = routes.length > 0 ? routes.map(generateMiniRouteHTML).join('') : '<p class="text-center text-gray-500 py-4">У вас нет маршрутов.</p>';
            document.getElementById('profile-tab-routes').textContent = `Маршруты (${routes.length})`;
        }
        
        // --- QR Code Modal ---
        function showQrModal() {
            tg.HapticFeedback.impactOccurred('light');
            const qrContainer = document.getElementById('qrcode');
            qrContainer.innerHTML = '';
            new QRCode(qrContainer, {
                text: `https://t.me/${BOT_USERNAME}?startapp=user_${telegramUser.id}`, // UPDATED: to startapp
                width: 200,
                height: 200,
                colorDark : "#000000",
                colorLight : "#ffffff",
                correctLevel : QRCode.CorrectLevel.H
            });
            qrModal.classList.add('visible');
            tg.BackButton.show();
        }

        function hideQrModal() {
            qrModal.classList.remove('visible');
            tg.BackButton.hide();
        }
        
        // --- Handle Start Param ---
        function handleStartParam() {
            const startParam = tg.initDataUnsafe.start_param;
            if (!startParam) return;

            const parts = startParam.split('_');
            const type = parts.length > 1 ? parts[0] : 'user'; // Default to 'user' for old links
            const id = parts.length > 1 ? parts[1] : startParam;
            const numericId = parseInt(id, 10);

            if (isNaN(numericId)) {
                console.warn("Invalid ID in start_param:", startParam);
                return;
            }

            // Даем приложению немного времени на отрисовку перед показом модальных окон
            setTimeout(() => {
                switch (type) {
                    case 'user':
                        showDetailModal('user', numericId);
                        break;
                    case 'post':
                        // UPDATED: Показываем ленту и готовимся к прокрутке
                        showView('feed-view');
                        scrollToPostId = numericId;
                        // renderFeed() будет вызван при инициализации или через real-time, он подхватит этот ID
                        break;
                    case 'route':
                        showDetailModal('route', numericId);
                        break;
                    case 'spot':
                        showDetailModal('spot', numericId);
                        break;
                    default:
                        console.warn("Unknown start_param type:", type);
                        // Обратная совместимость для старых ссылок только с ID пользователя
                        if (/^\d+$/.test(startParam)) {
                            showDetailModal('user', parseInt(startParam));
                        }
                }
            }, 500); 
        }
        
        // --- Custom Alert/Confirm ---
        function showCustomAlert(message) {
            tg.showAlert(message);
        }

        function showCustomConfirm(message, callback) {
            tg.showConfirm(message, (ok) => {
                if (ok) callback();
            });
        }


        // --- ПРИВЯЗКА ГЛОБАЛЬНЫХ ФУНКЦИЙ И ЗАПУСК ---
        window.showView = showView;
        window.hideDetailModal = hideDetailModal;
        window.toggleLike = toggleLike;
        window.showPostComments = showPostComments;
        window.hideCommentsModal = hideCommentsModal;
        window.setReplyMode = setReplyMode;
        window.cancelReply = cancelReply;
        window.postComment = postComment;
        window.showDetailModal = showDetailModal;
        window.switchProfileTab = switchProfileTab;
        window.switchMainProfileTab = switchMainProfileTab;
        window.navigateToMapObject = navigateToMapObject;
        window.hideSimplePostModal = hideSimplePostModal;
        window.handleSimplePostSave = handleSimplePostSave;
        window.hideCreationModal = hideCreationModal;
        window.postDetailComment = postDetailComment;
        window.setDetailReplyMode = setDetailReplyMode;
        window.cancelDetailReply = cancelDetailReply;
        window.hideQrModal = hideQrModal;
        window.shareContent = shareContent;
        
        document.addEventListener('DOMContentLoaded', main);
    </script>

</body>
</html>
