<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>TerraRun | Обновление 3D</title>

    <!-- Подключение Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>


    <script src='https://api.mapbox.com/mapbox-gl-js/v3.4.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.4.0/mapbox-gl.css' rel='stylesheet' />

    <!-- Подключение Turf.js для гео-анализа -->
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
    
    <!-- Подключение Telegram Web App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- Подключение Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <!-- Иконочные шрифты -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">
    
    <!-- Шрифты Google -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #f3f4f6;
            --secondary-bg-color: #ffffff;
            --text-color: #1f2937;
            --hint-color: #6b7280;
            --button-color: #3b82f6;
            --button-text-color: #ffffff;
            --destructive-color: #ef4444;
            --success-color: #22c55e;
            --star-color: #facc15;
            --border-color: #e5e7eb;
            --button-color-rgb: 59, 130, 246;
            --secondary-bg-color-rgb: 255, 255, 255;
        }

        /* Адаптация под безопасные зоны iOS */
        body {
            padding-top: constant(safe-area-inset-top);
            padding-top: env(safe-area-inset-top);
            overscroll-behavior: none;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            font-family: 'Inter', sans-serif;
        }

        /* Улучшенная блокировка скролла при открытом модальном окне */
        body.modal-open {
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        #map {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        .view {
            display: none;
            height: 100vh; /* Занимает всю высоту видимой области */
            overflow-y: auto;
            -webkit-overflow-scrolling: touch; /* Плавный скролл на iOS */
            transition: opacity 0.3s ease-in-out;
            background-color: var(--bg-color);
            box-sizing: border-box;
        }
        
        /* Паддинг для контента, чтобы он не заезжал под навбар */
        #feed-view, #top-view, #profile-view {
            padding-bottom: calc(80px + 1rem + env(safe-area-inset-bottom));
        }

        .view.active {
            display: block;
        }
        .nav-btn.active i, .nav-btn.active span {
            color: var(--button-color);
        }
        .nav-btn span, .nav-btn i {
             color: var(--hint-color);
        }
        .card-bg {
            background-color: var(--secondary-bg-color);
        }
        #bottom-navbar {
            height: calc(80px + env(safe-area-inset-bottom));
            padding-bottom: env(safe-area-inset-bottom);
            background-color: rgba(var(--secondary-bg-color-rgb), 0.8);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-top: 1px solid var(--border-color);
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .avatar-marker {
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 15px rgba(0,0,0,0.4);
            background-size: cover;
            background-position: center;
            transition: transform 0.2s ease-in-out, left 0.5s linear, top 0.5s linear;
            cursor: pointer;
        }
        .avatar-marker:hover {
            transform: scale(1.1);
        }
        .current-user-marker {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 2px 15px rgba(0,0,0,0.4), 0 0 0 0 rgba(var(--button-color-rgb), 0.7); }
            70% { box-shadow: 0 2px 15px rgba(0,0,0,0.4), 0 0 0 15px rgba(var(--button-color-rgb), 0); }
            100% { box-shadow: 0 2px 15px rgba(0,0,0,0.4), 0 0 0 0 rgba(var(--button-color-rgb), 0); }
        }
        .like-btn.liked i {
            color: var(--destructive-color);
            font-weight: 900; /* Solid heart */
        }
        #initial-loader {
            background-color: var(--bg-color);
        }
        #map-top-panel {
            position: fixed;
            top: calc(1rem + env(safe-area-inset-top));
            left: 0;
            right: 0;
            z-index: 20;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0 1rem;
            pointer-events: none;
        }
        #mode-switcher {
            background-color: rgba(var(--secondary-bg-color-rgb), 0.8);
            backdrop-filter: blur(10px);
            border-radius: 9999px;
            padding: 0.25rem;
            display: flex;
            gap: 0.25rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            pointer-events: all;
        }
        #map-controls-right {
            pointer-events: all;
        }
        .mode-btn {
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--hint-color);
            transition: all 0.2s ease-in-out;
            border: none;
            background-color: transparent;
        }
        .mode-btn.active {
            background-color: var(--button-color);
            color: var(--button-text-color);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        #map-action-container {
            position: fixed;
            left: 0;
            right: 0;
            z-index: 20;
            display: flex;
            justify-content: center;
            pointer-events: none;
            bottom: calc(80px + 1rem + env(safe-area-inset-bottom));
            transition: bottom 0.3s ease-in-out, transform 0.3s ease-in-out;
            transform: translateY(200%); /* Start hidden */
        }
        #map-action-container.visible {
            transform: translateY(0); /* Animate in */
        }
        
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0,0,0,0.4);
            display: flex;
            z-index: 50;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .bottom-sheet-modal {
            align-items: flex-end;
        }
        .bottom-sheet-content {
            width: 100%;
            background-color: var(--secondary-bg-color);
            border-radius: 1.5rem 1.5rem 0 0;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform 0.3s ease-in-out;
            max-height: calc(100vh - env(safe-area-inset-top) - 1rem); /* Safe upper limit */
        }
        .modal-overlay.visible .bottom-sheet-content {
            transform: translateY(0);
        }
        .grabber {
            width: 3rem;
            height: 0.375rem;
            background-color: #d1d5db;
            border-radius: 9999px;
            margin: 0.75rem auto;
            flex-shrink: 0;
        }
        
        .profile-tab, .feed-tab {
            flex-grow: 1;
            text-align: center;
            padding: 0.75rem 0.5rem;
            font-weight: 600;
            color: var(--hint-color);
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .profile-tab.active, .feed-tab.active {
            color: var(--button-color);
            border-bottom-color: var(--button-color);
        }
        .profile-tab-content, .feed-tab-content {
            display: none;
        }
        .profile-tab-content.active, .feed-tab-content.active {
            display: block;
        }
        
        /* Skeleton Loader Styles */
        .skeleton {
            background-color: #e2e8f0;
            border-radius: 0.5rem;
            animation: pulse-bg 1.5s infinite;
        }
        @keyframes pulse-bg {
            50% { background-color: #cbd5e1; }
        }
        
        .form-input, .form-textarea, .form-select {
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
            width: 100%;
        }
        .form-input:focus, .form-textarea:focus, .form-select:focus {
            outline: none;
            border-color: var(--button-color);
            box-shadow: 0 0 0 2px rgba(var(--button-color-rgb), 0.2);
        }
        /* Стили для кастомного инпута даты-времени */
        .datetime-input-wrapper {
            position: relative;
        }
        .datetime-input-wrapper input[type="datetime-local"]::-webkit-calendar-picker-indicator {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            color: transparent;
            background: transparent;
            cursor: pointer;
        }
        /* Mapbox Overrides */
        .mapboxgl-ctrl-group button {
            background-color: rgba(var(--secondary-bg-color-rgb), 0.8) !important;
            backdrop-filter: blur(10px) !important;
            -webkit-backdrop-filter: blur(10px) !important;
            border-radius: 9999px !important;
        }
         .mapboxgl-ctrl-group {
            background: transparent !important;
            border-radius: 9999px !important;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1) !important;
        }
        .mapboxgl-ctrl-geolocate, .mapboxgl-ctrl-compass {
            color: var(--text-color) !important;
        }
    </style>
</head>
<body class="font-sans antialiased overflow-hidden">
    
    <!-- Начальный загрузчик -->
    <div id="initial-loader" class="fixed inset-0 flex flex-col items-center justify-center z-50">
        <svg class="animate-spin h-10 w-10 mb-4" style="color: var(--button-color);" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
        <p id="loader-text" class="text-lg font-semibold" style="color: var(--text-color);">Загрузка TerraRun...</p>
    </div>

    <!-- Экран-заглушка / Ошибка -->
    <div id="fallback-screen" class="fixed inset-0 flex items-center justify-center p-4 z-40 hidden">
        <div id="fallback-content" class="text-center card-bg p-8 rounded-2xl shadow-lg max-w-sm"></div>
    </div>

    <!-- Основной контейнер приложения -->
    <div id="app-container" class="hidden">
        <!-- Вид 1: Карта -->
        <div id="map-view" class="view active">
            <div id="map"></div>
            
            <div id="map-center-controls" class="fixed inset-0 z-20 flex justify-center items-center pointer-events-none hidden">
                <button id="request-geo-btn" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-full shadow-lg flex items-center gap-2 pointer-events-auto">
                    <i class="fa-solid fa-location-arrow h-5 w-5"></i>
                    <span id="request-geo-text">Дать доступ к гео</span>
                    <svg id="request-geo-loader" class="animate-spin h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                </button>
            </div>
            
            <div id="map-top-panel">
                <div class="w-12"></div>
                <div class="flex-grow flex justify-center">
                     <div id="mode-switcher" class="hidden">
                         <button id="mode-spots" class="mode-btn active">Споты</button>
                         <button id="mode-routes" class="mode-btn">Маршруты</button>
                     </div>
                </div>
                <div id="map-controls-right" class="flex flex-col items-end gap-2">
                    <!-- Mapbox controls will be added here via JS -->
                </div>
            </div>
            
            <div id="map-action-container">
                <button id="map-action-btn" class="text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all duration-300 flex items-center gap-2 pointer-events-auto">
                    <i id="map-action-icon" class="fa-solid fa-play h-5 w-5"></i>
                    <span id="map-action-text"></span>
                </button>
            </div>
        </div>

        <!-- Вид 2: Лента -->
        <div id="feed-view" class="view p-4 fade-in">
            <div class="flex justify-between items-center mb-4 px-2">
                <h1 class="text-3xl font-bold">Лента</h1>
                <button id="feed-create-btn" class="p-2 rounded-full hover:bg-gray-200" style="background-color: var(--secondary-bg-color);">
                    <i class="fa-solid fa-plus h-7 w-7" style="color: var(--button-color);"></i>
                </button>
            </div>
            
            <div class="flex border-b sticky top-0 z-10 overflow-x-auto" style="background-color: var(--bg-color);">
                <div id="feed-tab-posts" class="feed-tab active" onclick="switchFeedTab('posts')">Посты</div>
                <div id="feed-tab-events" class="feed-tab" onclick="switchFeedTab('events')">Покатушки</div>
                <div id="feed-tab-spots" class="feed-tab" onclick="switchFeedTab('spots')">Споты</div>
                <div id="feed-tab-routes" class="feed-tab" onclick="switchFeedTab('routes')">Маршруты</div>
            </div>

            <!-- Контент для табов -->
            <div id="feed-content-posts" class="feed-tab-content active mt-4 space-y-4"></div>
            <div id="feed-content-events" class="feed-tab-content mt-4 space-y-4"></div>
            <div id="feed-content-spots" class="feed-tab-content mt-4 grid grid-cols-1 sm:grid-cols-2 gap-4"></div>
            <div id="feed-content-routes" class="feed-tab-content mt-4 space-y-4"></div>
        </div>

        <!-- Вид 3: Пользователи -->
        <div id="top-view" class="view p-4 fade-in">
            <div class="flex justify-between items-center mb-6 px-2">
                <h1 class="text-3xl font-bold">Пользователи</h1>
            </div>
            <div id="leaderboard" class="space-y-3"></div>
        </div>

        <!-- Вид 4: Профиль -->
        <div id="profile-view" class="view p-4 fade-in">
            <h1 class="text-3xl font-bold mb-6 px-2">Профиль</h1>
            <div class="card-bg rounded-2xl shadow-lg p-6 flex flex-col items-center space-y-4">
                <div id="profile-avatar-wrapper" class="w-24 h-24 rounded-full border-4 flex-shrink-0">
                    <img src="https://placehold.co/96x96/E2E8F0/4A5568?text=?" id="profile-avatar-img" class="w-full h-full rounded-full object-cover" alt="avatar">
                </div>
                <div class="text-center">
                    <h2 id="profile-name" class="text-2xl font-bold">Загрузка...</h2>
                </div>
                <div class="w-full pt-4 mt-4 border-t" style="border-color: var(--border-color);">
                    <div class="flex justify-center gap-8 w-full">
                        <button id="share-profile-btn" class="flex flex-col items-center space-y-1 transition-opacity hover:opacity-70">
                            <div class="p-3 rounded-full" style="background-color: rgba(var(--button-color-rgb), 0.15);"><i class="fa-solid fa-arrow-up-from-bracket h-6 w-6" style="color: var(--button-color);"></i></div>
                            <span class="text-xs font-medium" style="color: var(--hint-color);">Поделиться</span>
                        </button>
                    </div>
                </div>
            </div>
             <!-- Табы -->
            <div class="flex border-b mt-6 sticky top-0 z-10 overflow-x-auto" style="background-color: var(--bg-color);">
                <div id="profile-tab-posts" class="profile-tab active" onclick="switchMainProfileTab('posts')">Посты</div>
                <div id="profile-tab-events" class="profile-tab" onclick="switchMainProfileTab('events')">Покатушки</div>
                <div id="profile-tab-spots" class="profile-tab" onclick="switchMainProfileTab('spots')">Споты</div>
                <div id="profile-tab-routes" class="profile-tab" onclick="switchMainProfileTab('routes')">Маршруты</div>
            </div>

            <div id="profile-content-posts" class="profile-tab-content active mt-4 space-y-4"></div>
            <div id="profile-content-events" class="profile-tab-content mt-4 space-y-4"></div>
            <div id="profile-content-spots" class="profile-tab-content mt-4 grid grid-cols-1 sm:grid-cols-2 gap-4"></div>
            <div id="profile-content-routes" class="profile-tab-content mt-4 space-y-4"></div>
        </div>
    </div>

    <!-- Нижний навбар -->
    <nav id="bottom-navbar" class="hidden fixed bottom-0 left-0 right-0 flex justify-evenly items-center z-20">
        <button class="nav-btn active flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('map-view')"><i class="fa-solid fa-map-location-dot h-7 w-7"></i><span>Карта</span></button>
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('feed-view')"><i class="fa-solid fa-newspaper h-7 w-7"></i><span>Лента</span></button>
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('top-view')"><i class="fa-solid fa-users h-7 w-7"></i><span>Люди</span></button>
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('profile-view')"><i class="fa-solid fa-user h-7 w-7"></i><span>Профиль</span></button>
    </nav>
    
    <!-- Модальное окно создания простого поста -->
    <div id="simple-post-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideSimplePostModal()">
        <div id="simple-post-content" class="bottom-sheet-content" style="height: auto;">
            <div class="grabber" onclick="hideSimplePostModal()"></div>
            <div class="p-4 space-y-4 flex flex-col">
                <div class="flex justify-between items-center flex-shrink-0">
                    <h2 class="text-2xl font-bold">Новый пост</h2>
                    <button onclick="hideSimplePostModal()" class="p-2 rounded-full hover:bg-gray-200"><i class="fa-solid fa-times"></i></button>
                </div>
                <div class="flex-grow space-y-4">
                    <p style="color: var(--hint-color);">Поделитесь своими мыслями с сообществом.</p>
                    <textarea id="simple-post-details" class="form-textarea mt-1 block w-full" rows="4" placeholder="Что у вас нового?"></textarea>
                    <div id="simple-post-filename" class="text-sm text-gray-500 truncate"></div>
                </div>
                <div class="flex justify-between items-center pt-4 flex-shrink-0">
                    <div class="flex items-center gap-2">
                        <button id="simple-post-gallery-btn" class="cursor-pointer p-2 rounded-full hover:bg-gray-200">
                            <i class="fa-solid fa-images h-7 w-7" style="color: var(--hint-color);"></i>
                        </button>
                        <button id="simple-post-camera-btn" class="cursor-pointer p-2 rounded-full hover:bg-gray-200">
                            <i class="fa-solid fa-camera h-7 w-7" style="color: var(--hint-color);"></i>
                        </button>
                    </div>
                    <button onclick="handleSimplePostSave()" class="text-white font-bold py-2 px-6 rounded-full transition-all" style="background-color: var(--button-color);">Опубликовать</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно создания Спота/Маршрута -->
    <div id="creation-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideCreationModal()">
        <div class="bottom-sheet-content">
            <div class="grabber" onclick="hideCreationModal()"></div>
            <div id="creation-modal-body" class="flex-grow overflow-y-auto p-4 space-y-4">
                <h2 id="creation-modal-title" class="text-2xl font-bold"></h2>
                <p id="creation-modal-description" style="color: var(--hint-color);"></p>
                <div>
                    <label for="creation-modal-name" class="block text-sm font-medium mb-1">Название</label>
                    <input type="text" id="creation-modal-name" class="form-input w-full" placeholder="Например, 'Красивый вид'">
                </div>
                <div id="creation-modal-details-section">
                    <label for="creation-modal-details" class="block text-sm font-medium mb-1">Описание</label>
                    <textarea id="creation-modal-details" rows="3" class="form-textarea w-full" placeholder="Опишите это место или маршрут..."></textarea>
                </div>
                <div id="creation-modal-photo-section">
                    <label class="block text-sm font-medium mb-1">Фото</label>
                    <div class="mt-1">
                        <img id="creation-modal-photo-preview" src="" alt="Предпросмотр фото" class="hidden w-full h-auto mb-4 rounded-lg object-cover max-h-48">
                        <div class="flex gap-3">
                            <button id="creation-gallery-btn" class="w-full flex items-center justify-center gap-2 p-3 rounded-xl" style="background-color: var(--bg-color); color: var(--text-color);">
                                <i class="fa-solid fa-images"></i>
                                <span>Из галереи</span>
                            </button>
                            <button id="creation-camera-btn" class="w-full flex items-center justify-center gap-2 p-3 rounded-xl text-white" style="background-color: var(--button-color);">
                                <i class="fa-solid fa-camera"></i>
                                <span>Сделать снимок</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="flex justify-end space-x-3 pt-4">
                    <button onclick="hideCreationModal()" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-full transition-all">Отмена</button>
                    <button id="save-creation-btn" class="text-white font-bold py-2 px-4 rounded-full transition-all" style="background-color: var(--button-color);">Сохранить</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно создания Покатушки (Мероприятия) -->
    <div id="event-creation-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideEventCreationModal()">
        <div class="bottom-sheet-content">
            <div class="grabber" onclick="hideEventCreationModal()"></div>
            <div class="p-4 flex-shrink-0">
                 <h2 class="text-2xl font-bold">Новое мероприятие</h2>
            </div>
            <div id="event-creation-modal-body" class="flex-grow overflow-y-auto p-4 space-y-4">
                <div>
                    <label for="event-title" class="block text-sm font-medium mb-1">Название</label>
                    <input type="text" id="event-title" class="form-input" placeholder="Вечерний прохват">
                </div>
                <div>
                    <label for="event-description" class="block text-sm font-medium mb-1">Описание</label>
                    <textarea id="event-description" rows="3" class="form-textarea" placeholder="Собираемся, общаемся, катаемся!"></textarea>
                </div>
                <div>
                    <label for="event-datetime" class="block text-sm font-medium mb-1">Дата и время</label>
                    <div class="datetime-input-wrapper">
                        <input type="datetime-local" id="event-datetime" class="form-input">
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Точка сбора</label>
                    <div id="event-map-picker" class="h-48 w-full rounded-lg bg-gray-200 mt-1"></div>
                    <p id="event-map-hint" class="text-xs text-gray-500 mt-1">Кликните на карту, чтобы выбрать точку сбора.</p>
                </div>
                <div>
                    <label for="event-route-select" class="block text-sm font-medium mb-1">Маршрут (необязательно)</label>
                    <select id="event-route-select" class="form-select"></select>
                </div>
            </div>
            <div class="p-4 flex-shrink-0 border-t" style="border-color: var(--border-color);">
                 <button onclick="handleEventSave()" class="w-full text-white font-bold py-3 px-6 rounded-full transition-all" style="background-color: var(--button-color);">Создать мероприятие</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно деталей (универсальное) -->
    <div id="detail-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideDetailModal()">
        <div class="bottom-sheet-content">
            <div class="grabber" onclick="hideDetailModal()"></div>
            <div id="detail-modal-body" class="flex-grow overflow-y-auto"></div>
        </div>
    </div>

    <!-- Модальное окно с комментариями (ДЛЯ ПОСТОВ) -->
    <div id="comments-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideCommentsModal()">
        <div class="bottom-sheet-content" style="height: 75%;">
             <div class="grabber" onclick="hideCommentsModal()"></div>
             <h2 id="comments-modal-title" class="text-xl font-bold px-4 pb-2 flex-shrink-0">Комментарии</h2>
            <div id="comments-modal-body" class="flex-grow overflow-y-auto p-4"></div>
            <div id="comment-input-container" class="flex-shrink-0 p-2 border-t" style="background-color: var(--secondary-bg-color); border-color: var(--border-color);">
                <div id="reply-indicator" class="hidden text-xs px-2 pb-1 flex justify-between items-center" style="color: var(--hint-color);">
                    <span id="reply-indicator-text"></span>
                    <button onclick="cancelReply()" class="font-bold text-xl">&times;</button>
                </div>
                <div class="flex items-center space-x-2">
                    <textarea id="main-comment-input" class="form-textarea w-full" rows="1" placeholder="Написать комментарий..."></textarea>
                    <button id="main-comment-send-btn" onclick="postComment()" class="flex-shrink-0 text-white rounded-full p-2 hover:opacity-80 disabled:opacity-50" style="background-color: var(--button-color);">
                        <i class="fa-solid fa-paper-plane h-6 w-6"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно списка участников -->
    <div id="participants-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideParticipantsModal()">
        <div class="bottom-sheet-content" style="height: 75%;">
            <div class="grabber" onclick="hideParticipantsModal()"></div>
            <h2 id="participants-modal-title" class="text-xl font-bold px-4 pb-2 flex-shrink-0">Участники</h2>
            <div id="participants-modal-body" class="flex-grow overflow-y-auto p-4 space-y-3"></div>
        </div>
    </div>

    <input id="gallery-input" type="file" class="sr-only" accept="image/*">
    <input id="camera-input" type="file" class="sr-only" accept="image/*" capture="user">


    <script type="module">
        // --- КОНФИГУРАЦИЯ И КОНСТАНТЫ ---
        const SUPABASE_URL = 'https://jsnahjtoqwuwbjdmisuj.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpzbmFoanRvcXd1d2JqZG1pc3VqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMzOTQxMDQsImV4cCI6MjA2ODk3MDEwNH0.M3TWsNJppj1f-Cmj6nGCAUswyJZfTwkrpI';
        const MAPBOX_ACCESS_TOKEN = 'pk.eyJ1IjoieXVuZ3JlemFjIiwiYSI6ImNtOW10ZzJ6bDBjNHUyanI3ejc5eXo1d2MifQ._tryk9cXjfReUGLGnNkm6Q'; 
        const BOT_USERNAME = 'TerraRunBot';

        // --- ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ И СОСТОЯНИЕ ---
        const tg = window.Telegram.WebApp;
        let map;
        let eventPickerMap; // Карта для выбора точки сбора
        let supabase;
        let telegramUser = null;
        let locationWatchId = null;
        let scrollToPostId = null; 
        let countdownTimers = []; // Массив для хранения интервалов таймеров

        const AppState = {
            currentMapMode: 'spots', // 'spots', 'routes'
            currentFeedTab: 'posts', // 'posts', 'events', 'spots', 'routes'
            isRunning: false,
            lastKnownLocation: null, // [lng, lat]
            userProfile: {
                id: null, name: '', color: '#3b82f6', photo_url: null
            },
            currentRunPath: [], // [[lng, lat], [lng, lat], ...]
            currentUserMarker: null,
            allSpots: [],
            allRoutes: [],
            allEvents: [],
            allProfilesData: [],
            currentEditContext: {},
            currentDetailContext: {},
            currentReplyTarget: { type: null, id: null, parentCommentId: null },
            photoContext: null,
            simplePostContext: {},
            eventCreationContext: {},
            isMapLoaded: false,
        };
        
        // --- ЭЛЕМЕНТЫ DOM ---
        const DOM = {
            initialLoader: document.getElementById('initial-loader'),
            loaderText: document.getElementById('loader-text'),
            fallbackScreen: document.getElementById('fallback-screen'),
            fallbackContent: document.getElementById('fallback-content'),
            appContainer: document.getElementById('app-container'),
            bottomNavbar: document.getElementById('bottom-navbar'),
            modeSwitcher: document.getElementById('mode-switcher'),
            feedCreateBtn: document.getElementById('feed-create-btn'),
            detailModal: document.getElementById('detail-modal'),
            commentsModal: document.getElementById('comments-modal'),
            simplePostModal: document.getElementById('simple-post-modal'),
            creationModal: document.getElementById('creation-modal'),
            eventCreationModal: document.getElementById('event-creation-modal'),
            participantsModal: document.getElementById('participants-modal'),
            leaderboardDiv: document.getElementById('leaderboard'),
            profileName: document.getElementById('profile-name'),
            profileAvatarImg: document.getElementById('profile-avatar-img'),
            profileAvatarWrapper: document.getElementById('profile-avatar-wrapper'),
            requestGeoBtn: document.getElementById('request-geo-btn'),
            mapCenterControls: document.getElementById('map-center-controls'),
            shareProfileBtn: document.getElementById('share-profile-btn'),
            mapActionContainer: document.getElementById('map-action-container'),
            mapActionBtn: document.getElementById('map-action-btn'),
        };

        // --- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ---
        
        function shadeColor(color, percent) {
            if (!color || !color.startsWith('#')) return '#e5e7eb'; 
            let R = parseInt(color.substring(1, 3), 16);
            let G = parseInt(color.substring(3, 5), 16);
            let B = parseInt(color.substring(5, 7), 16);
            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);
            R = (R < 255) ? R : 255;
            G = (G < 255) ? G : 255;
            B = (B < 255) ? B : 255;
            R = (R > 0) ? R : 0;
            G = (G > 0) ? G : 0;
            B = (B > 0) ? B : 0;
            const RR = ((R.toString(16).length === 1) ? "0" + R.toString(16) : R.toString(16));
            const GG = ((G.toString(16).length === 1) ? "0" + G.toString(16) : G.toString(16));
            const BB = ((B.toString(16).length === 1) ? "0" + B.toString(16) : B.toString(16));
            return "#" + RR + GG + BB;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : null;
        }

        function shareContent(type, id, ownerId) {
            tg.HapticFeedback.impactOccurred('light');
            const isOwner = telegramUser && ownerId.toString() === telegramUser.id.toString();
            let text = '';
            switch (type) {
                case 'post': text = isOwner ? 'Оцени мой пост в TerraRun!' : 'Смотри какой интересный пост в TerraRun!'; break;
                case 'route': text = isOwner ? 'Зацени мой маршрут в TerraRun!' : 'Смотри какой интересный маршрут в TerraRun!'; break;
                case 'spot': text = isOwner ? 'Смотри какой интересный спот в TerraRun!' : 'Смотри какой интересный спот в TerraRun!'; break;
                case 'event': text = isOwner ? 'Присоединяйся к моей покатушке в TerraRun!' : 'Смотри, какая покатушка намечается в TerraRun!'; break;
                case 'user': text = isOwner ? 'Это мой профиль в TerraRun, присоединяйся!' : 'Смотри профиль этого бегуна в TerraRun!'; break;
            }
            const url = `https://t.me/${BOT_USERNAME}?startapp=${type}_${id}`;
            tg.openTelegramLink(`https://t.me/share/url?url=${encodeURIComponent(url)}&text=${encodeURIComponent(text)}`);
        }

        function escapeHTML(str) {
            if (!str) return '';
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
        }

        // --- ФУНКЦИИ UI ---
        function showView(viewId, options = {}) {
            tg.HapticFeedback.selectionChanged();
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(viewId).classList.add('active');
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`button[onclick="showView('${viewId}')"]`).classList.add('active');
            
            const isMapView = viewId === 'map-view';
            
            DOM.mapActionContainer.classList.toggle('visible', isMapView && AppState.lastKnownLocation);
            DOM.modeSwitcher.classList.toggle('hidden', !isMapView || !AppState.lastKnownLocation);
            
            if (isMapView && map) { 
                setTimeout(() => map.resize(), 100);
            }
        }
        
        function switchFeedTab(tabName) {
            if (AppState.currentFeedTab === tabName) return;
            tg.HapticFeedback.selectionChanged();
            AppState.currentFeedTab = tabName;

            document.querySelectorAll('.feed-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.feed-tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`feed-tab-${tabName}`).classList.add('active');
            document.getElementById(`feed-content-${tabName}`).classList.add('active');

            const createIcon = DOM.feedCreateBtn.querySelector('i');
            if (tabName === 'posts') {
                DOM.feedCreateBtn.classList.remove('hidden');
                DOM.feedCreateBtn.onclick = showSimplePostModal;
                createIcon.className = 'fa-solid fa-plus h-7 w-7';
            } else if (tabName === 'events') {
                DOM.feedCreateBtn.classList.remove('hidden');
                DOM.feedCreateBtn.onclick = showEventCreationModal;
                createIcon.className = 'fa-solid fa-calendar-plus h-7 w-7';
            } else { // Для 'spots' и 'routes'
                DOM.feedCreateBtn.classList.add('hidden');
            }
            
            renderCurrentFeedTab();
        }
        
        function renderCurrentFeedTab() {
            clearCountdownTimers();
            const tab = AppState.currentFeedTab;
            const container = document.getElementById(`feed-content-${tab}`);
            if (container.children.length > 0 && !container.querySelector('.skeleton-container')) {
                // Контент уже загружен, не перезагружаем
                return;
            }

            switch(tab) {
                case 'posts': renderFeedPosts(); break;
                case 'events': renderFeedEvents(); break;
                case 'spots': renderFeedSpots(); break;
                case 'routes': renderFeedRoutes(); break;
            }
        }

        async function setMapMode(newMode) {
            if (AppState.currentMapMode === newMode || !map) return;
            
            if (AppState.isRunning) {
                tg.showAlert("Сначала завершите запись маршрута.");
                return;
            }
            tg.HapticFeedback.selectionChanged();
            AppState.currentMapMode = newMode;
            
            tg.CloudStorage.setItem('currentMapMode', newMode);

            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.id === `mode-${newMode}`);
            });

            // Toggle layer visibility
            if (map.getLayer('spots-layer')) {
                map.setLayoutProperty('spots-layer', 'visibility', newMode === 'spots' ? 'visible' : 'none');
                map.setLayoutProperty('spots-labels', 'visibility', newMode === 'spots' ? 'visible' : 'none');
            }
            if (map.getLayer('routes-layer')) {
                map.setLayoutProperty('routes-layer', 'visibility', newMode === 'routes' ? 'visible' : 'none');
            }

            updateMapActionButton();
        }

        function updateMapActionButton() {
            const icon = document.getElementById('map-action-icon');
            const text = document.getElementById('map-action-text');

            if (!AppState.lastKnownLocation) {
                DOM.mapActionContainer.classList.remove('visible');
                return;
            }
            
            DOM.mapActionContainer.classList.add('visible');

            switch (AppState.currentMapMode) {
                case 'spots':
                    text.textContent = "Добавить спот здесь";
                    DOM.mapActionBtn.style.backgroundColor = 'var(--success-color)';
                    icon.className = 'fa-solid fa-location-dot h-5 w-5';
                    break;
                case 'routes':
                    if (AppState.isRunning) {
                        text.textContent = "Завершить маршрут";
                        DOM.mapActionBtn.style.backgroundColor = 'var(--destructive-color)';
                        icon.className = 'fa-solid fa-stop h-5 w-5';
                    } else {
                        text.textContent = "Начать запись маршрута";
                        DOM.mapActionBtn.style.backgroundColor = 'var(--button-color)';
                        icon.className = 'fa-solid fa-route h-5 w-5';
                    }
                    break;
            }
        }
        
        async function mapActionButtonHandler() {
            DOM.mapActionBtn.disabled = true; 
            try {
                switch (AppState.currentMapMode) {
                    case 'spots':
                        if(AppState.lastKnownLocation) {
                            handleMapClickForSpot(AppState.lastKnownLocation);
                        } else {
                            tg.showAlert("Определяем ваше местоположение...");
                        }
                        break;
                    case 'routes':
                        AppState.isRunning ? await stopRouteRecording() : startRouteRecording();
                        break;
                }
            } finally {
                DOM.mapActionBtn.disabled = false;
            }
        }
        
        function generateColorFromId(id) {
            const strId = String(id);
            let hash = 0;
            for (let i = 0; i < strId.length; i++) {
                hash = strId.charCodeAt(i) + ((hash << 5) - hash);
            }
            const h = hash % 360;
            return `hsl(${h}, 80%, 65%)`;
        }

        // --- ЛОГИКА МОДАЛЬНЫХ ОКОН ---
        
        function showSimplePostModal() {
            document.getElementById('simple-post-details').value = '';
            document.getElementById('simple-post-filename').textContent = '';
            AppState.simplePostContext = {};
            showModal(DOM.simplePostModal);
        }

        function hideSimplePostModal() {
            hideModal(DOM.simplePostModal);
        }
        
        function showCreationModal(type, context = {}) {
            AppState.currentEditContext = { type, ...context };
            const title = document.getElementById('creation-modal-title');
            const description = document.getElementById('creation-modal-description');
            const nameInput = document.getElementById('creation-modal-name');
            const detailsInput = document.getElementById('creation-modal-details');
            const detailsSection = document.getElementById('creation-modal-details-section');
            const photoSection = document.getElementById('creation-modal-photo-section');
            
            nameInput.value = '';
            detailsInput.value = '';
            const preview = document.getElementById('creation-modal-photo-preview');
            preview.classList.add('hidden');
            preview.src = '';

            detailsSection.style.display = 'none';
            photoSection.style.display = 'none';

            if (type === 'spot') {
                title.textContent = 'Создать новый спот';
                description.textContent = 'Отметьте интересное место на карте для других.';
                detailsSection.style.display = 'block';
                photoSection.style.display = 'block';
            } else if (type === 'route') {
                title.textContent = 'Сохранить новый маршрут';
                description.textContent = 'Дайте название и описание вашему маршруту.';
                detailsSection.style.display = 'block';
            }
            
            showModal(DOM.creationModal);
        }

        function hideCreationModal() {
            hideModal(DOM.creationModal);
            AppState.currentEditContext = {};
        }

        function handleSave() {
            const { type } = AppState.currentEditContext;
            if (type === 'spot') saveSpot();
            else if (type === 'route') saveRoute();
        }
        
        function showDetailModal(type, id) {
             AppState.currentDetailContext = { type, id, mapInstances: [] };
             tg.HapticFeedback.impactOccurred('medium');
             
             showModal(DOM.detailModal);
             loadDetailContent();
        }
        
        function hideDetailModal() {
            if (AppState.currentDetailContext.mapInstances) {
                AppState.currentDetailContext.mapInstances.forEach(mapInstance => mapInstance.remove());
            }
            hideModal(DOM.detailModal);
            AppState.currentDetailContext = {};
        }

        // --- Улучшенные функции открытия/закрытия модальных окон
        function showModal(modalElement) {
            modalElement.classList.add('visible');
            document.body.classList.add('modal-open');
            tg.BackButton.show();
        }

        function hideModal(modalElement) {
            modalElement.classList.remove('visible');
            // Проверяем, есть ли еще открытые модальные окна, прежде чем убирать класс
            const anyModalVisible = document.querySelector('.modal-overlay.visible');
            if (!anyModalVisible) {
                document.body.classList.remove('modal-open');
                tg.BackButton.hide();
            }
        }

        // --- ФУНКЦИИ ДЛЯ ВЫБОРА ФОТО ---
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (AppState.photoContext === 'creation') {
                const preview = document.getElementById('creation-modal-photo-preview');
                preview.src = URL.createObjectURL(file);
                preview.classList.remove('hidden');
                AppState.currentEditContext.file = file;
            } else if (AppState.photoContext === 'simple') {
                document.getElementById('simple-post-filename').textContent = file.name;
                AppState.simplePostContext = { file: file };
            }
            event.target.value = '';
        }
        
        async function generateUserProfileDetailHTML(profile, posts, spots, routes, events, likesByPost, commentsByPost) {
            const profileName = escapeHTML(profile.name);
            const avatar = profile.photo_url || `https://placehold.co/96x96/E2E8F0/4A5568?text=${profileName.charAt(0)}`;

            const postsHTML = posts.length > 0
                ? posts.map(p => generatePostHTML(p, likesByPost[p.id] || [], commentsByPost[p.id] || [])).join('')
                : '<p class="text-center text-gray-500 py-4">У этого пользователя нет постов.</p>';

            const eventsHTML = events.length > 0
                ? (await Promise.all(events.map(e => generateEventCardHTML(e)))).join('')
                : '<p class="text-center text-gray-500 py-4">Этот пользователь не участвует в мероприятиях.</p>';

            const spotsHTML = spots.length > 0
                ? spots.map(s => generateMiniSpotHTML(s, false)).join('')
                : '<p class="text-center text-gray-500 py-4">У этого пользователя нет спотов.</p>';

            const routesHTML = routes.length > 0
                ? routes.map(r => generateMiniRouteHTML(r, false)).join('')
                : '<p class="text-center text-gray-500 py-4">У этого пользователя нет маршрутов.</p>';

            return `
                <div class="p-4">
                    <div class="card-bg rounded-2xl shadow-lg p-6 flex flex-col items-center space-y-4">
                        <div class="w-24 h-24 rounded-full border-4 flex-shrink-0" style="border-color: ${profile.color || '#ccc'};">
                            <img src="${avatar}" class="w-full h-full rounded-full object-cover" alt="avatar">
                        </div>
                        <div class="text-center">
                            <h2 class="text-2xl font-bold">${profileName}</h2>
                        </div>
                        <div class="w-full pt-4 mt-4 border-t" style="border-color: var(--border-color);">
                            <div class="flex justify-center gap-8 w-full">
                                <button onclick="shareContent('user', ${profile.id}, ${profile.id})" class="flex flex-col items-center space-y-1 transition-opacity hover:opacity-70">
                                    <div class="p-3 rounded-full" style="background-color: rgba(var(--button-color-rgb), 0.15);"><i class="fa-solid fa-arrow-up-from-bracket h-6 w-6" style="color: var(--button-color);"></i></div>
                                    <span class="text-xs font-medium" style="color: var(--hint-color);">Поделиться</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="flex border-b sticky top-0 z-10 overflow-x-auto" style="background-color: var(--bg-color);">
                    <div id="tab-posts" class="profile-tab active" onclick="switchProfileTab('posts')">Посты (${posts.length})</div>
                    <div id="tab-events" class="profile-tab" onclick="switchProfileTab('events')">Покатушки (${events.length})</div>
                    <div id="tab-spots" class="profile-tab" onclick="switchProfileTab('spots')">Споты (${spots.length})</div>
                    <div id="tab-routes" class="profile-tab" onclick="switchProfileTab('routes')">Маршруты (${routes.length})</div>
                </div>
                <div class="p-4">
                    <div id="content-posts" class="profile-tab-content active space-y-4">${postsHTML}</div>
                    <div id="content-events" class="profile-tab-content space-y-4">${eventsHTML}</div>
                    <div id="content-spots" class="profile-tab-content grid grid-cols-1 sm:grid-cols-2 gap-4">${spotsHTML}</div>
                    <div id="content-routes" class="profile-tab-content space-y-4">${routesHTML}</div>
                </div>
            `;
        }

        async function loadDetailContent() {
            const { type, id } = AppState.currentDetailContext;
            const body = document.getElementById('detail-modal-body');
            
            body.innerHTML = `<div class="text-center p-8"><svg class="animate-spin mx-auto h-8 w-8 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></div>`;
            
            try {
                if (type === 'spot') {
                    const { data: spot, error } = await supabase.from('spots').select('*, profiles(id, name, photo_url)').eq('id', id).single();
                    if (error) throw error;
                    body.innerHTML = generateSpotDetailHTML(spot);
                    loadAndRenderComments('spot', id, 'detail-comments-list');
                } else if (type === 'route') {
                     const { data: route, error } = await supabase.from('routes').select('*, profiles(id, name, photo_url)').eq('id', id).single();
                    if (error) throw error;
                    body.innerHTML = generateRouteDetailHTML(route);
                    setTimeout(() => renderMiniMapForRoute(route), 100);
                    loadAndRenderComments('route', id, 'detail-comments-list');
                } else if (type === 'event') {
                    const { data: event, error } = await supabase.from('events').select('*, profiles(id, name, photo_url), routes(*)').eq('id', id).single();
                     if (error) throw error;
                    body.innerHTML = await generateEventDetailHTML(event);
                    setTimeout(() => renderMiniMapForEvent(event), 100);
                    loadAndRenderComments('event', id, 'event-comments-list');
                } else if (type === 'user') {
                    const [profileRes, postsRes, spotsRes, routesRes, eventsRes] = await Promise.all([
                        supabase.from('profiles').select('*').eq('id', id).single(),
                        supabase.from('posts').select('*').eq('user_id', id).order('created_at', { ascending: false }),
                        supabase.from('spots').select('*').eq('user_id', id).order('created_at', { ascending: false }),
                        supabase.from('routes').select('*').eq('user_id', id).order('created_at', { ascending: false }),
                        supabase.rpc('get_user_events', { p_user_id: id })
                    ]);

                    if (profileRes.error) throw profileRes.error;

                    const profile = profileRes.data;
                    const posts = postsRes.data || [];
                    const spots = spotsRes.data || [];
                    const routes = routesRes.data || [];
                    const events = eventsRes.data || [];

                    const postIds = posts.map(p => p.id);
                    const likesByPost = {};
                    const commentsByPost = {};
                    if (postIds.length > 0) {
                        const { data: likes } = await supabase.from('likes').select('*').in('post_id', postIds);
                        const { data: comments } = await supabase.from('comments').select('id, post_id').in('post_id', postIds);
                        if(likes) likes.forEach(like => (likesByPost[like.post_id] = likesByPost[like.post_id] || []).push(like));
                        if(comments) comments.forEach(comment => (commentsByPost[comment.post_id] = commentsByPost[comment.post_id] || []).push(comment));
                    }

                    body.innerHTML = await generateUserProfileDetailHTML(profile, posts, spots, routes, events, likesByPost, commentsByPost);
                    
                    setTimeout(() => {
                        posts.forEach(post => {
                            if (post.territory_captured) {
                                renderMiniMapForPost(post, body);
                            }
                        });
                    }, 100);
                }
            } catch (error) {
                 console.error(`Ошибка загрузки деталей для ${type} #${id}:`, error);
                 body.innerHTML = `<p class="text-red-500 text-center p-4">Не удалось загрузить детали. Попробуйте еще раз.</p>`;
            }
        }
        
        function switchProfileTab(tabName, containerIdPrefix = 'content') {
            const context = document.getElementById('detail-modal-body');
            context.querySelectorAll('.profile-tab').forEach(t => t.classList.remove('active'));
            context.querySelectorAll('.profile-tab-content').forEach(c => c.classList.remove('active'));
            context.querySelector(`#tab-${tabName}`).classList.add('active');
            context.querySelector(`#${containerIdPrefix}-${tabName}`).classList.add('active');
        }

        function generateMiniSpotHTML(spot, isFeed = false) {
             const buttonHTML = isFeed 
                ? `<button onclick="event.stopPropagation(); navigateToMapObject('spot', '${spot.id}')" class="mt-2 w-full text-sm text-center font-semibold p-2 rounded-lg" style="background-color: var(--bg-color); color: var(--button-color);">Показать на карте</button>` 
                : '';
               return `<div class="card-bg rounded-xl p-4 shadow-sm cursor-pointer hover:shadow-md transition-shadow" onclick="showDetailModal('spot', '${spot.id}')">
                        ${spot.photo_url ? `<img src="${spot.photo_url}" class="w-full h-32 object-cover rounded-lg mb-3" alt="Фото спота">` : ''}
                        <p class="font-bold">${escapeHTML(spot.name)}</p>
                        <p class="text-sm text-gray-600 truncate mt-1">${escapeHTML(spot.description)}</p>
                        <p class="text-xs text-gray-400 mt-2">${new Date(spot.created_at).toLocaleDateString()}</p>
                        ${buttonHTML}
                      </div>`;
        }
        
        function generateMiniRouteHTML(route, isFeed = false) {
               const buttonHTML = isFeed 
                ? `<button onclick="event.stopPropagation(); navigateToMapObject('route', '${route.id}')" class="mt-2 w-full text-sm text-center font-semibold p-2 rounded-lg" style="background-color: var(--bg-color); color: var(--button-color);">Показать на карте</button>` 
                : '';
               return `<div class="card-bg rounded-xl p-4 shadow-sm cursor-pointer hover:shadow-md transition-shadow" onclick="showDetailModal('route', '${route.id}')">
                               <p class="font-bold flex items-center gap-2"><i class="fa-solid fa-route" style="color: var(--hint-color);"></i> ${escapeHTML(route.name)}</p>
                               <p class="text-sm text-gray-600 truncate mt-1">${escapeHTML(route.description)}</p>
                               <p class="text-xs text-gray-400 mt-2">${new Date(route.created_at).toLocaleDateString()}</p>
                               ${buttonHTML}
                             </div>`;
        }

        function navigateToMapObject(type, id) {
            hideDetailModal(); 

            showView('map-view', { preventFit: true });
            
            setTimeout(() => {
                if (!map) {
                    console.error("Карта не инициализирована.");
                    return;
                }
                
                map.resize();

                let targetObject;
                const numericId = parseInt(id, 10);

                if (type === 'spot') {
                    setMapMode('spots');
                    targetObject = AppState.allSpots.find(s => s.id === numericId);
                    if (!targetObject) return console.error(`Спот с ID ${id} не найден.`);
                    
                    const geoJson = parseWKT(targetObject.location);
                    if (geoJson && geoJson.type === 'Point') {
                        map.flyTo({
                            center: geoJson.coordinates,
                            zoom: 16,
                            pitch: 60,
                            duration: 1500,
                            essential: true
                        });
                    }
                } else if (type === 'route') {
                    setMapMode('routes');
                    targetObject = AppState.allRoutes.find(r => r.id === numericId);
                    if (!targetObject) return console.error(`Маршрут с ID ${id} не найден.`);
                    
                    const geoJson = parseWKT(targetObject.path);
                    if (geoJson && geoJson.type === 'LineString' && geoJson.coordinates.length > 0) {
                        const bounds = new mapboxgl.LngLatBounds(
                            geoJson.coordinates[0],
                            geoJson.coordinates[0]
                        );
                        for (const coord of geoJson.coordinates) {
                            bounds.extend(coord);
                        }
                        map.fitBounds(bounds, {
                            padding: 60,
                            duration: 1000,
                            essential: true
                        });
                    }
                }
            }, 250); 
        }

        /**
         * Улучшенная функция парсинга.
         * В первую очередь пытается обработать прямой GeoJSON объект, который возвращает PostGIS.
         * Оставляет старый WKT-парсер как запасной вариант.
         */
        function parseWKT(wkt) {
            if (!wkt) return null;
            // Приоритет для GeoJSON объекта
            if (typeof wkt === 'object' && wkt.type && wkt.coordinates) return wkt;
            
            // Запасной вариант для строкового формата
            if (typeof wkt !== 'string') return null;
            try {
                if (wkt.trim().startsWith('{')) {
                    const parsed = JSON.parse(wkt);
                    if (parsed.type && parsed.coordinates) return parsed;
                }
                // ... (остальной код парсинга WKT без изменений)
                const match = wkt.match(/(POINT|LINESTRING|POLYGON|MULTIPOLYGON)\s*\((.+)\)/i);
                if (!match) return null;
                const type = match[1].toUpperCase();
                let content = match[2];
                if (type === 'POINT') {
                    const coords = content.match(/-?\d+(\.\d+)?/g);
                    if (!coords || coords.length < 2) return null;
                    return { type: 'Point', coordinates: [parseFloat(coords[0]), parseFloat(coords[1])] };
                }
                if (type === 'LINESTRING') {
                    const coordinates = content.split(',').map(pair => {
                        const nums = pair.trim().match(/-?\d+(\.\d+)?/g);
                        return nums && nums.length >= 2 ? [parseFloat(nums[0]), parseFloat(nums[1])] : null;
                    }).filter(Boolean);
                    return coordinates.length >= 2 ? { type: 'LineString', coordinates } : null;
                }
                if (type === 'POLYGON' || type === 'MULTIPOLYGON') {
                    const rings = content.match(/\(([^()]+)\)/g);
                    if (!rings) return null;
                    const coordinates = rings.map(ringContent => 
                        ringContent.replace(/[()]/g, '').split(',').map(pair => {
                            const nums = pair.trim().match(/-?\d+(\.\d+)?/g);
                            return nums && nums.length >= 2 ? [parseFloat(nums[0]), parseFloat(nums[1])] : null;
                        }).filter(Boolean)
                    );
                    if (type === 'POLYGON') return { type: 'Polygon', coordinates };
                    if (type === 'MULTIPOLYGON') return { type: 'MultiPolygon', coordinates: [coordinates] };
                }
            } catch (e) {
                console.error("Failed to parse WKT or JSON:", wkt, e);
                return null;
            }
            return null;
        }

        // --- ОСНОВНАЯ ЛОГИКА И ИНИЦИАЛИЗАЦИЯ ---
        async function runApp() {
            try {
                tg.ready();
                tg.expand();
                tg.enableClosingConfirmation();
                applyTheme(tg.themeParams);
                setupStaticEventListeners();

                if (!tg.initDataUnsafe?.user) {
                    showFallbackScreen('Требуется Telegram', 'Это приложение предназначено для работы исключительно внутри Telegram.', false);
                    return;
                }
                telegramUser = tg.initDataUnsafe.user;
                
                if (MAPBOX_ACCESS_TOKEN === 'YOUR_MAPBOX_ACCESS_TOKEN') {
                    showFallbackScreen('Ошибка конфигурации', 'Отсутствует ключ доступа для Mapbox. Пожалуйста, укажите его в коде.', false);
                    return;
                }
                mapboxgl.accessToken = MAPBOX_ACCESS_TOKEN;

                DOM.loaderText.textContent = 'Подключение к базе данных...';
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                
                DOM.loaderText.textContent = 'Загрузка карты...';
                initMap({ longitude: 37.618423, latitude: 55.751244 });
                
                DOM.loaderText.textContent = 'Загрузка профиля...';
                await upsertUserProfile();
                updateUI();
                
                DOM.loaderText.textContent = 'Загрузка данных...';
                await Promise.all([
                    fetchAllProfilesAndDraw(),
                    renderCurrentFeedTab(),
                    loadInitialMapData(),
                    renderMyProfileContent()
                ]);

                listenToRealtimeChanges();
                setupDynamicEventListeners();
                initializeGeolocation();
                handleStartParam();

                DOM.initialLoader.classList.add('hidden');
                DOM.appContainer.classList.remove('hidden');
                DOM.bottomNavbar.classList.remove('hidden');
                
                tg.CloudStorage.getItem('currentMapMode', (error, value) => {
                    if (error) {
                        console.error("CloudStorage error:", error);
                        setMapMode('spots');
                        return;
                    }
                    setMapMode(value || 'spots');
                });

            } catch (error) {
                console.error("Критическая ошибка инициализации:", error);
                let message = error.message || "Не удалось запустить приложение. Пожалуйста, попробуйте перезагрузить его.";
                showFallbackScreen("Ошибка инициализации", message, true);
            }
        }

        function initMap(coords) {
            if (map) return;
            map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/standard', // Стиль с поддержкой 3D
                center: [coords.longitude, coords.latitude],
                zoom: 5,
                pitch: 45, // Угол наклона для 3D
                bearing: -17.6,
                antialias: true
            });

            map.on('load', () => {
                AppState.isMapLoaded = true;
                // Добавляем слой с 3D зданиями
                map.addLayer({
                    'id': '3d-buildings',
                    'source': 'composite',
                    'source-layer': 'building',
                    'filter': ['==', 'extrude', 'true'],
                    'type': 'fill-extrusion',
                    'minzoom': 15,
                    'paint': {
                        'fill-extrusion-color': '#aaa',
                        'fill-extrusion-height': [
                            "interpolate", ["linear"], ["zoom"],
                            15, 0,
                            15.05, ["get", "height"]
                        ],
                        'fill-extrusion-base': [
                            "interpolate", ["linear"], ["zoom"],
                            15, 0,
                            15.05, ["get", "min_height"]
                        ],
                        'fill-extrusion-opacity': .6
                    }
                });
                
                // Инициализируем источники данных для объектов
                map.addSource('spots', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
                map.addSource('routes', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
                map.addSource('events', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
                map.addSource('current-run', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });

                // Добавляем слои для отображения
                map.addLayer({
                    id: 'routes-layer',
                    type: 'line',
                    source: 'routes',
                    layout: { 'line-join': 'round', 'line-cap': 'round', 'visibility': 'none' },
                    paint: { 'line-color': '#ff7800', 'line-width': 4, 'line-opacity': 0.8 }
                });
                map.addLayer({
                    id: 'spots-layer',
                    type: 'circle',
                    source: 'spots',
                    layout: { 'visibility': 'visible' },
                    paint: {
                        'circle-color': '#9333ea',
                        'circle-radius': 8,
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#ffffff'
                    }
                });
                 map.addLayer({
                    id: 'spots-labels',
                    type: 'symbol',
                    source: 'spots',
                    layout: {
                        'text-field': ['get', 'name'],
                        'text-variable-anchor': ['top', 'bottom', 'left', 'right'],
                        'text-radial-offset': 0.8,
                        'text-justify': 'auto',
                        'text-size': 12,
                        'visibility': 'visible'
                    },
                    paint: {
                        "text-color": "#222",
                        "text-halo-color": "#fff",
                        "text-halo-width": 1,
                        "text-halo-blur": 1
                    }
                });
                map.addLayer({
                    id: 'events-layer',
                    type: 'circle',
                    source: 'events',
                    paint: {
                        'circle-color': '#16a34a',
                        'circle-radius': 10,
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#ffffff'
                    }
                });
                map.addLayer({
                    id: 'current-run-layer',
                    type: 'line',
                    source: 'current-run',
                    layout: { 'line-join': 'round', 'line-cap': 'round' },
                    paint: { 'line-color': 'var(--button-color)', 'line-width': 5, 'line-opacity': 0.9 }
                });

                // Загружаем данные после создания слоев
                loadInitialMapData();
            });

            // Добавляем контролы навигации
            const geolocate = new mapboxgl.GeolocateControl({
                positionOptions: { enableHighAccuracy: true },
                trackUserLocation: true,
                showUserHeading: true
            });
            map.addControl(geolocate, 'top-right');
            map.addControl(new mapboxgl.NavigationControl(), 'top-right');
            
            // Обработчики кликов по слоям
            map.on('click', 'spots-layer', (e) => {
                const spotId = e.features[0].properties.id;
                showDetailModal('spot', spotId);
            });
             map.on('click', 'routes-layer', (e) => {
                // This is tricky for lines. We can show info but it might not be the intended route.
                // A better approach would be to query rendered features.
                // For now, let's just log it.
                console.log("Clicked a route", e.features[0].properties);
                const routeId = e.features[0].properties.id;
                showDetailModal('route', routeId);
            });
            map.on('click', 'events-layer', (e) => {
                const eventId = e.features[0].properties.id;
                showDetailModal('event', eventId);
            });

            // Change cursor on hover
            map.on('mouseenter', ['spots-layer', 'routes-layer', 'events-layer'], () => {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', ['spots-layer', 'routes-layer', 'events-layer'], () => {
                map.getCanvas().style.cursor = '';
            });
        }

        function updateUI() {
            const name = escapeHTML(telegramUser.first_name);
            DOM.profileName.textContent = name;
            
            if (telegramUser.photo_url) {
                DOM.profileAvatarImg.src = telegramUser.photo_url;
            } else {
                const initial = name.charAt(0).toUpperCase();
                DOM.profileAvatarImg.src = `https://placehold.co/96x96/E2E8F0/4A5568?text=${initial}`;
            }
            DOM.profileAvatarWrapper.style.borderColor = AppState.userProfile.color;
            updateMapActionButton();
            renderMyProfileContent();
        }
        
        function updateCurrentUserMarker(coords) { // coords is [lng, lat]
            if (!map) return;
            
            if (AppState.currentUserMarker) {
                AppState.currentUserMarker.setLngLat(coords);
            } else {
                const el = document.createElement('div');
                el.className = 'avatar-marker current-user-marker';
                el.style.backgroundImage = `url(${telegramUser.photo_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${telegramUser.first_name.charAt(0)}`})`;
                el.style.width = '40px';
                el.style.height = '40px';
                el.style.borderColor = AppState.userProfile.color;

                AppState.currentUserMarker = new mapboxgl.Marker(el)
                    .setLngLat(coords)
                    .addTo(map);
            }
        }
        
        // --- Логика геолокации ---
        async function initializeGeolocation() {
            if (!navigator.geolocation) {
                tg.showAlert("Геолокация не поддерживается вашим устройством.");
                return;
            }
            try {
                const permissionStatus = await navigator.permissions.query({ name: 'geolocation' });
                const handlePermissionChange = () => {
                    if (permissionStatus.state === 'granted') {
                        startGeoTracking();
                    } else {
                        AppState.lastKnownLocation = null;
                        DOM.mapActionContainer.classList.remove('visible');
                        DOM.modeSwitcher.classList.add('hidden');
                        DOM.mapCenterControls.classList.remove('hidden');
                    }
                };
                permissionStatus.onchange = handlePermissionChange;
                handlePermissionChange();
            } catch (e) {
                console.warn("API разрешений не поддерживается, используем старый метод.", e);
                DOM.mapCenterControls.classList.remove('hidden');
            }
        }

        function handleGeoRequest() {
            const geoLoader = document.getElementById('request-geo-loader');
            const geoText = document.getElementById('request-geo-text');
            geoText.textContent = 'Ждем ответа...';
            geoLoader.classList.remove('hidden');
            DOM.requestGeoBtn.disabled = true;
            startGeoTracking();
        }

        function startGeoTracking() {
             navigator.geolocation.getCurrentPosition(
                (position) => {
                    tg.HapticFeedback.notificationOccurred('success');
                    const coords = [position.coords.longitude, position.coords.latitude];
                    if (!AppState.lastKnownLocation && map) {
                        map.flyTo({ center: coords, zoom: 15, pitch: 45 });
                    }
                    AppState.lastKnownLocation = coords;
                    
                    updateCurrentUserMarker(coords);
                    DOM.mapCenterControls.classList.add('hidden');
                    DOM.modeSwitcher.classList.remove('hidden');
                    DOM.mapActionContainer.classList.add('visible');
                    
                    updateMapActionButton();
                    startWatchingLocation();
                },
                (error) => {
                    tg.HapticFeedback.notificationOccurred('error');
                    console.error("Geolocation error:", error);
                    tg.showAlert("Не удалось получить геолокацию. Проверьте разрешения в настройках вашего устройства.");
                    const geoText = document.getElementById('request-geo-text');
                    const geoLoader = document.getElementById('request-geo-loader');
                    geoText.textContent = 'Дать доступ к гео';
                    geoLoader.classList.add('hidden');
                    DOM.requestGeoBtn.disabled = false;
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        }
        
        function startWatchingLocation() {
            if (locationWatchId) {
                navigator.geolocation.clearWatch(locationWatchId);
            }
            locationWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    const coords = [position.coords.longitude, position.coords.latitude];
                    AppState.lastKnownLocation = coords;
                    updateCurrentUserMarker(coords);

                    if (AppState.isRunning) {
                        AppState.currentRunPath.push(coords);
                        const runSource = map.getSource('current-run');
                        if (runSource) {
                            runSource.setData({
                                type: 'FeatureCollection',
                                features: [{
                                    type: 'Feature',
                                    geometry: {
                                        type: 'LineString',
                                        coordinates: AppState.currentRunPath
                                    }
                                }]
                            });
                        }
                    }
                },
                (error) => {
                    console.warn("Ошибка отслеживания геолокации:", error.message);
                },
                { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
            );
        }

        // --- ЛОГИКА РЕЖИМОВ ---
        
        function handleMapClickForSpot(coords) { // coords is [lng, lat]
            const locationWKT = `POINT(${coords[0]} ${coords[1]})`;
            tg.showConfirm("Создать новый спот в этом месте?", (ok) => {
                if(ok) showCreationModal('spot', { location: locationWKT });
            });
        }

        async function saveSpot() {
            const { location } = AppState.currentEditContext;
            const name = document.getElementById('creation-modal-name').value.trim();
            const description = document.getElementById('creation-modal-details').value.trim();
            const file = AppState.currentEditContext.file;

            if (!name || !description) {
                tg.showAlert("Название и описание обязательны.");
                return;
            }

            let photoUrl = null;
            if (file) {
                try {
                    const filePath = `${telegramUser.id}/spots/${Date.now()}_${file.name}`;
                    const { data, error } = await supabase.storage.from('photo').upload(filePath, file);
                    if (error) throw error;
                    const { data: urlData } = supabase.storage.from('photo').getPublicUrl(data.path);
                    photoUrl = urlData.publicUrl;
                } catch (error) {
                    console.error("Ошибка загрузки фото:", error);
                    tg.showAlert("Ошибка загрузки фото.");
                    return;
                }
            }

            const { error } = await supabase.rpc('create_spot', {
                p_user_id: telegramUser.id,
                p_name: name,
                p_description: description,
                p_photo_url: photoUrl,
                p_location_wkt: location
            });

            if (error) {
                console.error("Ошибка сохранения спота через RPC:", error);
                tg.showAlert("Не удалось сохранить спот. Убедитесь, что SQL-функция 'create_spot' создана в базе данных.");
            } else {
                tg.showAlert("Спот успешно создан!");
                hideCreationModal();
                loadInitialMapData();
                renderMyProfileContent();
                if (AppState.currentFeedTab === 'spots') renderFeedSpots();
            }
        }
        
        function startRouteRecording() {
            if (!AppState.lastKnownLocation) {
                tg.showAlert("Сначала определите свое местоположение."); return;
            }
            AppState.isRunning = true;
            tg.HapticFeedback.impactOccurred('heavy');
            tg.isClosingConfirmationEnabled = true;
            updateMapActionButton();
            
            AppState.currentRunPath = [ AppState.lastKnownLocation ];
            const runSource = map.getSource('current-run');
            if (runSource) {
                runSource.setData({ type: 'FeatureCollection', features: [] });
            }
        }

        async function stopRouteRecording() {
            return new Promise(resolve => {
                AppState.isRunning = false;
                tg.HapticFeedback.notificationOccurred('success');
                tg.isClosingConfirmationEnabled = false;
                updateMapActionButton();
                
                if (AppState.currentRunPath.length < 2) {
                    tg.showAlert("Слишком короткий маршрут.");
                    AppState.currentRunPath = [];
                    resolve();
                    return;
                }
                
                const pathCoordinates = AppState.currentRunPath.map(p => `${p[0]} ${p[1]}`).join(', ');
                const pathWKT = `LINESTRING(${pathCoordinates})`;
                showCreationModal('route', { path: pathWKT });

                // Clear the temporary run path from the map
                const runSource = map.getSource('current-run');
                if (runSource) {
                    runSource.setData({ type: 'FeatureCollection', features: [] });
                }
                AppState.currentRunPath = [];
                resolve();
            });
        }

        async function saveRoute() {
            const { path } = AppState.currentEditContext;
            const name = document.getElementById('creation-modal-name').value.trim();
            const description = document.getElementById('creation-modal-details').value.trim();
            
            if (!name) {
                tg.showAlert("Название обязательно.");
                return;
            }

            const { error } = await supabase.rpc('create_route', {
                p_user_id: telegramUser.id,
                p_name: name,
                p_description: description,
                p_path_wkt: path
            });

            if (error) {
                console.error("Ошибка сохранения маршрута через RPC:", error);
                tg.showAlert("Не удалось сохранить маршрут. Убедитесь, что SQL-функция 'create_route' создана в базе данных.");
            } else {
                tg.showAlert("Маршрут сохранен!");
                hideCreationModal();
                loadInitialMapData();
                renderMyProfileContent();
                if (AppState.currentFeedTab === 'routes') renderFeedRoutes();
            }
        }
        
        // --- ЗАГРУЗКА ДАННЫХ ---
        async function loadInitialMapData() {
            if (!AppState.isMapLoaded) {
                // Карта еще не загрузилась, попробуем позже
                setTimeout(loadInitialMapData, 200);
                return;
            }
            try {
                const [spotsRes, routesRes, eventsRes] = await Promise.all([
                    supabase.from('spots').select('*'),
                    supabase.from('routes').select('*'),
                    supabase.from('events').select('*')
                ]);

                // Spots
                if (spotsRes.error) throw spotsRes.error;
                AppState.allSpots = spotsRes.data;
                const spotFeatures = AppState.allSpots.map(spot => {
                    const geoJson = parseWKT(spot.location);
                    if (!geoJson) return null;
                    return { type: 'Feature', geometry: geoJson, properties: { id: spot.id, name: spot.name } };
                }).filter(Boolean);
                map.getSource('spots')?.setData({ type: 'FeatureCollection', features: spotFeatures });

                // Routes
                if (routesRes.error) throw routesRes.error;
                AppState.allRoutes = routesRes.data;
                const routeFeatures = AppState.allRoutes.map(route => {
                    const geoJson = parseWKT(route.path);
                    if (!geoJson) return null;
                    return { type: 'Feature', geometry: geoJson, properties: { id: route.id, name: route.name } };
                }).filter(Boolean);
                map.getSource('routes')?.setData({ type: 'FeatureCollection', features: routeFeatures });
                
                // Events
                if (eventsRes.error) throw eventsRes.error;
                AppState.allEvents = eventsRes.data;
                const eventFeatures = AppState.allEvents.map(event => {
                    const geoJson = parseWKT(event.meeting_point);
                    if (!geoJson) return null;
                    return { type: 'Feature', geometry: geoJson, properties: { id: event.id, name: event.title } };
                }).filter(Boolean);
                map.getSource('events')?.setData({ type: 'FeatureCollection', features: eventFeatures });

            } catch (error) {
                console.error("Ошибка загрузки данных карты:", error);
                tg.showAlert("Не удалось загрузить все объекты на карте.");
            }
        }

        // --- SUPABASE и ОБРАБОТЧИКИ ---
        function listenToRealtimeChanges() {
            supabase.channel('public-changes')
              .on('postgres_changes', { event: '*', schema: 'public', table: 'profiles' }, fetchAllProfilesAndDraw)
              .on('postgres_changes', { event: '*', schema: 'public', table: 'posts' }, () => { renderFeedPosts(); renderMyProfileContent(); })
              .on('postgres_changes', { event: '*', schema: 'public', table: 'likes' }, payload => handleLikeChange(payload))
              .on('postgres_changes', { event: '*', schema: 'public', table: 'comments' }, (payload) => {
                  // Обновляем комментарии, если модальное окно открыто
                  const relevantId = payload.new?.post_id || payload.old?.post_id;
                  if (commentsModal.classList.contains('visible') && AppState.currentReplyTarget.id == relevantId) {
                      showPostComments(relevantId);
                  }
              })
              .on('postgres_changes', { event: '*', schema: 'public', table: 'spots' }, () => { loadInitialMapData(); renderMyProfileContent(); renderFeedSpots(); })
              .on('postgres_changes', { event: '*', schema: 'public', table: 'routes' }, () => { loadInitialMapData(); renderMyProfileContent(); renderFeedRoutes(); })
              .on('postgres_changes', { event: '*', schema: 'public', table: 'events' }, () => { loadInitialMapData(); renderMyProfileContent(); renderFeedEvents(); })
              .on('postgres_changes', { event: '*', schema: 'public', table: 'event_participants' }, (payload) => {
                  const eventId = payload.new?.event_id || payload.old?.event_id;
                  if (eventId) {
                      updateEventCard(eventId);
                      if (participantsModal.classList.contains('visible') && AppState.currentDetailContext.id === eventId) {
                          showParticipants(eventId);
                      }
                  }
              })
              .subscribe();
        }
        
        function handleLikeChange(payload) {
            // Эта функция может быть расширена для обновления только конкретного поста, а не всей ленты.
            renderFeedPosts();
            renderMyProfileContent();
        }

        function setupStaticEventListeners() {
            tg.onEvent('themeChanged', () => applyTheme(tg.themeParams));
            tg.onEvent('backButtonClicked', () => {
                if (participantsModal.classList.contains('visible')) hideParticipantsModal();
                else if (eventCreationModal.classList.contains('visible')) hideEventCreationModal();
                else if (commentsModal.classList.contains('visible')) hideCommentsModal();
                else if (detailModal.classList.contains('visible')) hideDetailModal();
                else if (creationModal.classList.contains('visible')) hideCreationModal();
                else if (simplePostModal.classList.contains('visible')) hideSimplePostModal();
            });
            tg.SettingsButton.onClick(() => {
                tg.HapticFeedback.impactOccurred('light');
                tg.openTelegramLink(`https://t.me/${BOT_USERNAME}`);
            });
        }

        function setupDynamicEventListeners() {
            document.getElementById('mode-spots').addEventListener('click', () => setMapMode('spots'));
            document.getElementById('mode-routes').addEventListener('click', () => setMapMode('routes'));
            
            document.getElementById('save-creation-btn').addEventListener('click', handleSave);
            
            // --- ОБРАБОТЧИКИ ДЛЯ ВЫБОРА ФОТО ---
            document.getElementById('simple-post-gallery-btn').addEventListener('click', () => {
                AppState.photoContext = 'simple';
                document.getElementById('gallery-input').click();
            });
            document.getElementById('simple-post-camera-btn').addEventListener('click', () => {
                AppState.photoContext = 'simple';
                document.getElementById('camera-input').click();
            });
            document.getElementById('creation-gallery-btn').addEventListener('click', () => {
                AppState.photoContext = 'creation';
                document.getElementById('gallery-input').click();
            });
            document.getElementById('creation-camera-btn').addEventListener('click', () => {
                AppState.photoContext = 'creation';
                document.getElementById('camera-input').click();
            });
            document.getElementById('camera-input').addEventListener('change', handleFileSelect);
            document.getElementById('gallery-input').addEventListener('change', handleFileSelect);

            DOM.requestGeoBtn.addEventListener('click', handleGeoRequest);
            
            DOM.shareProfileBtn.addEventListener('click', () => {
                shareContent('user', telegramUser.id, telegramUser.id);
            });
            
            DOM.mapActionBtn.addEventListener('click', mapActionButtonHandler);
            DOM.feedCreateBtn.onclick = showSimplePostModal; // Изначально на создание поста
            
            // Глобальный обработчик для динамических кнопок
            document.body.addEventListener('click', (event) => {
                const button = event.target.closest('[data-action]');
                if (!button) return;

                const action = button.dataset.action;
                const id = button.dataset.id;
                if (!action || !id) return;
                
                switch(action) {
                    case 'like-post': toggleLike(button, id, 'post'); break;
                    case 'comment-post': showPostComments(id); break;
                    case 'like-event': toggleLike(button, id, 'event'); break;
                    case 'comment-event': showDetailModal('event', id); break; // Открываем детали для комментирования
                    case 'join-event': joinEvent(id); break;
                    case 'leave-event': leaveEvent(id); break;
                    case 'show-participants': showParticipants(id); break;
                }
            });
        }
        
        function showFallbackScreen(title, message, showRetryButton = false) {
            DOM.fallbackContent.innerHTML = `
                <h1 class="text-2xl font-bold mb-4 ${showRetryButton ? 'text-red-500' : ''}">${escapeHTML(title)}</h1>
                <p class="mb-6" style="color: var(--hint-color);">${escapeHTML(message)}</p>
                ${showRetryButton ? `<button onclick="window.location.reload()" class="font-bold py-3 px-6 rounded-full" style="background-color: var(--button-color); color: var(--button-text-color);">Попробовать снова</button>` : ''}
            `;
            DOM.initialLoader.classList.add('hidden');
            DOM.fallbackScreen.classList.remove('hidden');
        }

        function applyTheme(themeParams) {
             const root = document.documentElement;
             root.style.setProperty('--bg-color', themeParams.bg_color || '#f3f4f6');
             root.style.setProperty('--secondary-bg-color', themeParams.secondary_bg_color || '#ffffff');
             root.style.setProperty('--text-color', themeParams.text_color || '#1f2937');
             root.style.setProperty('--hint-color', themeParams.hint_color || '#6b7280');
             root.style.setProperty('--button-color', themeParams.button_color || '#3b82f6');
             root.style.setProperty('--button-text-color', themeParams.button_text_color || '#ffffff');
             root.style.setProperty('--border-color', themeParams.bg_color ? shadeColor(themeParams.bg_color, -10) : '#e5e7eb');
             
             const buttonColorRgb = hexToRgb(themeParams.button_color || '#3b82f6');
             if (buttonColorRgb) root.style.setProperty('--button-color-rgb', buttonColorRgb.join(', '));
             
             const secondaryBgRgb = hexToRgb(themeParams.secondary_bg_color || '#ffffff');
             if (secondaryBgRgb) root.style.setProperty('--secondary-bg-color-rgb', secondaryBgRgb.join(', '));

             tg.setHeaderColor(themeParams.secondary_bg_color || '#ffffff');
             tg.setBackgroundColor(themeParams.bg_color || '#f3f4f6');
       }
        
        async function upsertUserProfile() {
            if (!telegramUser) throw new Error("Пользователь Telegram не определен для upsertUserProfile.");

            const { data, error } = await supabase.from('profiles').select('id, color').eq('id', telegramUser.id).single();
            
            if (error && error.code !== 'PGRST116') {
                console.error("Ошибка получения профиля:", error); 
                throw error; 
            } 
            
            if (data) {
                AppState.userProfile.color = data.color;
            } else {
                AppState.userProfile.color = generateColorFromId(telegramUser.id);
                const { error: insertError } = await supabase.from('profiles').insert({ 
                    id: telegramUser.id, 
                    name: telegramUser.first_name, 
                    color: AppState.userProfile.color, 
                    photo_url: telegramUser.photo_url || null, 
                });
                if (insertError) { 
                    console.error("Ошибка создания профиля:", insertError); 
                    throw insertError; 
                }
            }
        }
        
        async function handleSimplePostSave() {
            const description = document.getElementById('simple-post-details').value.trim();
            const file = AppState.simplePostContext?.file;

            if (!description) {
                tg.showAlert("Пожалуйста, введите текст поста.");
                return;
            }

            let photoUrl = null;
            if (file) {
                try {
                    const filePath = `${telegramUser.id}/posts/${Date.now()}_${file.name}`;
                    const { data, error } = await supabase.storage.from('photo').upload(filePath, file);
                    if (error) throw error;
                    photoUrl = supabase.storage.from('photo').getPublicUrl(data.path).data.publicUrl;
                } catch(error) {
                    console.error("Error uploading photo:", error); tg.showAlert("Не удалось загрузить фото."); return;
                }
            }

            const postData = {
                user_id: telegramUser.id,
                title: description.substring(0, 50) + (description.length > 50 ? '...' : ''),
                description: description,
                photo_url: photoUrl,
                user_name: telegramUser.first_name,
                user_avatar_url: telegramUser.photo_url,
                user_color: AppState.userProfile.color
            };

            const { error: postError } = await supabase.from('posts').insert(postData);
            
            if (postError) {
                console.error("Error saving post:", postError); tg.showAlert("Не удалось сохранить пост.");
            } else {
                tg.showAlert("Пост успешно опубликован!");
                hideSimplePostModal();
            }
        }

        async function fetchAllProfilesAndDraw() {
            let { data: profiles, error } = await supabase.from('profiles').select('*');
            if (error) { console.error("Error fetching profiles:", error); return; }
            AppState.allProfilesData = profiles;
            
            renderUserList(profiles);
        }

        function renderUserList(profiles) {
            DOM.leaderboardDiv.innerHTML = profiles.map((u) => {
                const isCurrentUser = telegramUser && u.id === telegramUser.id;
                const name = escapeHTML(u.name);
                const displayName = isCurrentUser ? `${name} (Вы)` : name;
                const avatar = u.photo_url || `https://placehold.co/50x50/E5E7EB/4B5563?text=${name.charAt(0)}`;
                return `<div class="card-bg rounded-xl shadow-md p-4 flex items-center space-x-4 cursor-pointer hover:bg-gray-50 transition" onclick="showDetailModal('user', ${u.id})">
                                        <img src="${avatar}" class="w-12 h-12 rounded-full" alt="avatar">
                                        <div class="flex-grow">
                                            <p class="font-bold">${displayName}</p>
                                        </div>
                                    </div>`
            }).join('');
        }

        async function renderFeedPosts() {
            const container = document.getElementById('feed-content-posts');
            container.innerHTML = generateSkeletonFeed(3); // Скелетон
            
            const { data: posts, error: postsError } = await supabase.from('posts').select('*').order('created_at', { ascending: false });
            if (postsError) { console.error("Error fetching posts:", postsError); return; }
            
            if (posts.length === 0) {
                container.innerHTML = '<p class="text-center text-gray-500 py-8">В ленте пока нет постов.</p>';
                return;
            }
            const postIds = posts.map(p => p.id);
            const { data: likes, error: likesError } = await supabase.from('likes').select('*').in('post_id', postIds);
            const { data: comments, error: commentsError } = await supabase.from('comments').select('id, post_id').in('post_id', postIds);
            if (likesError || commentsError) { console.error("Error fetching activity:", likesError, commentsError); return; }
            const likesByPost = (likes || []).reduce((acc, like) => { (acc[like.post_id] = acc[like.post_id] || []).push(like); return acc; }, {});
            const commentsByPost = (comments || []).reduce((acc, comment) => { (acc[comment.post_id] = acc[comment.post_id] || []).push(comment); return acc; }, {});
            
            container.innerHTML = posts.map(post => generatePostHTML(post, likesByPost[post.id] || [], commentsByPost[post.id] || [])).join('');

            if (scrollToPostId) {
                const postElement = document.getElementById(`post-${scrollToPostId}`);
                if (postElement) {
                    setTimeout(() => {
                        postElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        postElement.style.transition = 'background-color 0.5s ease';
                        postElement.style.backgroundColor = 'rgba(var(--button-color-rgb), 0.15)';
                        setTimeout(() => {
                            postElement.style.backgroundColor = '';
                        }, 2500);
                    }, 200);
                }
                scrollToPostId = null;
            }
        }
        
        function generatePostHTML(post, likes, comments) {
            const avatar = post.user_avatar_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${post.user_name.charAt(0)}`;
            const userHasLiked = telegramUser && likes.some(like => like.user_id === telegramUser.id);
            const isOwner = telegramUser && post.user_id === telegramUser.id;

            return `<div class="card-bg rounded-2xl shadow-lg overflow-hidden" id="post-${post.id}">
                        <div class="p-4">
                            <div class="flex justify-between items-start">
                                <div class="flex items-center space-x-3 cursor-pointer" onclick="showDetailModal('user', ${post.user_id})">
                                    <img src="${avatar}" class="w-10 h-10 rounded-full" alt="avatar">
                                    <div>
                                        <p class="font-bold">${escapeHTML(post.user_name)}</p>
                                        <p class="text-xs" style="color: var(--hint-color);">${new Date(post.created_at).toLocaleString('ru-RU')}</p>
                                    </div>
                                </div>
                                ${isOwner ? `<button onclick="confirmDelete('post', ${post.id})" class="p-2 rounded-full hover:bg-gray-200 text-gray-500 hover:text-red-500"><i class="fa-solid fa-trash-can"></i></button>` : ''}
                            </div>
                            <p class="mt-4">${escapeHTML(post.description)}</p>
                        </div>
                        ${post.photo_url ? `<img src="${post.photo_url}" class="w-full h-64 object-cover" alt="Post photo">` : ''}
                        <div class="p-4">
                            <div class="flex items-center justify-between mt-3">
                                <div class="flex items-center space-x-6" style="color: var(--hint-color);">
                                    <button class="like-btn flex items-baseline space-x-1 hover:text-red-500 transition ${userHasLiked ? 'liked' : ''}" data-action="like-post" data-id="${post.id}">
                                        <i class="fa-${userHasLiked ? 'solid' : 'regular'} fa-heart h-6 w-6"></i>
                                        <span data-likes-count>${likes.length}</span>
                                    </button>
                                    <button class="flex items-baseline space-x-1 hover:text-blue-500 transition" data-action="comment-post" data-id="${post.id}">
                                        <i class="fa-regular fa-comment h-6 w-6"></i>
                                        <span>${comments.length}</span>
                                    </button>
                                </div>
                                <button class="flex items-center space-x-1 hover:text-blue-500 transition" onclick="shareContent('post', ${post.id}, ${post.user_id})" style="color: var(--hint-color);">
                                    <i class="fa-solid fa-arrow-up-from-bracket h-5 w-5"></i>
                                </button>
                            </div>
                        </div>
                    </div>`;
        }

        async function toggleLike(buttonElement, targetId, type) {
            if (!telegramUser) {
                tg.showAlert('Пользователь не определен. Попробуйте перезагрузить приложение.');
                return;
            }
            tg.HapticFeedback.impactOccurred('light');
            
            const hasLiked = buttonElement.classList.contains('liked');
            const countSpan = buttonElement.querySelector('[data-likes-count]');
            const icon = buttonElement.querySelector('i');
            let currentCount = parseInt(countSpan.textContent, 10);

            // Оптимистичное обновление UI
            buttonElement.classList.toggle('liked');
            icon.classList.toggle('fa-solid', !hasLiked);
            icon.classList.toggle('fa-regular', hasLiked);
            countSpan.textContent = hasLiked ? currentCount - 1 : currentCount + 1;

            try {
                const likeData = { user_id: telegramUser.id };
                if (type === 'post') likeData.post_id = targetId;
                if (type === 'event') likeData.event_id = targetId;

                if (hasLiked) {
                    await supabase.from('likes').delete().match(likeData);
                } else {
                    await supabase.from('likes').insert(likeData);
                }
            } catch (error) {
                console.error("Ошибка лайка:", error);
                // Откат UI в случае ошибки
                buttonElement.classList.toggle('liked');
                icon.classList.toggle('fa-solid');
                icon.classList.toggle('fa-regular');
                countSpan.textContent = currentCount;
                tg.showAlert('Не удалось обработать лайк. Попробуйте снова.');
            }
        }
        
        // --- СИСТЕМА КОММЕНТАРИЕВ (ОБЩАЯ) ---
        async function fetchComments(type, id) {
            let query = supabase.from('comments').select('*, profiles(id, name, photo_url)');
            
            if (type === 'post') query = query.eq('post_id', id);
            else if (type === 'spot') query = query.eq('spot_id', id);
            else if (type === 'route') query = query.eq('route_id', id);
            else if (type === 'event') query = query.eq('event_id', id);

            const { data, error } = await query.order('created_at', { ascending: true });
            return { data, error };
        }
        
        async function showPostComments(postId) {
            tg.HapticFeedback.impactOccurred('medium');
            AppState.currentReplyTarget = { type: 'post', id: postId, parentCommentId: null };
            cancelReply();
            
            const modalBody = document.getElementById('comments-modal-body');
            modalBody.innerHTML = generateSkeletonFeed(2, true); // Скелетон для комментов
            showModal(DOM.commentsModal);
            
            const { data: comments, error } = await fetchComments('post', postId);
            if (error) { modalBody.innerHTML = `<p class="text-center p-4 text-red-500">Ошибка загрузки комментариев</p>`; return; }

            renderCommentTree(comments, modalBody);
        }

        async function loadAndRenderComments(type, id, containerId) {
             const container = document.querySelector(`#${containerId}`);
             if (!container) return;
             container.innerHTML = generateSkeletonFeed(2, true);
             
             const { data: comments, error } = await fetchComments(type, id);
             if (error) { container.innerHTML = `<p class="text-center p-4 text-red-500">Ошибка загрузки</p>`; return; }

             renderCommentTree(comments, container, 'detail');
        }

        function renderCommentTree(comments, container, context = 'post') {
            const commentsByParent = (comments || []).reduce((acc, comment) => { (acc[comment.parent_comment_id || 'root'] = acc[comment.parent_comment_id || 'root'] || []).push(comment); return acc; }, {});
            const rootComments = commentsByParent['root'] || [];
            container.innerHTML = rootComments.length ? rootComments.map(c => generateCommentHTML(c, commentsByParent, context)).join('') : '<p class="text-center text-gray-500 py-4">Нет комментариев</p>';
        }

        function hideCommentsModal() {
            hideModal(DOM.commentsModal);
        }

        function generateCommentHTML(comment, commentsByParent, context = 'post') {
            const replies = commentsByParent[comment.id] || [];
            const profileName = comment.profiles ? escapeHTML(comment.profiles.name) : 'Аноним';
            const avatar = comment.profiles ? (comment.profiles.photo_url || `https://placehold.co/32x32/E5E7EB/4B5563?text=${profileName.charAt(0)}`) : 'https://placehold.co/32x32';
            const replyFn = context === 'post' ? 'setReplyMode' : 'setDetailReplyMode';
            const parentId = comment.post_id || comment.spot_id || comment.route_id || comment.event_id;

            return `<div class="flex items-start space-x-3 mt-4">
                        <img src="${avatar}" class="w-8 h-8 rounded-full">
                        <div class="flex-1">
                            <div class="rounded-lg p-2" style="background-color: var(--bg-color);">
                                <p class="font-bold text-sm">${profileName}</p>
                                <p class="text-sm">${escapeHTML(comment.content)}</p>
                            </div>
                            <div class="text-xs mt-1">
                                <button onclick="${replyFn}('${parentId}', ${comment.id}, '${profileName.replace(/'/g, "\\'")}')" class="font-medium" style="color: var(--hint-color);">Ответить</button>
                            </div>
                            <div class="pl-4 border-l-2">${replies.map(reply => generateCommentHTML(reply, commentsByParent, context)).join('')}</div>
                        </div>
                    </div>`;
        }
        
        function setReplyMode(postId, parentCommentId, parentAuthorName) {
            AppState.currentReplyTarget = { type: 'post', id: postId, parentCommentId };
            document.getElementById('reply-indicator-text').textContent = `Ответ: ${parentAuthorName}`;
            document.getElementById('reply-indicator').classList.remove('hidden');
            document.getElementById('main-comment-input').focus();
        }

        function cancelReply() {
            AppState.currentReplyTarget.parentCommentId = null;
            document.getElementById('reply-indicator').classList.add('hidden');
        }

        async function postComment() {
            const { type, id, parentCommentId } = AppState.currentReplyTarget;
            if (!id || !telegramUser) return;
            const inputElement = document.getElementById('main-comment-input');
            const content = inputElement.value.trim();
            if (!content) return;
            
            const commentData = { 
                post_id: id, user_id: telegramUser.id, 
                parent_comment_id: parentCommentId, content: content 
            };
            const { error } = await supabase.from('comments').insert(commentData);
            if (error) { tg.showAlert('Ошибка отправки'); } else { inputElement.value = ''; cancelReply(); }
        }

        function setDetailReplyMode(id, parentCommentId, parentAuthorName) {
            const contextType = AppState.currentDetailContext.type;
            AppState.currentReplyTarget = { type: contextType, id: id, parentCommentId: parentCommentId };

            const indicator = document.querySelector(`#${contextType}-comments-section #detail-reply-indicator`);
            if(indicator) {
                indicator.querySelector('#detail-reply-indicator-text').textContent = `Ответ: ${parentAuthorName}`;
                indicator.classList.remove('hidden');
                indicator.closest('div').querySelector('textarea').focus();
            }
        }
        
        function cancelDetailReply() {
            const contextType = AppState.currentDetailContext.type;
            AppState.currentReplyTarget.parentCommentId = null;
            const indicator = document.querySelector(`#${contextType}-comments-section #detail-reply-indicator`);
            if(indicator) indicator.classList.add('hidden');
        }

        async function postDetailComment() {
            const { type, id, parentCommentId } = AppState.currentReplyTarget;
            if (!id || !telegramUser) return;
            
            const inputElement = document.querySelector(`#${type}-comments-section textarea`);
            const content = inputElement.value.trim();
            if (!content) return;

            const commentData = {
                user_id: telegramUser.id,
                parent_comment_id: parentCommentId,
                content: content
            };
            commentData[`${type}_id`] = id;

            const { error } = await supabase.from('comments').insert(commentData);

            if (error) { 
                tg.showAlert('Ошибка отправки комментария.'); 
                console.error("Comment post error:", error);
            } else { 
                inputElement.value = ''; 
                cancelDetailReply();
                loadAndRenderComments(type, id, `${type}-comments-list`);
            }
        }

        function switchMainProfileTab(tabName) {
            document.querySelectorAll('#profile-view .profile-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('#profile-view .profile-tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`profile-tab-${tabName}`).classList.add('active');
            document.getElementById(`profile-content-${tabName}`).classList.add('active');
        }

        async function renderMyProfileContent() {
            if (!telegramUser) return;
            const userId = telegramUser.id;

            // Показываем скелетоны
            document.getElementById('profile-content-posts').innerHTML = generateSkeletonFeed(1);
            document.getElementById('profile-content-events').innerHTML = generateSkeletonFeed(1);
            document.getElementById('profile-content-spots').innerHTML = generateSkeletonFeed(1);
            document.getElementById('profile-content-routes').innerHTML = generateSkeletonFeed(1);

            const [postsRes, spotsRes, routesRes, eventsRes] = await Promise.all([
                supabase.from('posts').select('*').eq('user_id', userId).order('created_at', { ascending: false }),
                supabase.from('spots').select('*').eq('user_id', userId).order('created_at', { ascending: false }),
                supabase.from('routes').select('*').eq('user_id', userId).order('created_at', { ascending: false }),
                supabase.rpc('get_user_events', { p_user_id: userId })
            ]);

            // Посты
            const posts = postsRes.data || [];
            const postIds = posts.map(p => p.id);
            const likesByPost = {};
            const commentsByPost = {};
            if (postIds.length > 0) {
                const { data: likes } = await supabase.from('likes').select('*').in('post_id', postIds);
                const { data: comments } = await supabase.from('comments').select('id, post_id').in('post_id', postIds);
                if(likes) likes.forEach(like => (likesByPost[like.post_id] = likesByPost[like.post_id] || []).push(like));
                if(comments) comments.forEach(comment => (commentsByPost[comment.post_id] = commentsByPost[comment.post_id] || []).push(comment));
            }
            const postsContainer = document.getElementById('profile-content-posts');
            postsContainer.innerHTML = posts.length > 0 ? posts.map(p => generatePostHTML(p, likesByPost[p.id] || [], commentsByPost[p.id] || [])).join('') : '<p class="text-center text-gray-500 py-4">У вас нет постов.</p>';
            document.getElementById('profile-tab-posts').textContent = `Посты (${posts.length})`;
            
            // Споты
            const spots = spotsRes.data || [];
            const spotsContainer = document.getElementById('profile-content-spots');
            spotsContainer.innerHTML = spots.length > 0 ? spots.map(s => generateMiniSpotHTML(s, false)).join('') : '<p class="text-center text-gray-500 py-4">У вас нет спотов.</p>';
            document.getElementById('profile-tab-spots').textContent = `Споты (${spots.length})`;

            // Маршруты
            const routes = routesRes.data || [];
            const routesContainer = document.getElementById('profile-content-routes');
            routesContainer.innerHTML = routes.length > 0 ? routes.map(r => generateMiniRouteHTML(r, false)).join('') : '<p class="text-center text-gray-500 py-4">У вас нет маршрутов.</p>';
            document.getElementById('profile-tab-routes').textContent = `Маршруты (${routes.length})`;
            
            // Мероприятия
            const events = eventsRes.data || [];
            const eventsContainer = document.getElementById('profile-content-events');
            if (events.length > 0) {
                const eventHTML = await Promise.all(events.map(e => generateEventCardHTML(e)));
                eventsContainer.innerHTML = eventHTML.join('');
            } else {
                eventsContainer.innerHTML = '<p class="text-center text-gray-500 py-4">Вы не участвуете в мероприятиях.</p>';
            }
            document.getElementById('profile-tab-events').textContent = `Покатушки (${events.length})`;
        }
        
        // --- Handle Start Param ---
        function handleStartParam() {
            const startParam = tg.initDataUnsafe.start_param;
            if (!startParam) return;

            const parts = startParam.split('_');
            const type = parts.length > 1 ? parts[0] : 'user';
            const id = parts.length > 1 ? parts[1] : startParam;
            const numericId = parseInt(id, 10);

            if (isNaN(numericId)) {
                console.warn("Invalid ID in start_param:", startParam);
                return;
            }

            setTimeout(() => {
                switch (type) {
                    case 'user': showDetailModal('user', numericId); break;
                    case 'post': showView('feed-view'); switchFeedTab('posts'); scrollToPostId = numericId; break;
                    case 'route': showDetailModal('route', numericId); break;
                    case 'spot': showDetailModal('spot', numericId); break;
                    case 'event': showDetailModal('event', numericId); break;
                    default:
                        console.warn("Unknown start_param type:", type);
                        if (/^\d+$/.test(startParam)) {
                            showDetailModal('user', parseInt(startParam));
                        }
                }
            }, 500); 
        }
        
        // --- SKELETON LOADER ---
        function generateSkeletonFeed(count = 1, isComment = false) {
            let skeletonHTML = '';
            for (let i = 0; i < count; i++) {
                skeletonHTML += `
                    <div class="skeleton-container card-bg rounded-2xl shadow-lg overflow-hidden p-4 space-y-4">
                        <div class="flex items-center space-x-3">
                            <div class="skeleton w-10 h-10 rounded-full"></div>
                            <div class="flex-1 space-y-2">
                                <div class="skeleton h-4 w-3/4 rounded"></div>
                                <div class="skeleton h-3 w-1/2 rounded"></div>
                            </div>
                        </div>
                        ${!isComment ? `
                        <div class="skeleton h-5 w-full rounded"></div>
                        <div class="skeleton h-24 w-full rounded"></div>
                        ` : `
                        <div class="skeleton h-4 w-full rounded mt-2"></div>
                        <div class="skeleton h-4 w-5/6 rounded mt-1"></div>
                        `}
                    </div>
                `;
            }
            return skeletonHTML;
        }

        // =================================================================
        // --- НОВЫЙ ФУНКЦИОНАЛ: МЕРОПРИЯТИЯ (ПОКАТУШКИ) ---
        // =================================================================

        // --- Рендер ---
        async function renderFeedEvents() {
            const container = document.getElementById('feed-content-events');
            container.innerHTML = generateSkeletonFeed(3);
            
            try {
                const { data, error } = await supabase.from('events')
                    .select(`*, profiles(id, name, photo_url)`)
                    .order('event_time', { ascending: true });

                if (error) throw error;
                
                if (data.length === 0) {
                    container.innerHTML = '<p class="text-center text-gray-500 py-8">Пока нет запланированных покатушек. Создайте первую!</p>';
                    return;
                }
                
                const eventsHTML = await Promise.all(data.map(event => generateEventCardHTML(event)));
                container.innerHTML = eventsHTML.join('');
                data.forEach(event => startCountdown(event.id, new Date(event.event_time)));

            } catch (error) {
                 console.error("Ошибка загрузки мероприятий:", error);
                 container.innerHTML = '<p class="text-center text-red-500 py-8">Не удалось загрузить мероприятия.</p>';
            }
        }
        
        async function renderFeedSpots() {
            const container = document.getElementById('feed-content-spots');
            container.innerHTML = generateSkeletonFeed(4);
            const { data, error } = await supabase.from('spots').select('*').order('created_at', { ascending: false }).limit(20);
            if(error) { container.innerHTML = '<p class="text-center text-red-500 py-8">Не удалось загрузить споты.</p>'; return; }
            if(data.length === 0) { container.innerHTML = '<p class="text-center text-gray-500 py-8">Спотов пока нет.</p>'; return; }
            container.innerHTML = data.map(s => generateMiniSpotHTML(s, true)).join('');
        }
        
        async function renderFeedRoutes() {
            const container = document.getElementById('feed-content-routes');
            container.innerHTML = generateSkeletonFeed(4);
            const { data, error } = await supabase.from('routes').select('*').order('created_at', { ascending: false }).limit(20);
            if(error) { container.innerHTML = '<p class="text-center text-red-500 py-8">Не удалось загрузить маршруты.</p>'; return; }
            if(data.length === 0) { container.innerHTML = '<p class="text-center text-gray-500 py-8">Маршрутов пока нет.</p>'; return; }
            container.innerHTML = data.map(r => generateMiniRouteHTML(r, true)).join('');
        }

        async function generateEventCardHTML(event) {
            const author = event.profiles || { name: 'Аноним', photo_url: null };
            const avatar = author.photo_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${author.name.charAt(0)}`;
            const eventTime = new Date(event.event_time);
            
            let participants = [];
            try {
                const { data: participantsData } = await supabase.from('event_participants').select('user_id', { count: 'exact' }).eq('event_id', event.id);
                participants = participantsData || [];
            } catch (e) {
                console.error(`Failed to fetch activity for event ${event.id}`, e);
            }
            
            const userIsParticipant = telegramUser && participants.some(p => p.user_id === telegramUser.id);

            const participantButton = userIsParticipant 
                ? `<button data-action="leave-event" data-id="${event.id}" class="w-full font-bold py-3 px-4 rounded-full transition-all text-white bg-red-500 hover:bg-red-600">Не пойду</button>`
                : `<button data-action="join-event" data-id="${event.id}" class="w-full font-bold py-3 px-4 rounded-full transition-all text-white bg-green-500 hover:bg-green-600">Участвую!</button>`;
            
            return `<div class="card-bg rounded-2xl shadow-lg overflow-hidden border border-transparent hover:border-blue-400 transition-all duration-300" id="event-${event.id}">
                        <div class="p-4">
                            <div id="event-timer-${event.id}" class="text-center font-bold text-lg mb-4 p-2 rounded-lg" style="background-color: var(--bg-color); color: var(--button-color);"></div>
                            <div class="flex items-center space-x-3 cursor-pointer mb-4" onclick="showDetailModal('user', ${author.id})">
                                <img src="${avatar}" class="w-10 h-10 rounded-full" alt="avatar">
                                <div><p class="font-bold">${escapeHTML(author.name)}</p><p class="text-xs" style="color: var(--hint-color);">Организатор</p></div>
                            </div>
                            <h3 class="text-xl font-bold cursor-pointer hover:text-blue-600" onclick="showDetailModal('event', '${event.id}')">${escapeHTML(event.title)}</h3>
                            <p class="mt-2 text-sm text-gray-600">${escapeHTML(event.description)}</p>
                            <div class="mt-4 p-3 rounded-lg" style="background-color: var(--bg-color);">
                                <div class="flex items-center space-x-3">
                                    <i class="fa-solid fa-calendar-alt w-5 text-center" style="color: var(--hint-color);"></i>
                                    <span class="text-sm font-semibold">${eventTime.toLocaleString('ru-RU', {dateStyle: 'long', timeStyle: 'short'})}</span>
                                </div>
                            </div>
                        </div>
                        <div class="p-4 border-t" style="border-color: var(--border-color);">
                            <div class="flex items-center justify-between mb-4">
                                <div class="flex items-center space-x-6" style="color: var(--hint-color);">
                                    <button class="flex items-baseline space-x-1 hover:text-blue-500 transition" data-action="show-participants" data-id="${event.id}">
                                        <i class="fa-regular fa-user h-6 w-6"></i>
                                        <span data-participants-count>${participants.length}</span>
                                    </button>
                                </div>
                                <button class="flex items-center space-x-1 hover:text-blue-500 transition" onclick="shareContent('event', '${event.id}', ${author.id})" style="color: var(--hint-color);">
                                    <i class="fa-solid fa-arrow-up-from-bracket h-5 w-5"></i>
                                </button>
                            </div>
                            ${participantButton}
                        </div>
                    </div>`;
        }
        
        // --- Создание/Редактирование ---
        async function showEventCreationModal() {
            tg.HapticFeedback.impactOccurred('light');
            
            // Сброс формы
            document.getElementById('event-title').value = '';
            document.getElementById('event-description').value = '';
            document.getElementById('event-datetime').value = '';
            AppState.eventCreationContext = {};

            // Загрузка маршрутов пользователя
            const select = document.getElementById('event-route-select');
            select.innerHTML = '<option value="">Без маршрута</option>';
            const { data: routes, error } = await supabase.from('routes').select('id, name').eq('user_id', telegramUser.id);
            if (error) console.error("Ошибка загрузки маршрутов:", error);
            else routes.forEach(r => select.innerHTML += `<option value="${r.id}">${escapeHTML(r.name)}</option>`);
            
            showModal(DOM.eventCreationModal);

            // Инициализация карты для выбора точки
            setTimeout(initEventPickerMap, 100);
        }
        
        function hideEventCreationModal() {
            hideModal(DOM.eventCreationModal);
            if (eventPickerMap) {
                eventPickerMap.remove();
                eventPickerMap = null;
            }
        }
        
        function initEventPickerMap() {
            if(eventPickerMap) eventPickerMap.remove();
            const center = AppState.lastKnownLocation || [37.62, 55.75]; // lng, lat
            eventPickerMap = new mapboxgl.Map({
                container: 'event-map-picker',
                style: 'mapbox://styles/mapbox/streets-v12',
                center: center,
                zoom: 12
            });
            
            let marker;
            eventPickerMap.on('click', (e) => {
                const coords = e.lngLat;
                AppState.eventCreationContext.meetingPoint = `POINT(${coords.lng} ${coords.lat})`;
                if (marker) {
                    marker.setLngLat(coords);
                } else {
                    marker = new mapboxgl.Marker().setLngLat(coords).addTo(eventPickerMap);
                }
                document.getElementById('event-map-hint').textContent = 'Точка выбрана!';
                document.getElementById('event-map-hint').style.color = 'var(--success-color)';
            });
        }
        
        async function handleEventSave() {
            const title = document.getElementById('event-title').value.trim();
            const description = document.getElementById('event-description').value.trim();
            const event_time = document.getElementById('event-datetime').value;
            const route_id = document.getElementById('event-route-select').value || null;
            const meeting_point = AppState.eventCreationContext.meetingPoint;

            if (!title || !description || !event_time || !meeting_point) {
                tg.showAlert("Пожалуйста, заполните все поля и выберите точку сбора на карте.");
                return;
            }

            const { data, error } = await supabase.from('events').insert({
                creator_id: telegramUser.id,
                title, description, event_time, route_id, meeting_point
            }).select().single();
            
            if (error) {
                console.error("Ошибка создания мероприятия:", error);
                tg.showAlert("Не удалось создать мероприятие.");
            } else {
                // Автоматически добавляем создателя в участники
                await supabase.from('event_participants').insert({ event_id: data.id, user_id: telegramUser.id });
                tg.showAlert("Мероприятие успешно создано!");
                hideEventCreationModal();
                renderCurrentFeedTab();
            }
        }
        
        // --- Участие ---
        async function joinEvent(eventId) {
            tg.HapticFeedback.impactOccurred('light');
            const { error } = await supabase.from('event_participants').insert({ event_id: eventId, user_id: telegramUser.id });
            if (error) {
                console.error("Ошибка присоединения к мероприятию:", error);
                tg.showAlert("Не удалось присоединиться.");
            } else {
                updateEventCard(eventId);
            }
        }
        
        async function leaveEvent(eventId) {
            tg.HapticFeedback.impactOccurred('light');
            const { error } = await supabase.from('event_participants').delete().match({ event_id: eventId, user_id: telegramUser.id });
            if (error) {
                console.error("Ошибка выхода из мероприятия:", error);
                tg.showAlert("Не удалось отменить участие.");
            } else {
                updateEventCard(eventId);
            }
        }
        
        async function showParticipants(eventId) {
            tg.HapticFeedback.impactOccurred('light');
            AppState.currentDetailContext.id = eventId; // Сохраняем контекст
            const modalBody = document.getElementById('participants-modal-body');
            modalBody.innerHTML = generateSkeletonFeed(3, true);
            showModal(DOM.participantsModal);

            const { data, error } = await supabase.from('event_participants')
                .select('profiles(*)')
                .eq('event_id', eventId);
            
            if (error) {
                modalBody.innerHTML = '<p class="text-red-500">Не удалось загрузить список.</p>';
                return;
            }
            
            if (data.length === 0) {
                 modalBody.innerHTML = '<p class="text-gray-500">Пока никто не участвует.</p>';
                 return;
            }

            modalBody.innerHTML = data.map(p => {
                const user = p.profiles;
                const avatar = user.photo_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${user.name.charAt(0)}`;
                return `<div class="flex items-center space-x-3 cursor-pointer p-2 rounded-lg hover:bg-gray-100" onclick="showDetailModal('user', ${user.id})">
                            <img src="${avatar}" class="w-10 h-10 rounded-full">
                            <span class="font-semibold">${escapeHTML(user.name)}</span>
                        </div>`;
            }).join('');
        }
        
        function hideParticipantsModal() {
            hideModal(DOM.participantsModal);
        }

        // --- Таймер ---
        function startCountdown(eventId, eventTime) {
            const timerElement = document.getElementById(`event-timer-${eventId}`);
            if (!timerElement) return;

            const updateTimer = () => {
                const now = new Date();
                const diff = eventTime.getTime() - now.getTime();

                if (diff <= 0) {
                    timerElement.textContent = "Мероприятие началось!";
                    timerElement.style.color = 'var(--success-color)';
                    const timerIndex = countdownTimers.findIndex(t => t.id === eventId);
                    if (timerIndex > -1) {
                        clearInterval(countdownTimers[timerIndex].interval);
                        countdownTimers.splice(timerIndex, 1);
                    }
                    return;
                }

                const d = Math.floor(diff / (1000 * 60 * 60 * 24));
                const h = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const m = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                const s = Math.floor((diff % (1000 * 60)) / 1000);

                let timerText = "До начала: ";
                if(d > 0) timerText += `${d}д `;
                timerText += `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
                timerElement.textContent = timerText;
            };

            updateTimer();
            const intervalId = setInterval(updateTimer, 1000);
            countdownTimers.push({ id: eventId, interval: intervalId });
        }

        function clearCountdownTimers() {
            countdownTimers.forEach(timer => clearInterval(timer.interval));
            countdownTimers = [];
        }

        async function updateEventCard(eventId) {
            const { data: event, error } = await supabase.from('events')
                .select(`*, profiles(id, name, photo_url)`)
                .eq('id', eventId)
                .single();
            if (error || !event) return;

            const cardElement = document.getElementById(`event-${eventId}`);
            if (cardElement) {
                const newCardHTML = await generateEventCardHTML(event);
                cardElement.outerHTML = newCardHTML;
                startCountdown(event.id, new Date(event.event_time));
            }
        }
        
        // --- ПРИВЯЗКА ГЛОБАЛЬНЫХ ФУНКЦИЙ И ЗАПУСК ---
        window.showView = showView;
        window.switchFeedTab = switchFeedTab;
        window.hideDetailModal = hideDetailModal;
        window.toggleLike = toggleLike;
        window.showPostComments = showPostComments;
        window.hideCommentsModal = hideCommentsModal;
        window.setReplyMode = setReplyMode;
        window.cancelReply = cancelReply;
        window.postComment = postComment;
        window.showDetailModal = showDetailModal;
        window.switchProfileTab = switchProfileTab;
        window.switchMainProfileTab = switchMainProfileTab;
        window.navigateToMapObject = navigateToMapObject;
        window.hideSimplePostModal = hideSimplePostModal;
        window.handleSimplePostSave = handleSimplePostSave;
        window.hideCreationModal = hideCreationModal;
        window.postDetailComment = postDetailComment;
        window.setDetailReplyMode = setDetailReplyMode;
        window.cancelDetailReply = cancelDetailReply;
        window.shareContent = shareContent;
        // NEW
        window.showEventCreationModal = showEventCreationModal;
        window.hideEventCreationModal = hideEventCreationModal;
        window.handleEventSave = handleEventSave;
        window.joinEvent = joinEvent;
        window.leaveEvent = leaveEvent;
        window.showParticipants = showParticipants;
        window.hideParticipantsModal = hideParticipantsModal;
        
        document.addEventListener('DOMContentLoaded', runApp);
    </script>
</body>
</html>
