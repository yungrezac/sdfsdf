<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>TerraRun | Карта</title>

    <!-- Подключение Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Подключение Leaflet JS и CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- Подключение Turf.js для гео-анализа -->
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
    
    <!-- Подключение плагина Leaflet.TextPath для текста вдоль линии -->
    <script src="https://unpkg.com/leaflet-textpath/leaflet.textpath.js"></script>
    
    <!-- Подключение Telegram Web App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- Подключение Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <!-- Подключение QR Code Generator -->
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

    <style>
        :root {
            --bg-color: #f3f4f6;
            --secondary-bg-color: #ffffff;
            --text-color: #1f2937;
            --hint-color: #6b7280;
            --button-color: #3b82f6;
            --button-text-color: #ffffff;
            --destructive-color: #ef4444;
            --star-color: #facc15; /* Желтый для звезд */
        }

        /* Адаптация под безопасные зоны iOS */
        body {
            padding-top: constant(safe-area-inset-top);
            padding-top: env(safe-area-inset-top);
            padding-bottom: constant(safe-area-inset-bottom);
            padding-bottom: env(safe-area-inset-bottom);
        }

        body {
            overscroll-behavior: none;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }
        #map, .mini-map, #detail-mini-map {
            z-index: 10;
            background-color: var(--bg-color);
        }
        #map {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 80px; /* Высота навбара */
        }
        .view {
            display: none;
            height: calc(100vh - 80px - env(safe-area-inset-bottom));
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            transition: opacity 0.3s ease-in-out;
            background-color: var(--bg-color);
        }
        .view.active {
            display: block;
        }
        .nav-btn.active svg, .nav-btn.active span {
            color: var(--button-color);
        }
        .nav-btn span {
             color: var(--hint-color);
        }
        .nav-btn.active span {
            color: var(--button-color);
        }
        .card-bg {
            background-color: var(--secondary-bg-color);
        }
        #bottom-navbar {
            height: calc(80px + env(safe-area-inset-bottom));
            padding-bottom: env(safe-area-inset-bottom);
            background-color: color-mix(in srgb, var(--secondary-bg-color) 80%, transparent);
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .avatar-marker {
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 15px rgba(0,0,0,0.4);
            background-size: cover;
            background-position: center;
            transition: transform 0.2s ease-in-out;
        }
        .avatar-marker:hover {
            transform: scale(1.1);
        }
        .current-user-marker {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 2px 15px rgba(0,0,0,0.4), 0 0 0 0 color-mix(in srgb, var(--button-color) 70%, transparent); }
            70% { box-shadow: 0 2px 15px rgba(0,0,0,0.4), 0 0 0 15px color-mix(in srgb, var(--button-color) 0%, transparent); }
            100% { box-shadow: 0 2px 15px rgba(0,0,0,0.4), 0 0 0 0 color-mix(in srgb, var(--button-color) 0%, transparent); }
        }
        .like-btn.liked svg {
            fill: var(--destructive-color);
            color: var(--destructive-color);
        }
        #main-action-btn {
            position: fixed;
            bottom: calc(5.5rem + env(safe-area-inset-bottom)); /* 88px + safe area */
            left: 50%;
            transform: translateX(-50%);
            z-index: 30;
            transition: all 0.3s ease-in-out;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.2), 0 8px 10px -6px rgba(0, 0, 0, 0.2);
        }
        #main-action-btn.running {
            background-color: var(--destructive-color);
        }
        #main-action-btn.hidden {
            bottom: -100px;
        }
        #initial-loader {
            background-color: var(--bg-color);
        }
        /* Стили для верхней панели на карте */
        #map-top-panel {
            position: fixed;
            top: calc(1rem + env(safe-area-inset-top));
            left: 0;
            right: 0;
            z-index: 20;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1rem;
            pointer-events: none; /* Позволяет кликать сквозь контейнер */
        }
        #mode-switcher {
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 9999px;
            padding: 0.25rem;
            display: flex;
            gap: 0.25rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            pointer-events: all; /* Включаем клики для самого свитчера */
            margin: 0 auto; /* Центрирование */
        }
        #recenter-btn {
            pointer-events: all; /* Включаем клики для кнопки */
        }
        .mode-btn {
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--hint-color);
            transition: all 0.2s ease-in-out;
            border: none;
            background-color: transparent;
        }
        .mode-btn.active {
            background-color: var(--button-color);
            color: var(--button-text-color);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        /* Стили для модальных окон */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0,0,0,0.4);
            display: flex;
            z-index: 50;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        
        /* Модальное окно сверху вниз */
        #simple-post-modal {
            align-items: flex-start;
        }
        #simple-post-content {
            transform: translateY(-100%);
            transition: transform 0.3s ease-in-out;
        }
        #simple-post-modal.visible #simple-post-content {
            transform: translateY(0);
        }

        /* Модальное окно снизу вверх (Bottom Sheet) */
        .bottom-sheet-modal {
            align-items: flex-end;
        }
        .bottom-sheet-content {
            width: 100%;
            background-color: var(--secondary-bg-color);
            border-radius: 1.5rem 1.5rem 0 0;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform 0.3s ease-in-out;
        }
        .bottom-sheet-modal.visible .bottom-sheet-content {
            transform: translateY(0);
        }
        .grabber {
            width: 3rem;
            height: 0.375rem;
            background-color: #d1d5db;
            border-radius: 9999px;
            margin: 0.75rem auto;
            flex-shrink: 0;
            cursor: grab;
        }
        
        /* Стили для звездного рейтинга */
        .star-rating {
            display: inline-flex;
            flex-direction: row-reverse;
            justify-content: center;
        }
        .star-rating input { display: none; }
        .star-rating label {
            color: #ccc;
            cursor: pointer;
            font-size: 2rem;
            transition: color 0.2s;
        }
        .star-rating input:checked ~ label,
        .star-rating label:hover,
        .star-rating label:hover ~ label {
            color: var(--star-color);
        }
        /* Стили для табов в профиле */
        .profile-tab {
            flex-grow: 1;
            text-align: center;
            padding: 0.75rem 0.5rem;
            font-weight: 600;
            color: var(--hint-color);
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }
        .profile-tab.active {
            color: var(--button-color);
            border-bottom-color: var(--button-color);
        }
        .profile-tab-content {
            display: none;
        }
        .profile-tab-content.active {
            display: block;
        }
        
        /* NEW: Стили для комментариев в модальном окне деталей */
        #detail-comments-section {
            border-top: 1px solid var(--bg-color);
            padding: 1rem;
        }
        #detail-comment-input-form {
            padding: 0.5rem 1rem 1rem;
            border-top: 1px solid var(--bg-color);
            background-color: var(--secondary-bg-color);
        }
    </style>
</head>
<body class="font-sans antialiased overflow-hidden">
    
    <!-- Начальный загрузчик -->
    <div id="initial-loader" class="fixed inset-0 flex flex-col items-center justify-center z-50">
        <svg class="animate-spin h-10 w-10 mb-4" style="color: var(--button-color);" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
        <p id="loader-text" class="text-lg font-semibold" style="color: var(--text-color);">Загрузка TerraRun...</p>
    </div>

    <!-- Экран-заглушка / Ошибка -->
    <div id="fallback-screen" class="fixed inset-0 flex items-center justify-center p-4 z-40 hidden">
        <div id="fallback-content" class="text-center card-bg p-8 rounded-2xl shadow-lg max-w-sm"></div>
    </div>

    <!-- Основной контейнер приложения -->
    <div id="app-container" class="hidden">
        <!-- Вид 1: Карта -->
        <div id="map-view" class="view active">
            <div id="map"></div>
            
            <div id="map-top-panel">
                <div class="w-12"></div> <!-- Пустой див для баланса -->
                <div id="mode-switcher" class="hidden">
                    <button id="mode-capture" class="mode-btn active">Захват</button>
                    <button id="mode-spots" class="mode-btn">Споты</button>
                    <button id="mode-routes" class="mode-btn">Маршруты</button>
                </div>
                <button id="recenter-btn" class="bg-white/80 backdrop-blur-md p-3 rounded-full shadow-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-gray-700" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0zM15 11a3 3 0 11-6 0 3 3 0 016 0z" /></svg>
                </button>
            </div>
        </div>

        <!-- Вид 2: Лента -->
        <div id="feed-view" class="view p-4 fade-in">
            <div class="flex justify-between items-center mb-6 px-2">
                <h1 class="text-3xl font-bold">Лента</h1>
                <button id="create-simple-post-btn" class="p-2 rounded-full hover:bg-gray-200" style="background-color: var(--secondary-bg-color);">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" style="color: var(--button-color);" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" /></svg>
                </button>
            </div>
            <div id="feed-container" class="space-y-4"></div>
        </div>

        <!-- Вид 3: Топ пользователей -->
        <div id="top-view" class="view p-4 fade-in">
            <div class="flex justify-between items-center mb-6 px-2">
                <h1 class="text-3xl font-bold">Топ Бегунов</h1>
                <button id="scan-qr-btn" class="p-2 rounded-full hover:bg-gray-200" style="background-color: var(--secondary-bg-color);">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" style="color: var(--hint-color);" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect><line x1="14" y1="14" x2="21" y2="14"></line><line x1="14" y1="17.5" x2="21" y2="17.5"></line><line x1="14" y1="21" x2="21" y2="21"></line></svg>
                </button>
            </div>
            <div id="leaderboard" class="space-y-3"></div>
        </div>

        <!-- Вид 4: Профиль -->
        <div id="profile-view" class="view p-4 fade-in">
            <h1 class="text-3xl font-bold mb-6 px-2">Профиль</h1>
            <div class="card-bg rounded-2xl shadow-lg p-6 flex flex-col items-center space-y-4">
                <div id="profile-avatar-wrapper" class="w-24 h-24 rounded-full border-4 flex-shrink-0">
                    <img src="https://placehold.co/96x96/E2E8F0/4A5568?text=?" id="profile-avatar-img" class="w-full h-full rounded-full object-cover" alt="avatar">
                </div>
                <div class="text-center">
                    <h2 id="profile-name" class="text-2xl font-bold">Загрузка...</h2>
                    <p class="text-sm mt-2" style="color: var(--hint-color);">Общая площадь</p>
                    <p id="profile-area" class="text-3xl font-bold" style="color: var(--button-color);">0 м²</p>
                </div>
                <div class="w-full pt-4 mt-4 border-t" style="border-color: color-mix(in srgb, var(--bg-color) 70%, transparent);">
                    <div class="grid grid-cols-3 gap-4 text-center">
                        <button id="invite-friend-btn" class="flex flex-col items-center space-y-1 transition-opacity hover:opacity-70">
                            <div class="p-3 rounded-full" style="background-color: color-mix(in srgb, var(--button-color) 15%, transparent);"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" style="color: var(--button-color);" viewBox="0 0 20 20" fill="currentColor"><path d="M8 9a3 3 0 100-6 3 3 0 000 6zM8 11a6 6 0 016 6H2a6 6 0 016-6zM16 11a1 1 0 10-2 0v1h-1a1 1 0 100 2h1v1a1 1 0 102 0v-1h1a1 1 0 100-2h-1v-1z" /></svg></div>
                            <span class="text-xs font-medium" style="color: var(--hint-color);">Пригласить</span>
                        </button>
                        <button id="show-qr-btn" class="flex flex-col items-center space-y-1 transition-opacity hover:opacity-70">
                            <div class="p-3 rounded-full" style="background-color: color-mix(in srgb, var(--button-color) 15%, transparent);"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" style="color: var(--button-color);" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect><line x1="14" y1="14" x2="21" y2="14"></line><line x1="14" y1="17.5" x2="21" y2="17.5"></line><line x1="14" y1="21" x2="21" y2="21"></line></svg></div>
                            <span class="text-xs font-medium" style="color: var(--hint-color);">Мой QR</span>
                        </button>
                        <button id="donate-btn" class="flex flex-col items-center space-y-1 transition-opacity hover:opacity-70">
                            <div class="p-3 rounded-full" style="background-color: color-mix(in srgb, #28a745 15%, transparent);"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" style="color: #28a745;" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd" /></svg></div>
                            <span class="text-xs font-medium" style="color: var(--hint-color);">Поддержать</span>
                        </button>
                    </div>
                </div>
            </div>
             <!-- NEW TABS -->
            <div class="flex border-b mt-6 sticky top-0 z-10" style="background-color: var(--bg-color);">
                <div id="profile-tab-posts" class="profile-tab active" onclick="switchMainProfileTab('posts')">Посты</div>
                <div id="profile-tab-spots" class="profile-tab" onclick="switchMainProfileTab('spots')">Споты</div>
                <div id="profile-tab-routes" class="profile-tab" onclick="switchMainProfileTab('routes')">Маршруты</div>
            </div>

            <div id="profile-content-posts" class="profile-tab-content active mt-4 space-y-4"></div>
            <div id="profile-content-spots" class="profile-tab-content mt-4 space-y-4"></div>
            <div id="profile-content-routes" class="profile-tab-content mt-4 space-y-4"></div>
        </div>
        
        <!-- Главная плавающая кнопка действия -->
        <button id="main-action-btn" class="hidden w-auto h-20 px-8 rounded-full text-white items-center justify-center transition-all" style="background-color: var(--button-color);">
            <!-- Содержимое кнопки будет меняться в JS -->
        </button>
    </div>

    <!-- Нижний навбар -->
    <nav id="bottom-navbar" class="hidden fixed bottom-0 left-0 right-0 backdrop-blur-md shadow-[0_-5px_20px_-5px_rgba(0,0,0,0.1)] flex justify-around items-center z-20">
        <button class="nav-btn active flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('map-view')"><svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" /><path stroke-linecap="round" stroke-linejoin="round" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" /></svg><span>Карта</span></button>
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('feed-view')"><svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3h2m0 0h2" /></svg><span>Лента</span></button>
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('top-view')"><svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 013 19.875v-6.75zM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V8.625zM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V4.125z" /></svg><span>Топ</span></button>
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('profile-view')"><svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" /></svg><span>Профиль</span></button>
    </nav>
    
    <!-- Модальное окно создания поста-достижения (старое) -->
    <div id="edit-modal" class="modal-overlay justify-center items-center p-4" onclick="if(event.target === this) hideEditModal()">
        <div class="card-bg rounded-2xl shadow-2xl p-6 w-full max-w-md fade-in space-y-4">
            <h2 id="edit-modal-title" class="text-2xl font-bold"></h2>
            <p id="edit-modal-description" style="color: var(--hint-color);"></p>
            <div>
                <label for="edit-modal-name" class="block text-sm font-medium">Название</label>
                <input type="text" id="edit-modal-name" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500" placeholder="Например, 'Красивый вид'">
            </div>
            <div id="edit-modal-details-section">
                <label for="edit-modal-details" class="block text-sm font-medium">Описание</label>
                <textarea id="edit-modal-details" rows="3" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500" placeholder="Опишите это место, маршрут или просто поделитесь мыслями..."></textarea>
            </div>
            <div id="edit-modal-photo-section">
                <label for="edit-modal-photo-input" class="block text-sm font-medium">Фото</label>
                <div class="mt-1 flex justify-center px-6 pt-5 pb-6 border-2 border-gray-300 border-dashed rounded-md">
                    <div class="space-y-1 text-center">
                        <img id="edit-modal-photo-preview" src="" alt="Предпросмотр фото" class="hidden mx-auto h-24 w-auto mb-4 rounded">
                        <svg id="edit-modal-photo-icon" class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48" aria-hidden="true"><path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /></svg>
                        <div class="flex text-sm text-gray-600">
                            <label id="edit-modal-photo-input-label" for="edit-modal-photo-input" class="relative cursor-pointer rounded-md font-medium" style="color: var(--button-color);">
                                <span>Загрузите файл</span>
                                <input id="edit-modal-photo-input" name="edit-modal-photo-input" type="file" class="sr-only" accept="image/*">
                            </label>
                            <p class="pl-1">или перетащите</p>
                        </div>
                        <p class="text-xs text-gray-500">PNG, JPG до 10MB</p>
                    </div>
                </div>
            </div>
            <div class="flex justify-end space-x-3">
                <button id="cancel-edit-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-full transition-all">Отмена</button>
                <button id="save-edit-btn" class="text-white font-bold py-2 px-4 rounded-full transition-all flex items-center justify-center" style="background-color: var(--button-color); color: var(--button-text-color)">
                    <span id="save-edit-text">Сохранить</span>
                    <svg id="save-edit-loader" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                </button>
            </div>
        </div>
    </div>

    <!-- NEW: Модальное окно создания простого поста (сверху вниз, 45%) -->
    <div id="simple-post-modal" class="modal-overlay" onclick="if(event.target === this) hideSimplePostModal()">
        <div id="simple-post-content" class="card-bg rounded-b-2xl shadow-2xl p-6 w-full max-w-lg space-y-4" style="height: 45vh;">
            <div class="flex justify-between items-center">
                <h2 class="text-2xl font-bold">Новый пост</h2>
                <button onclick="hideSimplePostModal()" class="p-2 rounded-full hover:bg-gray-200">&times;</button>
            </div>
            <p style="color: var(--hint-color);">Поделитесь своими мыслями с сообществом.</p>
            <textarea id="simple-post-details" class="mt-1 block w-full h-1/3 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500" placeholder="Что у вас нового?"></textarea>
            <div id="simple-post-filename" class="text-sm text-gray-500 truncate"></div>
            <div class="flex justify-between items-center pt-4">
                 <label for="simple-post-photo-input" class="cursor-pointer p-2 rounded-full hover:bg-gray-200">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" style="color: var(--hint-color);" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13" />
                    </svg>
                    <input id="simple-post-photo-input" type="file" class="sr-only" accept="image/*">
                </label>
                <button onclick="handleSimplePostSave()" class="text-white font-bold py-2 px-6 rounded-full transition-all" style="background-color: var(--button-color);">Опубликовать</button>
            </div>
        </div>
    </div>

    <!-- NEW: Модальное окно создания Спота/Маршрута (снизу вверх, 75%) -->
    <div id="creation-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideCreationModal()">
        <div class="bottom-sheet-content" style="height: 75%; max-height: calc(100vh - env(safe-area-inset-top) - 1rem);">
            <div class="grabber" onclick="hideCreationModal()"></div>
            <div id="creation-modal-body" class="flex-grow overflow-y-auto p-4 space-y-4">
                <h2 id="creation-modal-title" class="text-2xl font-bold"></h2>
                <p id="creation-modal-description" style="color: var(--hint-color);"></p>
                <div>
                    <label for="creation-modal-name" class="block text-sm font-medium">Название</label>
                    <input type="text" id="creation-modal-name" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500" placeholder="Например, 'Красивый вид'">
                </div>
                <div>
                    <label for="creation-modal-details" class="block text-sm font-medium">Описание</label>
                    <textarea id="creation-modal-details" rows="3" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500" placeholder="Опишите это место или маршрут..."></textarea>
                </div>
                <div>
                    <label for="creation-modal-photo-input" class="block text-sm font-medium">Фото</label>
                    <div class="mt-1 flex justify-center px-6 pt-5 pb-6 border-2 border-gray-300 border-dashed rounded-md">
                        <div class="space-y-1 text-center">
                            <img id="creation-modal-photo-preview" src="" alt="Предпросмотр фото" class="hidden mx-auto h-24 w-auto mb-4 rounded">
                            <svg id="creation-modal-photo-icon" class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48" aria-hidden="true"><path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /></svg>
                            <div class="flex text-sm text-gray-600">
                                <label for="creation-modal-photo-input" class="relative cursor-pointer rounded-md font-medium" style="color: var(--button-color);">
                                    <span>Загрузите файл</span>
                                    <input id="creation-modal-photo-input" type="file" class="sr-only" accept="image/*">
                                </label>
                                <p class="pl-1">или перетащите</p>
                            </div>
                            <p class="text-xs text-gray-500">PNG, JPG до 10MB</p>
                        </div>
                    </div>
                </div>
                <div class="flex justify-end space-x-3 pt-4">
                    <button onclick="hideCreationModal()" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-full transition-all">Отмена</button>
                    <button id="save-creation-btn" class="text-white font-bold py-2 px-4 rounded-full transition-all" style="background-color: var(--button-color);">Сохранить</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно деталей (выдвигается снизу) -->
    <div id="detail-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideDetailModal()">
        <div class="bottom-sheet-content" style="height: 90%; max-height: calc(100vh - env(safe-area-inset-top) - 1rem);">
            <div class="grabber" onclick="hideDetailModal()"></div>
            <div id="detail-modal-body" class="flex-grow overflow-y-auto"></div>
        </div>
    </div>

    <!-- Модальное окно с комментариями (ДЛЯ ПОСТОВ) -->
    <div id="comments-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideCommentsModal()">
        <div class="bottom-sheet-content" style="height: 75%;">
             <div class="grabber" onclick="hideCommentsModal()"></div>
             <h2 id="comments-modal-title" class="text-xl font-bold px-4 pb-2 flex-shrink-0">Комментарии</h2>
            <div id="comments-modal-body" class="flex-grow overflow-y-auto p-4"></div>
            <div id="comment-input-container" class="flex-shrink-0 p-2 border-t" style="background-color: var(--secondary-bg-color); border-color: var(--bg-color);">
                <div id="reply-indicator" class="hidden text-xs px-2 pb-1 flex justify-between items-center" style="color: var(--hint-color);">
                    <span id="reply-indicator-text"></span>
                    <button onclick="cancelReply()" class="font-bold text-xl">&times;</button>
                </div>
                <div class="flex items-center space-x-2">
                    <textarea id="main-comment-input" class="w-full p-2 border rounded-lg focus:ring-blue-500 focus:border-blue-500 flex-grow" rows="1" placeholder="Написать комментарий..."></textarea>
                    <button id="main-comment-send-btn" onclick="postComment()" class="flex-shrink-0 text-white rounded-full p-2 hover:opacity-80 disabled:opacity-50" style="background-color: var(--button-color);">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 transform rotate-45" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" /></svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // --- КОНФИГУРАЦИЯ И КОНСТАНТЫ ---
        const SUPABASE_URL = 'https://jsnahjtoqwuwbjdmisuj.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpzbmFoanRvcXd1d2JqZG1pc3VqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMzOTQxMDQsImV4cCI6MjA2ODk3MDEwNH0.M3TWsNJppj1f-Cmj6nGCAUswy1HZgBLW8yJZfTwkrpI';
        const MAPBOX_ACCESS_TOKEN = 'pk.eyJ1IjoieXVuZ3JlemFjIiwiYSI6ImNtOW10ZzJ6bDBjNHUyanI3ejc5eXo1d2MifQ._tryk9cXjfReUGLGnNkm6Q';
        const MAP_TILE_URL = 'https://api.mapbox.com/styles/v1/mapbox/streets-v12/tiles/512/{z}/{x}/{y}?access_token={accessToken}';

        // --- ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ И СОСТОЯНИЕ ---
        const tg = window.Telegram.WebApp;
        let map;
        let supabase;
        let telegramUser = null;
        
        // Состояние режимов
        let currentMode = 'capture'; // 'capture', 'spots', 'routes'
        let isRunning = false; // Для режимов 'capture' и 'routes'
        let geoWatchInterval = null; // ID интервала для отслеживания геолокации
        let lastKnownLocation = null;
        
        // Данные режимов
        let currentRunPath = [];
        let currentPathPolyline = null;
        let userTerritory = null;
        let userColor = '#3b82f6';
        let currentUserMarker = null;
        
        let allUserLayers = {};
        let allSpots = [];
        let allRoutes = [];
        let territoriesLayerGroup = L.layerGroup();
        let spotMarkersLayer = L.layerGroup();
        let routePolylinesLayer = L.layerGroup();

        let allProfilesData = [];
        let lastCaptureData = null; // Для постов
        let currentEditContext = {}; // Для модалки создания/редактирования
        let currentDetailContext = {}; // Для модалки деталей
        let currentReplyTarget = { type: null, id: null, parentCommentId: null };
        
        // --- ЭЛЕМЕНТЫ DOM ---
        const initialLoader = document.getElementById('initial-loader');
        const loaderText = document.getElementById('loader-text');
        const fallbackScreen = document.getElementById('fallback-screen');
        const fallbackContent = document.getElementById('fallback-content');
        const appContainer = document.getElementById('app-container');
        const bottomNavbar = document.getElementById('bottom-navbar');
        const mainActionBtn = document.getElementById('main-action-btn');
        const modeSwitcher = document.getElementById('mode-switcher');
        
        // Модальные окна
        const editModal = document.getElementById('edit-modal');
        const detailModal = document.getElementById('detail-modal');
        const commentsModal = document.getElementById('comments-modal');
        const simplePostModal = document.getElementById('simple-post-modal');
        const creationModal = document.getElementById('creation-modal');

        const leaderboardDiv = document.getElementById('leaderboard');
        const feedContainer = document.getElementById('feed-container');
        const profileName = document.getElementById('profile-name');
        const profileAreaDisplay = document.getElementById('profile-area');
        const profileAvatarImg = document.getElementById('profile-avatar-img');
        const profileAvatarWrapper = document.getElementById('profile-avatar-wrapper');
        const recenterBtn = document.getElementById('recenter-btn');
        const scanQrBtn = document.getElementById('scan-qr-btn');
        const inviteFriendBtn = document.getElementById('invite-friend-btn');
        const donateBtn = document.getElementById('donate-btn');
        const showQrBtn = document.getElementById('show-qr-btn');
        const createSimplePostBtn = document.getElementById('create-simple-post-btn');

        // --- ФУНКЦИИ UI ---
        function showView(viewId) {
            tg.HapticFeedback.selectionChanged();
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(viewId).classList.add('active');
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`button[onclick="showView('${viewId}')"]`).classList.add('active');
            
            const isMapView = viewId === 'map-view';
            mainActionBtn.classList.toggle('hidden', !isMapView);
            modeSwitcher.classList.toggle('hidden', !isMapView);
            
            if (isMapView) {
                setTimeout(() => map?.invalidateSize(), 100);
            }
        }

        function setMode(newMode) {
            if (currentMode === newMode) return;
            
            if (isRunning) {
                tg.showAlert("Сначала завершите текущую активность (захват или запись маршрута).");
                return;
            }

            tg.HapticFeedback.selectionChanged();
            currentMode = newMode;

            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.id === `mode-${newMode}`);
            });

            map.off('click');
            
            if (map.hasLayer(territoriesLayerGroup)) map.removeLayer(territoriesLayerGroup);
            if (map.hasLayer(spotMarkersLayer)) map.removeLayer(spotMarkersLayer);
            if (map.hasLayer(routePolylinesLayer)) map.removeLayer(routePolylinesLayer);

            switch (newMode) {
                case 'capture':
                    map.addLayer(territoriesLayerGroup);
                    break;
                case 'spots':
                    map.addLayer(spotMarkersLayer);
                    map.on('click', handleMapClickForSpot);
                    break;
                case 'routes':
                    map.addLayer(routePolylinesLayer);
                    break;
            }
            updateMainActionButton();
        }

        function updateMainActionButton() {
            mainActionBtn.onclick = null;
            let content = '';
            mainActionBtn.classList.remove('running');


            switch (currentMode) {
                case 'capture':
                    if (isRunning) {
                        content = `<svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z" clip-rule="evenodd" /></svg>`;
                        mainActionBtn.classList.add('running');
                        mainActionBtn.onclick = stopRun;
                    } else {
                        content = `<svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" /></svg>`;
                        mainActionBtn.onclick = startRun;
                    }
                    mainActionBtn.innerHTML = content;
                    mainActionBtn.classList.remove('w-auto', 'px-8');
                    mainActionBtn.classList.add('w-20');
                    break;
                case 'spots':
                    mainActionBtn.innerHTML = `<span>Добавить спот здесь</span>`;
                    mainActionBtn.onclick = () => {
                         if(lastKnownLocation) {
                             handleMapClickForSpot({latlng: L.latLng(lastKnownLocation)});
                         } else {
                             tg.showAlert("Определяем ваше местоположение...");
                         }
                    };
                    mainActionBtn.classList.add('w-auto', 'px-8');
                    mainActionBtn.classList.remove('w-20');
                    break;
                case 'routes':
                     if (isRunning) {
                        content = `<span>Завершить и сохранить</span>`;
                        mainActionBtn.classList.add('running');
                        mainActionBtn.onclick = stopRouteRecording;
                    } else {
                        content = `<span>Начать запись маршрута</span>`;
                        mainActionBtn.onclick = startRouteRecording;
                    }
                    mainActionBtn.innerHTML = content;
                    mainActionBtn.classList.add('w-auto', 'px-8');
                    mainActionBtn.classList.remove('w-20');
                    break;
            }
        }
        
        function generateColorFromId(id) {
            const strId = String(id);
            let hash = 0;
            for (let i = 0; i < strId.length; i++) {
                hash = strId.charCodeAt(i) + ((hash << 5) - hash);
            }
            const h = hash % 360;
            return `hsl(${h}, 80%, 65%)`;
        }

        // --- ЛОГИКА МОДАЛЬНЫХ ОКОН ---
        
        function showEditModal(type, context = {}) {
            currentEditContext = { type, ...context };
            const title = document.getElementById('edit-modal-title');
            const description = document.getElementById('edit-modal-description');
            const nameInput = document.getElementById('edit-modal-name');
            const detailsInput = document.getElementById('edit-modal-details');
            const detailsSection = document.getElementById('edit-modal-details-section');
            const photoSection = document.getElementById('edit-modal-photo-section');
            
            nameInput.value = '';
            detailsInput.value = '';
            document.getElementById('edit-modal-photo-input').value = '';
            document.getElementById('edit-modal-photo-preview').classList.add('hidden');
            document.getElementById('edit-modal-photo-icon').classList.remove('hidden');

            if (type === 'post') {
                 title.textContent = 'Новое достижение!';
                 description.textContent = 'Дайте название вашей новой территории.';
                 detailsSection.style.display = 'none';
                 photoSection.style.display = 'block';
            }
            
            editModal.classList.add('visible');
        }

        function hideEditModal() {
            editModal.classList.remove('visible');
            currentEditContext = {};
        }
        
        function showSimplePostModal() {
            document.getElementById('simple-post-details').value = '';
            document.getElementById('simple-post-photo-input').value = '';
            document.getElementById('simple-post-filename').textContent = '';
            simplePostModal.classList.add('visible');
        }

        function hideSimplePostModal() {
            simplePostModal.classList.remove('visible');
        }
        
        function showCreationModal(type, context = {}) {
            currentEditContext = { type, ...context };
            const title = document.getElementById('creation-modal-title');
            const description = document.getElementById('creation-modal-description');
            const nameInput = document.getElementById('creation-modal-name');
            const detailsInput = document.getElementById('creation-modal-details');
            
            nameInput.value = '';
            detailsInput.value = '';
            document.getElementById('creation-modal-photo-input').value = '';
            document.getElementById('creation-modal-photo-preview').classList.add('hidden');
            document.getElementById('creation-modal-photo-icon').classList.remove('hidden');

            if (type === 'spot') {
                title.textContent = 'Создать новый спот';
                description.textContent = 'Отметьте интересное место на карте для других.';
            } else if (type === 'route') {
                title.textContent = 'Сохранить новый маршрут';
                description.textContent = 'Дайте название и описание вашему маршруту.';
            }
            
            creationModal.classList.add('visible');
        }

        function hideCreationModal() {
            creationModal.classList.remove('visible');
            currentEditContext = {};
        }

        function handleSave() {
            const { type } = currentEditContext;
            if (type === 'spot') saveSpot();
            else if (type === 'route') saveRoute();
            else if (type === 'post') handlePostSubmission();
        }
        
        function showDetailModal(type, id) {
             currentDetailContext = { type, id };
             tg.HapticFeedback.impactOccurred('medium');
             tg.BackButton.show();
             
             detailModal.classList.add('visible');
             loadDetailContent();
        }
        
        function hideDetailModal() {
            tg.BackButton.hide();
            detailModal.classList.remove('visible');
            currentDetailContext = {};
        }

        async function loadDetailContent() {
            const { type, id } = currentDetailContext;
            const body = document.getElementById('detail-modal-body');
            
            body.innerHTML = `<div class="text-center p-8"><svg class="animate-spin mx-auto h-8 w-8 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></div>`;

            const commentsHtml = `
                <div id="detail-comments-section" class="mt-4">
                    <h3 class="text-xl font-bold px-4">Комментарии</h3>
                    <div id="detail-comments-list" class="p-4 space-y-4">
                          <p class="text-center text-gray-500">Загрузка комментариев...</p>
                    </div>
                </div>
                <div id="detail-comment-input-form" class="flex-shrink-0 p-2 border-t" style="background-color: var(--secondary-bg-color); border-color: var(--bg-color);">
                     <div id="detail-reply-indicator" class="hidden text-xs px-2 pb-1 flex justify-between items-center" style="color: var(--hint-color);">
                         <span id="detail-reply-indicator-text"></span>
                         <button onclick="cancelDetailReply()" class="font-bold text-xl">&times;</button>
                     </div>
                    <div class="flex items-center space-x-2">
                        <textarea id="detail-comment-input" class="w-full p-2 border rounded-lg focus:ring-blue-500 focus:border-blue-500 flex-grow" rows="1" placeholder="Написать комментарий..."></textarea>
                        <button onclick="postDetailComment()" class="flex-shrink-0 text-white rounded-full p-2 hover:opacity-80 disabled:opacity-50" style="background-color: var(--button-color);">
                           <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 transform rotate-45" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" /></svg>
                        </button>
                    </div>
                </div>
            `;

            if (type === 'spot') {
                const { data: spot, error } = await supabase.from('spots').select('*, profiles(id, name, photo_url), location_wkt:location::text').eq('id', id).single();
                if (error || !spot) {
                    body.innerHTML = `<p class="text-red-500 text-center p-4">Не удалось загрузить детали спота.</p>`;
                    return;
                }
                const author = spot.profiles || { name: 'Аноним', photo_url: null };
                const avatar = author.photo_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${author.name.charAt(0)}`;
                body.innerHTML = `
                    <div class="space-y-4 pb-4">
                        ${spot.photo_url ? `<img src="${spot.photo_url}" class="w-full h-64 object-cover" alt="Spot photo">` : ''}
                        <div class="px-4">
                            <h2 class="text-3xl font-bold">${spot.name}</h2>
                            <div class="flex items-center space-x-3 mt-2 cursor-pointer" onclick="showDetailModal('user', ${spot.user_id})">
                                <img src="${avatar}" class="w-8 h-8 rounded-full" alt="author avatar">
                                <span class="font-semibold text-sm">Автор: ${author.name}</span>
                            </div>
                            <p class="mt-4" style="color: var(--text-color);">${spot.description}</p>
                        </div>
                    </div>
                    ${commentsHtml}
                `;
                loadAndRenderComments(type, id, 'detail-comments-list');
            } else if (type === 'route') {
                const { data: route, error } = await supabase.from('routes').select('*, profiles(id, name, photo_url), path_wkt:path::text').eq('id', id).single();
                if (error || !route) {
                    body.innerHTML = `<p class="text-red-500 text-center p-4">Не удалось загрузить детали маршрута.</p>`;
                    return;
                }
                const author = route.profiles || { name: 'Аноним', photo_url: null };
                const avatar = author.photo_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${author.name.charAt(0)}`;
                body.innerHTML = `
                    <div class="space-y-4 pb-4">
                        <div id="detail-mini-map" class="h-64 w-full bg-gray-200"></div>
                        <div class="px-4">
                            <h2 class="text-3xl font-bold">${route.name}</h2>
                            <div class="flex items-center space-x-3 mt-2 cursor-pointer" onclick="showDetailModal('user', ${route.user_id})">
                                <img src="${avatar}" class="w-8 h-8 rounded-full" alt="author avatar">
                                <span class="font-semibold text-sm">Автор: ${author.name}</span>
                            </div>
                            ${route.description ? `<p class="mt-4" style="color: var(--text-color);">${route.description}</p>` : ''}
                        </div>
                    </div>
                     ${commentsHtml}
                `;
                setTimeout(() => {
                    const mapContainer = document.getElementById('detail-mini-map');
                    const routeGeoJson = parseWKT(route.path_wkt);
                    if (mapContainer && !mapContainer._leaflet_id && routeGeoJson) {
                        const miniMap = L.map(mapContainer, { zoomControl: false, attributionControl: false, dragging: false, scrollWheelZoom: false, doubleClickZoom: false });
                        L.tileLayer(MAP_TILE_URL, { maxZoom: 19, accessToken: MAPBOX_ACCESS_TOKEN, tileSize: 512, zoomOffset: -1 }).addTo(miniMap);
                        const routeLayer = L.geoJSON(routeGeoJson, { style: { color: '#ff7800', weight: 3 } }).addTo(miniMap);
                        miniMap.fitBounds(routeLayer.getBounds(), { padding: [10, 10] });
                    }
                }, 100);
                 loadAndRenderComments(type, id, 'detail-comments-list');
            } else if (type === 'user') {
                const [profileRes, postsRes, spotsRes, routesRes] = await Promise.all([
                    supabase.from('profiles').select('*').eq('id', id).single(),
                    supabase.from('posts').select('*').eq('user_id', id).order('created_at', { ascending: false }),
                    supabase.from('spots').select('*, location_wkt:location::text').eq('user_id', id).order('created_at', { ascending: false }),
                    supabase.from('routes').select('*, path_wkt:path::text').eq('user_id', id).order('created_at', { ascending: false })
                ]);

                if (profileRes.error) {
                    body.innerHTML = `<p class="text-red-500 text-center">Не удалось загрузить профиль.</p>`;
                    return;
                }
                const profile = profileRes.data;
                const posts = postsRes.data || [];
                const spots = spotsRes.data || [];
                const routes = routesRes.data || [];

                const postIds = posts.map(p => p.id);
                const likesByPost = {};
                const commentsByPost = {};
                if (postIds.length > 0) {
                    const { data: likes } = await supabase.from('likes').select('*').in('post_id', postIds);
                    const { data: comments } = await supabase.from('comments').select('id, post_id').in('post_id', postIds);
                    if(likes) likes.forEach(like => (likesByPost[like.post_id] = likesByPost[like.post_id] || []).push(like));
                    if(comments) comments.forEach(comment => (commentsByPost[comment.post_id] = commentsByPost[comment.post_id] || []).push(comment));
                }

                const avatar = profile.photo_url || `https://placehold.co/80x80/E5E7EB/4B5563?text=${profile.name.charAt(0)}`;
                const area = profile.area || 0;
                const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;

                body.innerHTML = `
                    <div class="p-4">
                        <div class="flex items-center space-x-4">
                            <img src="${avatar}" class="w-20 h-20 rounded-full" alt="avatar">
                            <div>
                                <h2 class="text-2xl font-bold">${profile.name}</h2>
                                <p class="text-sm" style="color: var(--hint-color);">Общая площадь</p>
                                <p class="text-xl font-bold" style="color: var(--button-color);">${formattedArea}</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex border-b mt-4 px-4">
                        <div id="tab-posts" class="profile-tab active" onclick="switchProfileTab('posts')">Посты (${posts.length})</div>
                        <div id="tab-spots" class="profile-tab" onclick="switchProfileTab('spots')">Споты (${spots.length})</div>
                        <div id="tab-routes" class="profile-tab" onclick="switchProfileTab('routes')">Маршруты (${routes.length})</div>
                    </div>

                    <div id="content-posts" class="profile-tab-content active p-4 space-y-4">
                        ${posts.length > 0 ? posts.map(p => generatePostHTML(p, likesByPost[p.id] || [], commentsByPost[p.id] || [])).join('') : '<p class="text-center text-gray-500 py-4">У пользователя нет постов.</p>'}
                    </div>
                    <div id="content-spots" class="profile-tab-content p-4 space-y-4">
                        ${spots.length > 0 ? spots.map(generateMiniSpotHTML).join('') : '<p class="text-center text-gray-500 py-4">У пользователя нет спотов.</p>'}
                    </div>
                    <div id="content-routes" class="profile-tab-content p-4 space-y-4">
                         ${routes.length > 0 ? routes.map(generateMiniRouteHTML).join('') : '<p class="text-center text-gray-500 py-4">У пользователя нет маршрутов.</p>'}
                    </div>
                `;

                setTimeout(() => {
                    posts.forEach(post => {
                        if (post.territory_captured) {
                            const mapContainer = body.querySelector(`#mini-map-${post.id}`);
                            if (mapContainer && !mapContainer._leaflet_id) {
                                const miniMap = L.map(mapContainer, { zoomControl: false, attributionControl: false, dragging: false, scrollWheelZoom: false, doubleClickZoom: false });
                                L.tileLayer(MAP_TILE_URL, { maxZoom: 19, accessToken: MAPBOX_ACCESS_TOKEN, tileSize: 512, zoomOffset: -1 }).addTo(miniMap);
                                const territoryLayer = L.geoJSON(post.territory_captured, { style: { color: post.user_color, weight: 2, opacity: 0.8, fillColor: post.user_color, fillOpacity: 0.5 } }).addTo(miniMap);
                                miniMap.fitBounds(territoryLayer.getBounds(), { padding: [10, 10] });
                            }
                        }
                    });
                }, 100);
            }
        }
        
        function switchProfileTab(tabName) {
            document.querySelectorAll('#detail-modal .profile-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('#detail-modal .profile-tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`tab-${tabName}`).classList.add('active');
            document.getElementById(`content-${tabName}`).classList.add('active');
        }

        function generateMiniPostHTML(post) {
            return `<div class="card-bg rounded-lg p-3 shadow-sm cursor-pointer hover:bg-gray-100" data-action="show-post-comments" data-id="${post.id}">
                        <p class="font-semibold">${post.title}</p>
                        <p class="text-xs text-gray-400">${new Date(post.created_at).toLocaleDateString()}</p>
                    </div>`;
        }
        function generateMiniSpotHTML(spot) {
             return `<div class="card-bg rounded-lg p-3 shadow-sm cursor-pointer hover:bg-gray-100" onclick="navigateToMapObject('spot', ${spot.id})">
                          <p class="font-semibold">${spot.name}</p>
                          <p class="text-sm text-gray-600 truncate">${spot.description}</p>
                          <p class="text-xs text-gray-400">${new Date(spot.created_at).toLocaleDateString()}</p>
                     </div>`;
        }
        function generateMiniRouteHTML(route) {
             return `<div class="card-bg rounded-lg p-3 shadow-sm cursor-pointer hover:bg-gray-100" onclick="navigateToMapObject('route', ${route.id})">
                          <p class="font-semibold">${route.name}</p>
                          <p class="text-xs text-gray-400">${new Date(route.created_at).toLocaleDateString()}</p>
                     </div>`;
        }

        function navigateToMapObject(type, id) {
            hideDetailModal(); 
            showView('map-view');
            setMode(type === 'spot' ? 'spots' : 'routes'); 

            let target;
            if (type === 'spot') {
                target = allSpots.find(s => s.id === id);
                const geoJson = parseWKT(target?.location_wkt);
                if (geoJson) {
                    const coords = geoJson.coordinates;
                    map.flyTo([coords[1], coords[0]], 17);
                }
            } else if (type === 'route') {
                target = allRoutes.find(r => r.id === id);
                const geoJson = parseWKT(target?.path_wkt);
                if (geoJson) {
                    const coords = geoJson.coordinates.map(p => [p[1], p[0]]);
                    if (coords.length >= 2) {
                        const polyline = L.polyline(coords);
                        map.flyToBounds(polyline.getBounds(), { padding: [50, 50] });
                    }
                }
            }
        }

        /**
         * [FIXED] Более надежная функция для парсинга WKT-строк в GeoJSON.
         * Использует регулярные выражения для извлечения координат, что делает ее
         * устойчивой к префиксам (например, SRID) и вариациям в форматировании.
         * @param {string | null} wkt - Строка в формате Well-Known Text (например, 'POINT(30 10)').
         * @returns {object | null} GeoJSON-объект или null в случае ошибки.
         */
        function parseWKT(wkt) {
            if (!wkt || typeof wkt !== 'string') {
                return null;
            }
            
            try {
                const match = wkt.match(/(POINT|LINESTRING)\s*\((.+)\)/i);
                if (!match) {
                    return null;
                }

                const type = match[1].toUpperCase();
                let content = match[2];

                if (type === 'POINT') {
                    const coords = content.match(/-?\d+(\.\d+)?/g);
                    if (!coords || coords.length < 2) return null;
                    return { type: 'Point', coordinates: [parseFloat(coords[0]), parseFloat(coords[1])] };
                }

                if (type === 'LINESTRING') {
                    const coordPairs = content.split(',');
                    const coordinates = coordPairs.map(pair => {
                        const nums = pair.trim().match(/-?\d+(\.\d+)?/g);
                        if (!nums || nums.length < 2) return null;
                        return [parseFloat(nums[0]), parseFloat(nums[1])];
                    }).filter(p => p !== null);

                    if (coordinates.length < 2) return null;
                    return { type: 'LineString', coordinates: coordinates };
                }

            } catch (e) {
                console.error("Failed to parse WKT:", wkt, e);
                return null;
            }
            return null;
        }

        // --- ОСНОВНАЯ ЛОГИКА И ИНИЦИАЛИЗАЦИЯ ---
        async function main() {
            try {
                tg.ready();
                tg.expand();
                applyTheme(tg.themeParams);
                setupStaticEventListeners();

                if (!tg.initDataUnsafe?.user) {
                    showFallbackScreen({ 
                        title: 'Требуется Telegram', 
                        message: 'Это приложение предназначено для работы исключительно внутри Telegram.' 
                    });
                    return;
                }
                telegramUser = tg.initDataUnsafe.user;

                // Получаем геолокацию через Telegram API
                const initialPosition = await requestInitialGeo();
                const initialCoords = initialPosition.coords;
                
                loaderText.textContent = 'Подключение к базе данных...';
                
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                
                loaderText.textContent = 'Загрузка данных...';
                initMap(initialCoords); // Используем полученные координаты
                await upsertUserProfile();
                updateUI();
                
                await Promise.all([
                    fetchAllProfilesAndDraw(),
                    renderFeed(),
                    loadInitialMapData(),
                    renderMyProfileContent()
                ]);

                listenToRealtimeChanges();
                setupDynamicEventListeners();

                initialLoader.classList.add('hidden');
                appContainer.classList.remove('hidden');
                bottomNavbar.classList.remove('hidden');
                
                setMode('capture');

            } catch (error) {
                console.error("Критическая ошибка инициализации:", error);
                let fallbackOptions = {
                    title: "Ошибка инициализации",
                    message: "Не удалось запустить приложение. Пожалуйста, попробуйте перезагрузить его.",
                    button: { text: 'Попробовать снова', action: 'window.location.reload()' }
                };
                
                if (error.message === 'GEOLOCATION_DENIED') {
                     fallbackOptions = {
                        title: "Доступ к геолокации необходим",
                        message: "Для работы TerraRun требуется доступ к вашему местоположению. Нажмите кнопку ниже, чтобы предоставить разрешение.",
                        button: { text: 'Разрешить доступ', action: 'requestPermissionAndReload()' }
                     };
                } else if (error.message.includes("is not a function")) {
                    fallbackOptions.title = "Ошибка API Telegram";
                    fallbackOptions.message = "Функция геолокации недоступна. Убедитесь, что вы используете последнюю версию Telegram и ваш бот настроен правильно.";
                }
                else if (error.message) {
                    fallbackOptions.message = error.message;
                }
                showFallbackScreen(fallbackOptions);
            }
        }

        function initMap(coords) {
            if (map) return;
            const latLng = [coords.latitude, coords.longitude];
            map = L.map('map', { zoomControl: false, attributionControl: false }).setView(latLng, 16);
            
            L.tileLayer(MAP_TILE_URL, {
                maxZoom: 19,
                tileSize: 512,
                zoomOffset: -1,
                accessToken: MAPBOX_ACCESS_TOKEN
            }).addTo(map);
            
            updateCurrentUserMarker(latLng);
            setTimeout(() => map?.invalidateSize(), 100);
        }

        function updateUI() {
            const name = telegramUser.first_name.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            profileName.textContent = name;
            
            if (telegramUser.photo_url) {
                profileAvatarImg.src = telegramUser.photo_url;
            } else {
                const initial = name.charAt(0).toUpperCase();
                profileAvatarImg.src = `https://placehold.co/96x96/E2E8F0/4A5568?text=${initial}`;
            }
            profileAvatarWrapper.style.borderColor = userColor;
            updateMainActionButton();
            refreshAllStats();
            renderMyProfileContent();
        }
        
        function updateCurrentUserMarker(latLng) {
            if (!map) return;
            const userAvatarUrl = telegramUser.photo_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${telegramUser.first_name.charAt(0)}`;
            const icon = L.divIcon({
                html: `<div class="avatar-marker current-user-marker" style="background-image: url(${userAvatarUrl}); width: 40px; height: 40px; border-color: ${userColor};"></div>`,
                className: '',
                iconSize: [40, 40],
                iconAnchor: [20, 20]
            });
            
            if (currentUserMarker) {
                currentUserMarker.setLatLng(latLng);
            } else {
                currentUserMarker = L.marker(latLng, { icon: icon, zIndexOffset: 1000 }).addTo(map);
            }
        }

        // --- ЛОГИКА РЕЖИМОВ ---
        
        function startRun() {
            if (!lastKnownLocation) {
                tg.showAlert("Не удалось определить ваше местоположение. Попробуйте нажать кнопку 'Найти меня'."); return;
            }
            isRunning = true;
            tg.HapticFeedback.impactOccurred('heavy');
            tg.isClosingConfirmationEnabled = true;
            updateMainActionButton();
            
            currentRunPath = [ [lastKnownLocation[1], lastKnownLocation[0]] ];
            if (currentPathPolyline) map.removeLayer(currentPathPolyline);
            currentPathPolyline = L.polyline([], { color: 'var(--destructive-color)', weight: 5, opacity: 0.9 }).addTo(map);
            currentPathPolyline.addLatLng(lastKnownLocation);

            // Запускаем интервал для отслеживания геолокации
            if (geoWatchInterval) clearInterval(geoWatchInterval);
            geoWatchInterval = setInterval(trackUserPosition, 5000); // Запрашиваем позицию каждые 5 секунд
        }

        function stopRun() {
             tg.showConfirm("Завершить пробежку и захватить территорию?", (ok) => {
                   if (ok) processStop();
             });
        }
        function processStop() {
            isRunning = false;
            // Останавливаем интервал отслеживания
            if (geoWatchInterval) {
                clearInterval(geoWatchInterval);
                geoWatchInterval = null;
            }

            tg.HapticFeedback.notificationOccurred('success');
            tg.isClosingConfirmationEnabled = false;
            updateMainActionButton();
            if (currentRunPath.length > 3) {
                processRunPath();
            } else {
                tg.showAlert('Слишком короткий маршрут для захвата.');
            }
            if (currentPathPolyline) setTimeout(() => { if(currentPathPolyline) map.removeLayer(currentPathPolyline); currentPathPolyline = null; }, 2000);
        }
        
        function handleMapClickForSpot(e) {
            const { lat, lng } = e.latlng;
            const locationWKT = `POINT(${lng} ${lat})`;
            tg.showConfirm("Создать новый спот в этом месте?", (ok) => {
                if (ok) {
                    showCreationModal('spot', { location: locationWKT });
                }
            });
        }

        // ** RPC вызовы теперь безопаснее **
        async function saveSpot() {
            const { location } = currentEditContext;
            const name = document.getElementById('creation-modal-name').value.trim();
            const description = document.getElementById('creation-modal-details').value.trim();
            const file = document.getElementById('creation-modal-photo-input').files[0];

            if (!name || !description) {
                tg.showAlert("Название и описание обязательны."); return;
            }
            
            let photoUrl = null;
            if (file) {
                const filePath = `${telegramUser.id}/spots/${Date.now()}_${file.name}`;
                const { data, error } = await supabase.storage.from('photo').upload(filePath, file);
                if (error) { console.error("Ошибка загрузки фото:", error); tg.showAlert("Ошибка загрузки фото."); return; }
                const { data: urlData } = supabase.storage.from('photo').getPublicUrl(data.path);
                photoUrl = urlData.publicUrl;
            }
            
            // ID пользователя больше не передается, он берется из сессии на сервере
            const { error } = await supabase.rpc('create_spot', {
                name_in: name,
                description_in: description,
                photo_url_in: photoUrl,
                location_wkt_in: location
            });

            if (error) {
                console.error("Ошибка сохранения спота:", error); tg.showAlert("Не удалось сохранить спот.");
            } else {
                tg.showAlert("Спот успешно создан!");
                hideCreationModal();
            }
        }
        
        /**
         * [FIXED] Более безопасная функция добавления спота на карту.
         * Проверяет результат парсинга перед созданием слоя.
         * @param {object} spot - Объект спота из базы данных.
         */
        function addSpotToMap(spot) {
            try {
                const wkt = spot.location_wkt || spot.location;
                const geoJsonPoint = parseWKT(wkt);

                if (!geoJsonPoint || geoJsonPoint.type !== 'Point') {
                    console.warn(`Не удалось обработать геолокацию спота ${spot.id}:`, wkt);
                    return;
                }

                const spotLayer = L.geoJSON(geoJsonPoint, {
                    pointToLayer: (feature, latlng) => L.marker(latlng)
                }).on('click', () => showDetailModal('spot', spot.id));
                
                spotMarkersLayer.addLayer(spotLayer);
            } catch (e) {
                console.error(`Ошибка при добавлении спота ${spot.id} на карту.`, e, spot);
            }
        }

        function startRouteRecording() {
            if (!lastKnownLocation) {
                tg.showAlert("Сначала определите свое местоположение."); return;
            }
            isRunning = true;
            tg.HapticFeedback.impactOccurred('heavy');
            tg.isClosingConfirmationEnabled = true;
            updateMainActionButton();
            
            currentRunPath = [ [lastKnownLocation[0], lastKnownLocation[1]] ];
            if (currentPathPolyline) map.removeLayer(currentPathPolyline);
            currentPathPolyline = L.polyline([], { color: 'var(--button-color)', weight: 5, opacity: 0.9 }).addTo(map);
            currentPathPolyline.addLatLng(lastKnownLocation);

            // Запускаем интервал для отслеживания геолокации
            if (geoWatchInterval) clearInterval(geoWatchInterval);
            geoWatchInterval = setInterval(trackUserPosition, 5000);
        }

        function stopRouteRecording() {
            isRunning = false;
             // Останавливаем интервал отслеживания
            if (geoWatchInterval) {
                clearInterval(geoWatchInterval);
                geoWatchInterval = null;
            }

            tg.HapticFeedback.notificationOccurred('success');
            tg.isClosingConfirmationEnabled = false;
            updateMainActionButton();
            
            if (currentRunPath.length < 2) {
                tg.showAlert("Слишком короткий маршрут.");
                if (currentPathPolyline) map.removeLayer(currentPathPolyline);
                currentPathPolyline = null;
                return;
            }
            
            const pathCoordinates = currentRunPath.map(p => `${p[1]} ${p[0]}`).join(', ');
            const pathWKT = `LINESTRING(${pathCoordinates})`;
            showCreationModal('route', { path: pathWKT });

            if (currentPathPolyline) setTimeout(() => { if(currentPathPolyline) map.removeLayer(currentPathPolyline); currentPathPolyline = null; }, 2000);
        }

        // ** RPC вызовы теперь безопаснее **
        async function saveRoute() {
            const { path } = currentEditContext;
            const name = document.getElementById('creation-modal-name').value.trim();
            const description = document.getElementById('creation-modal-details').value.trim();
            
            if (!name) { tg.showAlert("Название обязательно."); return; }

            // ID пользователя больше не передается, он берется из сессии на сервере
            const { error } = await supabase.rpc('create_route', {
                name_in: name,
                description_in: description,
                path_wkt_in: path
            });

            if (error) {
                console.error("Ошибка сохранения маршрута:", error); tg.showAlert("Не удалось сохранить маршрут.");
            } else {
                tg.showAlert("Маршрут сохранен!");
                hideCreationModal();
            }
        }
        
        /**
         * [FIXED] Более безопасная функция добавления маршрута на карту.
         * Проверяет результат парсинга перед созданием слоя.
         * @param {object} route - Объект маршрута из базы данных.
         */
        function addRouteToMap(route) {
            try {
                const wkt = route.path_wkt || route.path;
                const geoJsonLine = parseWKT(wkt);

                if (!geoJsonLine || geoJsonLine.type !== 'LineString' || !Array.isArray(geoJsonLine.coordinates) || geoJsonLine.coordinates.length < 2) {
                    console.warn(`Не удалось обработать путь для маршрута ${route.id}:`, wkt);
                    return;
                }

                const routeLayer = L.geoJSON(geoJsonLine, {
                    style: { color: '#ff7800', weight: 3 }
                }).on('click', () => showDetailModal('route', route.id));
                routePolylinesLayer.addLayer(routeLayer);
            } catch (e) {
                console.error(`Ошибка при добавлении маршрута ${route.id} на карту.`, e, route);
            }
        }

        // --- ЗАГРУЗКА ДАННЫХ ---
        async function loadInitialMapData() {
            const { data: spots, error: spotsError } = await supabase.from('spots').select('*, location_wkt:location::text');
            if (spotsError) {
                console.error("Ошибка загрузки спотов:", spotsError);
            } else {
                allSpots = spots;
                spotMarkersLayer.clearLayers();
                allSpots.forEach(addSpotToMap);
            }

            const { data: routes, error: routesError } = await supabase.from('routes').select('*, path_wkt:path::text');
            if (routesError) {
                console.error("Ошибка загрузки маршрутов:", routesError);
            } else {
                allRoutes = routes;
                routePolylinesLayer.clearLayers();
                allRoutes.forEach(addRouteToMap);
            }
        }

        // --- SUPABASE и ОБРАБОТЧИКИ ---
        function listenToRealtimeChanges() {
            supabase.channel('public-changes')
              .on('postgres_changes', { event: '*', schema: 'public', table: 'profiles' }, fetchAllProfilesAndDraw)
              .on('postgres_changes', { event: '*', schema: 'public', table: 'posts' }, () => { renderFeed(); renderMyProfileContent(); })
              .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'likes' }, renderFeed)
              .on('postgres_changes', { event: 'DELETE', schema: 'public', table: 'likes' }, renderFeed)
              .on('postgres_changes', { event: '*', schema: 'public', table: 'comments' }, (payload) => {
                  if (commentsModal.classList.contains('visible') && currentReplyTarget.type === 'post') {
                      const changedPostId = payload.new?.post_id || payload.old?.post_id;
                      if (changedPostId && changedPostId === currentReplyTarget.id) {
                          showPostComments(currentReplyTarget.id);
                      }
                  }
                  if (detailModal.classList.contains('visible') && (currentDetailContext.type === 'spot' || currentDetailContext.type === 'route')) {
                      const changedParentId = payload.new?.spot_id || payload.new?.route_id || payload.old?.spot_id || payload.old?.route_id;
                      if (changedParentId === currentDetailContext.id) {
                          loadAndRenderComments(currentDetailContext.type, currentDetailContext.id, 'detail-comments-list');
                      }
                  }
                  renderFeed();
              })
              .on('postgres_changes', { event: '*', schema: 'public', table: 'spots' }, () => { loadInitialMapData(); renderMyProfileContent(); })
              .on('postgres_changes', { event: '*', schema: 'public', table: 'routes' }, () => { loadInitialMapData(); renderMyProfileContent(); })
              .subscribe();
        }

        function setupStaticEventListeners() {
            tg.onEvent('themeChanged', () => applyTheme(tg.themeParams));
            tg.onEvent('backButtonClicked', () => {
                if (commentsModal.classList.contains('visible')) {
                    hideCommentsModal();
                } else if (detailModal.classList.contains('visible')) {
                    hideDetailModal();
                } else if (creationModal.classList.contains('visible')) {
                    hideCreationModal();
                } else if (simplePostModal.classList.contains('visible')) {
                    hideSimplePostModal();
                }
            });
        }

        function setupDynamicEventListeners() {
            document.getElementById('mode-capture').addEventListener('click', () => setMode('capture'));
            document.getElementById('mode-spots').addEventListener('click', () => setMode('spots'));
            document.getElementById('mode-routes').addEventListener('click', () => setMode('routes'));
            
            document.getElementById('save-edit-btn').addEventListener('click', handleSave);
            document.getElementById('cancel-edit-btn').addEventListener('click', hideEditModal);
            
            document.getElementById('save-creation-btn').addEventListener('click', handleSave);
            document.getElementById('creation-modal-photo-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const preview = document.getElementById('creation-modal-photo-preview');
                    preview.src = URL.createObjectURL(file);
                    preview.classList.remove('hidden');
                    document.getElementById('creation-modal-photo-icon').classList.add('hidden');
                }
            });
            document.getElementById('simple-post-photo-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    document.getElementById('simple-post-filename').textContent = file.name;
                }
            });

            recenterBtn.addEventListener('click', () => {
                tg.HapticFeedback.impactOccurred('medium');
                if (lastKnownLocation) map.flyTo(lastKnownLocation, 16);
            });
            
            scanQrBtn.addEventListener('click', () => {
                tg.HapticFeedback.impactOccurred('light');
                tg.showScanQrPopup({ text: 'Наведите на QR-код другого игрока' });
            });

            inviteFriendBtn.addEventListener('click', () => {
                tg.HapticFeedback.impactOccurred('light');
                tg.openTelegramLink(`https://t.me/share/url?url=${encodeURIComponent(`https://t.me/TerraRunBot/app`)}&text=${encodeURIComponent(`Присоединяйся ко мне в TerraRun и давай захватывать территории вместе!`)}`);
            });
            
            createSimplePostBtn.addEventListener('click', showSimplePostModal);
            
            showQrBtn.addEventListener('click', () => { /* TODO: Implement */ });
            donateBtn.addEventListener('click', () => { /* TODO: Implement */ });

            document.body.addEventListener('click', (event) => {
                const button = event.target.closest('button[data-action], div[data-action]');
                if (!button) return;

                const action = button.dataset.action;
                const id = button.dataset.id || button.dataset.postId;

                if (!action || !id) return;

                if (action === 'like') {
                    toggleLike(button, id);
                } else if (action === 'comment' || action === 'show-post-comments') {
                    showPostComments(id);
                }
            });
        }
        
        function showFallbackScreen(options) {
            const { title, message, button } = options;
            fallbackContent.innerHTML = `
                <h1 class="text-2xl font-bold mb-4">${title}</h1>
                <p class="mb-6" style="color: var(--hint-color);">${message}</p>
                ${button ? `<button onclick="${button.action}" class="font-bold py-3 px-6 rounded-full" style="background-color: var(--button-color); color: var(--button-text-color);">${button.text}</button>` : ''}
            `;
            initialLoader.classList.add('hidden');
            fallbackScreen.classList.remove('hidden');
        }

        function applyTheme(themeParams) {
             document.documentElement.style.setProperty('--bg-color', themeParams.bg_color || '#f3f4f6');
             document.documentElement.style.setProperty('--secondary-bg-color', themeParams.secondary_bg_color || '#ffffff');
             document.documentElement.style.setProperty('--text-color', themeParams.text_color || '#1f2937');
             document.documentElement.style.setProperty('--hint-color', themeParams.hint_color || '#6b7280');
             document.documentElement.style.setProperty('--button-color', themeParams.button_color || '#3b82f6');
             document.documentElement.style.setProperty('--button-text-color', themeParams.button_text_color || '#ffffff');
             tg.setHeaderColor(themeParams.secondary_bg_color || '#ffffff');
             tg.setBackgroundColor(themeParams.bg_color || '#f3f4f6');
        }

        /**
         * Запрашивает геолокацию через Telegram API.
         * Эта функция вызывается для получения координат пользователя.
         * @returns {Promise<object>} Промис, который разрешается с объектом геолокации.
         */
        function telegramRequestLocation() {
            return new Promise((resolve, reject) => {
                // Проверяем, существует ли функция, перед вызовом
                if (typeof tg.requestGeoLocation !== 'function') {
                    return reject(new Error('tg.requestGeoLocation is not a function'));
                }

                tg.requestGeoLocation((location) => {
                    if (location) {
                        resolve({ coords: location });
                    } else {
                        // Пользователь отклонил запрос или произошла ошибка
                        reject(new Error('GEOLOCATION_DENIED'));
                    }
                });
            });
        }

        /**
         * Отслеживает позицию пользователя во время бега.
         */
        async function trackUserPosition() {
            try {
                const position = await telegramRequestLocation();
                const { latitude, longitude } = position.coords;
                lastKnownLocation = [latitude, longitude];
                updateCurrentUserMarker(lastKnownLocation);

                if (isRunning && currentPathPolyline) {
                    const newPoint = (currentMode === 'capture') 
                        ? [longitude, latitude] 
                        : [latitude, longitude];
                    currentRunPath.push(newPoint);
                    currentPathPolyline.addLatLng([latitude, longitude]);
                }
            } catch (error) {
                console.error("Ошибка отслеживания геолокации:", error);
                // Можно остановить бег, если пользователь отозвал разрешение
                if (isRunning) {
                    tg.showAlert("Потерян доступ к геолокации. Пробежка остановлена.");
                    processStop();
                }
            }
        }

        /**
         * Запрашивает геолокацию один раз при запуске приложения.
         * @returns {Promise<object>} Промис с начальной позицией.
         */
        async function requestInitialGeo() {
            loaderText.textContent = 'Запрос доступа к местоположению...';
            const initialPosition = await telegramRequestLocation();
            const { latitude, longitude } = initialPosition.coords;
            lastKnownLocation = [latitude, longitude];
            // Отслеживание (watch) будет запускаться только при старте пробежки/записи
            return initialPosition;
        }

        /**
         * Новая функция для повторного запроса разрешений и перезагрузки.
         */
        function requestPermissionAndReload() {
            tg.requestGeoLocation((location) => {
                if (location) {
                    // Пользователь дал разрешение, перезагружаем страницу
                    // чтобы пройти процесс инициализации заново.
                    window.location.reload();
                }
                // Если разрешение не дано, пользователь останется на том же экране.
            });
        }
        
        async function upsertUserProfile() {
            if (!telegramUser) throw new Error("Пользователь Telegram не определен для upsertUserProfile.");

            const { data, error } = await supabase.from('profiles').select('*').eq('id', telegramUser.id).single();
            
            if (error && error.code !== 'PGRST116') {
                console.error("Ошибка получения профиля:", error); 
                throw error; 
            } 
            
            if (data) {
                userColor = data.color;
                userTerritory = data.territory;
            } else {
                userColor = generateColorFromId(telegramUser.id);
                const { error: insertError } = await supabase.from('profiles').insert({ 
                    id: telegramUser.id, 
                    name: telegramUser.first_name, 
                    color: userColor, 
                    area: 0, 
                    photo_url: telegramUser.photo_url || null, 
                    territory: null 
                });
                if (insertError) { 
                    console.error("Ошибка создания профиля:", insertError); 
                    throw insertError; 
                }
            }
        }
        
        async function processRunPath() {
            const startPoint = currentRunPath[0];
            const endPoint = currentRunPath[currentRunPath.length - 1];
            const distance = turf.distance(turf.point(startPoint), turf.point(endPoint), { units: 'meters' });
            if (distance > 50) {
                tg.showAlert('Маршрут не замкнут. Вернитесь к точке старта (в радиус 50м) для захвата.');
                return;
            }
            currentRunPath.push(startPoint);
            const line = turf.lineString(currentRunPath);
            const polygonized = turf.polygonize(line);
            if (polygonized.features.length === 0) {
                tg.showAlert('Не удалось сформировать замкнутую территорию. Вероятно, маршрут пересекал сам себя.');
                return;
            }
            let newCapture = polygonized.features[0];
            if (polygonized.features.length > 1) {
                try {
                    newCapture = turf.union(...polygonized.features);
                } catch (e) {
                    console.error("Turf union error:", e);
                }
            }
            updateTerritory(newCapture);
        }

        async function updateTerritory(newCapture) {
            try {
                let combinedTerritory = userTerritory ? turf.union(userTerritory, newCapture) : newCapture;
                userTerritory = turf.cleanCoords(combinedTerritory);
                
                await saveUserData();
                refreshAllStats();
                tg.HapticFeedback.notificationOccurred('success');
                showEditModal('post', { captureData: newCapture });
            } catch (error) {
                console.error("Ошибка в updateTerritory:", error);
                tg.showAlert("Ошибка обработки территории.");
            }
        }

        async function saveUserData() {
            let area = userTerritory ? turf.area(userTerritory) : 0;
            const userData = { id: telegramUser.id, name: telegramUser.first_name, photo_url: telegramUser.photo_url || null, color: userColor, territory: userTerritory, area: area, updated_at: new Date().toISOString() };
            const { error } = await supabase.from('profiles').upsert(userData);
            if (error) console.error('Error saving user data:', error);
        }

        async function handlePostSubmission() {
            const { captureData } = currentEditContext;
            const title = document.getElementById('edit-modal-name').value.trim();
            
            if (!title) { tg.showAlert("Пожалуйста, введите название."); return; }

            let photoUrl = null;
            const file = document.getElementById('edit-modal-photo-input').files[0];
            if (file) {
                const filePath = `${telegramUser.id}/${Date.now()}_${file.name}`;
                const { data, error } = await supabase.storage.from('photo').upload(filePath, file);
                if (error) { console.error("Error uploading photo:", error); tg.showAlert("Не удалось загрузить фото."); return; }
                photoUrl = supabase.storage.from('photo').getPublicUrl(data.path).data.publicUrl;
            }

            const areaCaptured = turf.area(captureData);
            const postData = {
                user_id: telegramUser.id,
                title: title,
                description: null,
                photo_url: photoUrl,
                territory_captured: captureData,
                area_captured: areaCaptured,
                user_name: telegramUser.first_name,
                user_avatar_url: telegramUser.photo_url,
                user_color: userColor
            };

            const { error: postError } = await supabase.from('posts').insert(postData);
            
            if (postError) {
                console.error("Error saving post:", postError); tg.showAlert("Не удалось сохранить пост.");
            } else {
                tg.showAlert("Пост успешно опубликован!");
                hideEditModal();
                // --- НОВОЕ: Отправка данных боту ---
                try {
                    const dataToSend = {
                        type: 'new_post',
                        title: title,
                        area: areaCaptured
                    };
                    tg.sendData(JSON.stringify(dataToSend));
                    console.log('Данные о новом посте (с территорией) отправлены боту:', dataToSend);
                } catch (e) {
                    console.error('Не удалось отправить данные боту:', e);
                }
                // --- КОНЕЦ НОВОГО БЛОКА ---
            }
        }
        
        async function handleSimplePostSave() {
            const description = document.getElementById('simple-post-details').value.trim();
            if (!description) {
                tg.showAlert("Пожалуйста, введите текст поста.");
                return;
            }

            let photoUrl = null;
            const file = document.getElementById('simple-post-photo-input').files[0];
            if (file) {
                const filePath = `${telegramUser.id}/posts/${Date.now()}_${file.name}`;
                const { data, error } = await supabase.storage.from('photo').upload(filePath, file);
                if (error) { console.error("Error uploading photo:", error); tg.showAlert("Не удалось загрузить фото."); return; }
                photoUrl = supabase.storage.from('photo').getPublicUrl(data.path).data.publicUrl;
            }

            const postData = {
                user_id: telegramUser.id,
                title: description.substring(0, 50) + (description.length > 50 ? '...' : ''),
                description: description,
                photo_url: photoUrl,
                user_name: telegramUser.first_name,
                user_avatar_url: telegramUser.photo_url,
                user_color: userColor
            };

            const { error: postError } = await supabase.from('posts').insert(postData);
            
            if (postError) {
                console.error("Error saving post:", postError); tg.showAlert("Не удалось сохранить пост.");
            } else {
                tg.showAlert("Пост успешно опубликован!");
                hideSimplePostModal();
                // --- НОВОЕ: Отправка данных боту ---
                try {
                    const dataToSend = {
                        type: 'new_post',
                        title: postData.title,
                        area: null // Нет захваченной территории
                    };
                    tg.sendData(JSON.stringify(dataToSend));
                    console.log('Данные о новом простом посте отправлены боту:', dataToSend);
                } catch (e) {
                    console.error('Не удалось отправить данные боту:', e);
                }
                // --- КОНЕЦ НОВОГО БЛОКА ---
            }
        }


        async function fetchAllProfilesAndDraw() {
            let { data: profiles, error } = await supabase.from('profiles').select('*, territory_wkt:territory::text');
            if (error) { console.error("Error fetching profiles:", error); return; }
            allProfilesData = profiles;
            
            territoriesLayerGroup.clearLayers();
            allUserLayers = {};

            profiles.forEach(profile => {
                if (telegramUser && profile.id === telegramUser.id) {
                    userTerritory = parseWKT(profile.territory_wkt) || profile.territory;
                    userColor = profile.color;
                    refreshAllStats();
                }
                const userLayerGroup = L.layerGroup();
                const territoryGeoJson = parseWKT(profile.territory_wkt);
                if (territoryGeoJson) {
                    L.geoJSON(territoryGeoJson, { style: { color: profile.color, weight: 2, opacity: 0.8, fillColor: profile.color, fillOpacity: 0.4 } }).addTo(userLayerGroup);
                }
                userLayerGroup.addTo(territoriesLayerGroup);
                allUserLayers[profile.id] = userLayerGroup;
            });
            updateLeaderboard(profiles);
        }

        function updateLeaderboard(profiles) {
            profiles.sort((a, b) => (b.area || 0) - (a.area || 0));
            leaderboardDiv.innerHTML = profiles.map((u, index) => {
                const isCurrentUser = telegramUser && u.id === telegramUser.id;
                const name = u.name.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                const displayName = isCurrentUser ? `${name} (Вы)` : name;
                const avatar = u.photo_url || `https://placehold.co/50x50/E5E7EB/4B5563?text=${name.charAt(0)}`;
                const area = u.area || 0;
                const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;
                return `<div class="card-bg rounded-xl shadow-md p-4 flex items-center space-x-4 cursor-pointer hover:bg-gray-50 transition" onclick="showDetailModal('user', ${u.id})">
                            <span class="text-xl font-bold w-8" style="color: var(--hint-color);">${index + 1}</span>
                            <img src="${avatar}" class="w-12 h-12 rounded-full" alt="avatar">
                            <div class="flex-grow">
                                <p class="font-bold">${displayName}</p>
                                <p class="text-sm" style="color: var(--hint-color);">${formattedArea}</p>
                            </div>
                        </div>`
            }).join('');
        }

        function refreshAllStats() {
            let area = 0;
            if (userTerritory) {
                try {
                    area = turf.area(userTerritory);
                } catch(e) {
                    console.warn("Could not calculate area for user territory", e);
                    area = 0;
                }
            }
            if (isNaN(area)) area = 0;
            const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;
            profileAreaDisplay.textContent = formattedArea;
        }

        async function renderFeed() {
            const { data: posts, error: postsError } = await supabase.from('posts').select('*').order('created_at', { ascending: false });
            if (postsError) { console.error("Error fetching posts:", postsError); return; }
            const postIds = posts.map(p => p.id);
            if (postIds.length === 0) {
                feedContainer.innerHTML = '<p class="text-center text-gray-500">В ленте пока нет постов.</p>';
                return;
            }
            const { data: likes, error: likesError } = await supabase.from('likes').select('*').in('post_id', postIds);
            const { data: comments, error: commentsError } = await supabase.from('comments').select('id, post_id').in('post_id', postIds);
            if (likesError || commentsError) { console.error("Error fetching activity:", likesError, commentsError); return; }
            const likesByPost = likes.reduce((acc, like) => { (acc[like.post_id] = acc[like.post_id] || []).push(like); return acc; }, {});
            const commentsByPost = comments.reduce((acc, comment) => { (acc[comment.post_id] = acc[comment.post_id] || []).push(comment); return acc; }, {});
            
            const feedHTML = posts.map(post => generatePostHTML(post, likesByPost[post.id] || [], commentsByPost[post.id] || [])).join('');
            feedContainer.innerHTML = feedHTML || '<p class="text-center text-gray-500">В ленте пока нет постов.</p>';
            
            posts.forEach(post => {
                if (post.territory_captured) {
                    const mapContainer = document.getElementById(`mini-map-${post.id}`);
                    if (mapContainer && !mapContainer._leaflet_id) {
                        const miniMap = L.map(mapContainer, { zoomControl: false, attributionControl: false, dragging: false, scrollWheelZoom: false, doubleClickZoom: false });
                        L.tileLayer(MAP_TILE_URL, { maxZoom: 19, accessToken: MAPBOX_ACCESS_TOKEN, tileSize: 512, zoomOffset: -1 }).addTo(miniMap);
                        const territoryLayer = L.geoJSON(post.territory_captured, { style: { color: post.user_color, weight: 2, opacity: 0.8, fillColor: post.user_color, fillOpacity: 0.5 } }).addTo(miniMap);
                        miniMap.fitBounds(territoryLayer.getBounds(), { padding: [10, 10] });
                    }
                }
            });
        }
        
        function generatePostHTML(post, likes, comments) {
            const avatar = post.user_avatar_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${post.user_name.charAt(0)}`;
            const area = post.area_captured || 0;
            const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;
            const userHasLiked = telegramUser && likes.some(like => like.user_id === telegramUser.id);
            return `<div class="card-bg rounded-2xl shadow-lg overflow-hidden" id="post-${post.id}">
                        <div class="p-4">
                            <div class="flex items-center space-x-3 cursor-pointer" onclick="showDetailModal('user', ${post.user_id})"><img src="${avatar}" class="w-10 h-10 rounded-full" alt="avatar"><div><p class="font-bold">${post.user_name}</p><p class="text-xs" style="color: var(--hint-color);">${new Date(post.created_at).toLocaleString('ru-RU')}</p></div></div>
                            <p class="mt-4 font-semibold">${post.title.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</p>
                            ${post.description ? `<p class="mt-2 text-sm" style="color: var(--text-color);">${post.description.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</p>` : ''}
                        </div>
                        ${post.photo_url ? `<img src="${post.photo_url}" class="w-full h-64 object-cover" alt="Post photo">` : ''}
                        ${post.territory_captured ? `<div id="mini-map-${post.id}" class="h-48 w-full mini-map"></div>` : ''}
                        <div class="p-4">
                            ${post.area_captured ? `<p class="font-semibold">Захвачено: <span class="font-bold" style="color: var(--button-color);">${formattedArea}</span></p>` : ''}
                            <div class="flex items-center space-x-6 mt-3" style="color: var(--hint-color);">
                                <button class="like-btn flex items-center space-x-1 hover:text-red-500 transition ${userHasLiked ? 'liked' : ''}" data-action="like" data-post-id="${post.id}">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 016.364 0L12 7.636l1.318-1.318a4.5 4.5 0 016.364 6.364L12 20.364l-7.682-7.682a4.5 4.5 0 010-6.364z" /></svg>
                                    <span data-likes-count>${likes.length}</span>
                                </button>
                                <button class="flex items-center space-x-1 hover:text-blue-500 transition" data-action="comment" data-post-id="${post.id}">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" /></svg>
                                    <span>${comments.length}</span>
                                </button>
                            </div>
                        </div>
                    </div>`;
        }

        async function toggleLike(buttonElement, postId) {
            if (!telegramUser) {
                tg.showAlert('Пользователь не определен. Попробуйте перезагрузить приложение.');
                return;
            }
            tg.HapticFeedback.impactOccurred('light');
            
            const hasLiked = buttonElement.classList.contains('liked');
            const countSpan = buttonElement.querySelector('[data-likes-count]');
            let currentCount = parseInt(countSpan.textContent, 10);

            buttonElement.classList.toggle('liked');
            countSpan.textContent = hasLiked ? currentCount - 1 : currentCount + 1;

            try {
                if (hasLiked) {
                    await supabase.from('likes').delete().match({ post_id: postId, user_id: telegramUser.id });
                } else {
                    await supabase.from('likes').insert({ post_id: postId, user_id: telegramUser.id });
                }
            } catch (error) {
                console.error("Ошибка лайка:", error);
                buttonElement.classList.toggle('liked');
                countSpan.textContent = currentCount;
                tg.showAlert('Не удалось поставить лайк. Попробуйте снова.');
            }
        }
        
        // --- СИСТЕМА КОММЕНТАРИЕВ ---

        async function fetchComments(type, id) {
            let query = supabase.from('comments').select('*, profiles(id, name, photo_url)');
            if (type === 'post') {
                query = query.eq('post_id', id);
            } else if (type === 'spot') {
                query = query.eq('spot_id', id);
            } else if (type === 'route') {
                query = query.eq('route_id', id);
            }
            const { data, error } = await query.order('created_at', { ascending: true });
            return { data, error };
        }
        
        async function showPostComments(postId) {
            tg.HapticFeedback.impactOccurred('medium');
            tg.BackButton.show();
            currentReplyTarget = { type: 'post', id: postId, parentCommentId: null };
            cancelReply();
            
            const modalBody = document.getElementById('comments-modal-body');
            modalBody.innerHTML = '<div class="text-center p-8"><svg class="animate-spin mx-auto h-8 w-8 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></div>';
            commentsModal.classList.add('visible');
            
            const { data: comments, error } = await fetchComments('post', postId);
            if (error) { modalBody.innerHTML = `<p class="text-center p-4 text-red-500">Ошибка загрузки комментариев</p>`; return; }

            renderCommentTree(comments, modalBody);
        }

        async function loadAndRenderComments(type, id, containerId) {
              const container = document.getElementById(containerId);
              if (!container) return;
              container.innerHTML = '<p class="text-center text-gray-500">Загрузка комментариев...</p>';
              
              const { data: comments, error } = await fetchComments(type, id);
              if (error) { container.innerHTML = `<p class="text-center p-4 text-red-500">Ошибка загрузки комментариев</p>`; return; }

              renderCommentTree(comments, container, 'detail');
        }

        function renderCommentTree(comments, container, context = 'post') {
            const commentsByParent = comments.reduce((acc, comment) => { (acc[comment.parent_comment_id || 'root'] = acc[comment.parent_comment_id || 'root'] || []).push(comment); return acc; }, {});
            const rootComments = commentsByParent['root'] || [];
            container.innerHTML = rootComments.length ? rootComments.map(c => generateCommentHTML(c, commentsByParent, context)).join('') : '<p class="text-center text-gray-500 py-4">Нет комментариев</p>';
        }

        function hideCommentsModal() {
            tg.BackButton.hide();
            commentsModal.classList.remove('visible');
        }

        function generateCommentHTML(comment, commentsByParent, context = 'post') {
            const replies = commentsByParent[comment.id] || [];
            const profileName = comment.profiles ? comment.profiles.name : 'Аноним';
            const avatar = comment.profiles ? (comment.profiles.photo_url || `https://placehold.co/32x32/E5E7EB/4B5563?text=${profileName.charAt(0)}`) : 'https://placehold.co/32x32';
            const replyFn = context === 'post' ? 'setReplyMode' : 'setDetailReplyMode';
            const parentId = comment.post_id || comment.spot_id || comment.route_id;

            return `<div class="flex items-start space-x-3 mt-4">
                        <img src="${avatar}" class="w-8 h-8 rounded-full">
                        <div class="flex-1">
                            <div class="rounded-lg p-2" style="background-color: var(--bg-color);">
                                <p class="font-bold text-sm">${profileName}</p>
                                <p class="text-sm">${comment.content}</p>
                            </div>
                            <div class="text-xs mt-1">
                                <button onclick="${replyFn}('${parentId}', ${comment.id}, '${profileName.replace(/'/g, "\\'")}')" class="font-medium" style="color: var(--hint-color);">Ответить</button>
                            </div>
                            <div class="pl-4 border-l-2">${replies.map(reply => generateCommentHTML(reply, commentsByParent, context)).join('')}</div>
                        </div>
                    </div>`;
        }
        
        function setReplyMode(postId, parentCommentId, parentAuthorName) {
            currentReplyTarget = { type: 'post', id: postId, parentCommentId };
            document.getElementById('reply-indicator-text').textContent = `Ответ: ${parentAuthorName}`;
            document.getElementById('reply-indicator').classList.remove('hidden');
            document.getElementById('main-comment-input').focus();
        }

        function cancelReply() {
            currentReplyTarget.parentCommentId = null;
            document.getElementById('reply-indicator').classList.add('hidden');
        }

        async function postComment() {
            const { type, id, parentCommentId } = currentReplyTarget;
            if (!id || !telegramUser) return;
            const inputElement = document.getElementById('main-comment-input');
            const content = inputElement.value.trim();
            if (!content) return;
            
            const commentData = { 
                post_id: id,
                user_id: telegramUser.id, 
                parent_comment_id: parentCommentId, 
                content: content 
            };
            const { error } = await supabase.from('comments').insert(commentData);
            if (error) { tg.showAlert('Ошибка отправки'); } else { inputElement.value = ''; cancelReply(); }
        }

        function setDetailReplyMode(id, parentCommentId, parentAuthorName) {
            currentDetailContext.replyTo = { parentCommentId };
            document.getElementById('detail-reply-indicator-text').textContent = `Ответ: ${parentAuthorName}`;
            document.getElementById('detail-reply-indicator').classList.remove('hidden');
            document.getElementById('detail-comment-input').focus();
        }
        
        function cancelDetailReply() {
            currentDetailContext.replyTo = null;
            document.getElementById('detail-reply-indicator').classList.add('hidden');
        }

        async function postDetailComment() {
            const { type, id, replyTo } = currentDetailContext;
            if (!id || !telegramUser) return;
            const inputElement = document.getElementById('detail-comment-input');
            const content = inputElement.value.trim();
            if (!content) return;

            const parentCommentId = replyTo ? replyTo.parentCommentId : null;

            const commentData = {
                user_id: telegramUser.id,
                parent_comment_id: parentCommentId,
                content: content
            };
            if (type === 'spot') {
                commentData.spot_id = id;
            } else if (type === 'route') {
                commentData.route_id = id;
            }

            const { error } = await supabase.from('comments').insert(commentData);

            if (error) { 
                tg.showAlert('Ошибка отправки комментария.'); 
                console.error("Comment post error:", error);
            } else { 
                inputElement.value = ''; 
                cancelDetailReply();
                loadAndRenderComments(type, id, 'detail-comments-list');
            }
        }


        function switchMainProfileTab(tabName) {
            document.querySelectorAll('#profile-view .profile-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('#profile-view .profile-tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`profile-tab-${tabName}`).classList.add('active');
            document.getElementById(`profile-content-${tabName}`).classList.add('active');
        }

        async function renderMyProfileContent() {
            if (!telegramUser) return;
            const userId = telegramUser.id;

            const [postsRes, spotsRes, routesRes] = await Promise.all([
                supabase.from('posts').select('*').eq('user_id', userId).order('created_at', { ascending: false }),
                supabase.from('spots').select('*, location_wkt:location::text').eq('user_id', userId).order('created_at', { ascending: false }),
                supabase.from('routes').select('*, path_wkt:path::text').eq('user_id', userId).order('created_at', { ascending: false })
            ]);

            const posts = postsRes.data || [];
            const postIds = posts.map(p => p.id);
            const likesByPost = {};
            const commentsByPost = {};
            if (postIds.length > 0) {
                const { data: likes } = await supabase.from('likes').select('*').in('post_id', postIds);
                const { data: comments } = await supabase.from('comments').select('id, post_id').in('post_id', postIds);
                if(likes) likes.forEach(like => (likesByPost[like.post_id] = likesByPost[like.post_id] || []).push(like));
                if(comments) comments.forEach(comment => (commentsByPost[comment.post_id] = commentsByPost[comment.post_id] || []).push(comment));
            }
            const postsContainer = document.getElementById('profile-content-posts');
            postsContainer.innerHTML = posts.length > 0 ? posts.map(p => generatePostHTML(p, likesByPost[p.id] || [], commentsByPost[p.id] || [])).join('') : '<p class="text-center text-gray-500 py-4">У вас нет постов.</p>';
            document.getElementById('profile-tab-posts').textContent = `Посты (${posts.length})`;

            const spots = spotsRes.data || [];
            const spotsContainer = document.getElementById('profile-content-spots');
            spotsContainer.innerHTML = spots.length > 0 ? spots.map(generateMiniSpotHTML).join('') : '<p class="text-center text-gray-500 py-4">У вас нет спотов.</p>';
            document.getElementById('profile-tab-spots').textContent = `Споты (${spots.length})`;

            const routes = routesRes.data || [];
            const routesContainer = document.getElementById('profile-content-routes');
            routesContainer.innerHTML = routes.length > 0 ? routes.map(generateMiniRouteHTML).join('') : '<p class="text-center text-gray-500 py-4">У вас нет маршрутов.</p>';
            document.getElementById('profile-tab-routes').textContent = `Маршруты (${routes.length})`;
        }


        // --- ПРИВЯЗКА ГЛОБАЛЬНЫХ ФУНКЦИЙ И ЗАПУСК ---
        window.showView = showView;
        window.hideEditModal = hideEditModal;
        window.hideDetailModal = hideDetailModal;
        window.toggleLike = toggleLike;
        window.showPostComments = showPostComments;
        window.hideCommentsModal = hideCommentsModal;
        window.setReplyMode = setReplyMode;
        window.cancelReply = cancelReply;
        window.postComment = postComment;
        window.showDetailModal = showDetailModal;
        window.switchProfileTab = switchProfileTab;
        window.switchMainProfileTab = switchMainProfileTab;
        window.navigateToMapObject = navigateToMapObject;
        window.hideSimplePostModal = hideSimplePostModal;
        window.handleSimplePostSave = handleSimplePostSave;
        window.hideCreationModal = hideCreationModal;
        window.postDetailComment = postDetailComment;
        window.setDetailReplyMode = setDetailReplyMode;
        window.cancelDetailReply = cancelDetailReply;
        window.requestPermissionAndReload = requestPermissionAndReload;
        
        document.addEventListener('DOMContentLoaded', main);
    </script>

</body>
</html>
