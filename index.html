<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>TerraRun | Карта</title>

    <!-- Подключение Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- ПОДКЛЮЧЕНИЕ YANDEX MAPS API -->
    <script src="https://api-maps.yandex.ru/2.1/?apikey=6559b722-5ab3-4376-b85c-ce2c99df7d46&lang=ru_RU" type="text/javascript"></script>

    <!-- Подключение Turf.js для гео-анализа -->
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
    
    <!-- Подключение Telegram Web App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- Подключение Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <!-- Подключение QR Code Generator -->
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

    <!-- Иконочные шрифты -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">
    
    <!-- Шрифты Google -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #f3f4f6;
            --secondary-bg-color: #ffffff;
            --text-color: #1f2937;
            --hint-color: #6b7280;
            --button-color: #3b82f6;
            --button-text-color: #ffffff;
            --destructive-color: #ef4444;
            --success-color: #22c55e;
            --star-color: #facc15;
            --border-color: #e5e7eb;
            --button-color-rgb: 59, 130, 246;
        }

        /* Адаптация под безопасные зоны iOS */
        body {
            padding-top: constant(safe-area-inset-top);
            padding-top: env(safe-area-inset-top);
            padding-bottom: constant(safe-area-inset-bottom);
            padding-bottom: env(safe-area-inset-bottom);
        }

        body {
            overscroll-behavior: none;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            font-family: 'Inter', sans-serif;
        }
        #map, .mini-map, #detail-mini-map {
            z-index: 10;
            background-color: var(--bg-color);
        }
        #map {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 80px; /* Высота навбара */
        }
        .view {
            display: none;
            height: calc(100vh - 80px - env(safe-area-inset-bottom));
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            transition: opacity 0.3s ease-in-out;
            background-color: var(--bg-color);
        }
        .view.active {
            display: block;
        }
        .nav-btn.active i, .nav-btn.active span {
            color: var(--button-color);
        }
        .nav-btn span {
             color: var(--hint-color);
        }
        .nav-btn i {
             color: var(--hint-color);
        }
        .card-bg {
            background-color: var(--secondary-bg-color);
        }
        #bottom-navbar {
            height: calc(80px + env(safe-area-inset-bottom));
            padding-bottom: env(safe-area-inset-bottom);
            background-color: rgba(var(--secondary-bg-color-rgb), 0.8);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-top: 1px solid var(--border-color);
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .avatar-marker {
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 15px rgba(0,0,0,0.4);
            background-size: cover;
            background-position: center;
            transition: transform 0.2s ease-in-out, left 0.5s linear, top 0.5s linear;
        }
        .avatar-marker:hover {
            transform: scale(1.1);
        }
        .current-user-marker {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 2px 15px rgba(0,0,0,0.4), 0 0 0 0 rgba(var(--button-color-rgb), 0.7); }
            70% { box-shadow: 0 2px 15px rgba(0,0,0,0.4), 0 0 0 15px rgba(var(--button-color-rgb), 0); }
            100% { box-shadow: 0 2px 15px rgba(0,0,0,0.4), 0 0 0 0 rgba(var(--button-color-rgb), 0); }
        }
        .like-btn.liked i {
            color: var(--destructive-color);
            font-weight: 900; /* Solid heart */
        }
        #initial-loader {
            background-color: var(--bg-color);
        }
        /* Стили для верхней панели на карте */
        #map-top-panel {
            position: fixed;
            top: calc(1rem + env(safe-area-inset-top));
            left: 0;
            right: 0;
            z-index: 20;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0 1rem;
            pointer-events: none; /* Позволяет кликать сквозь контейнер */
        }
        #mode-switcher {
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 9999px;
            padding: 0.25rem;
            display: flex;
            gap: 0.25rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            pointer-events: all; /* Включаем клики для самого свитчера */
        }
        #map-controls-right {
            pointer-events: all; /* Включаем клики для кнопок справа */
        }
        .mode-btn {
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--hint-color);
            transition: all 0.2s ease-in-out;
            border: none;
            background-color: transparent;
        }
        .mode-btn.active {
            background-color: var(--button-color);
            color: var(--button-text-color);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        /* Стили для модальных окон */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0,0,0,0.4);
            display: flex;
            z-index: 50;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        
        /* Модальное окно сверху вниз */
        #simple-post-modal {
            align-items: flex-start;
        }
        #simple-post-content {
            transform: translateY(-100%);
            transition: transform 0.3s ease-in-out;
        }
        #simple-post-modal.visible #simple-post-content {
            transform: translateY(0);
        }

        /* Модальное окно снизу вверх (Bottom Sheet) */
        .bottom-sheet-modal {
            align-items: flex-end;
        }
        .bottom-sheet-content {
            width: 100%;
            background-color: var(--secondary-bg-color);
            border-radius: 1.5rem 1.5rem 0 0;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform 0.3s ease-in-out;
        }
        .bottom-sheet-modal.visible .bottom-sheet-content {
            transform: translateY(0);
        }
        .grabber {
            width: 3rem;
            height: 0.375rem;
            background-color: #d1d5db;
            border-radius: 9999px;
            margin: 0.75rem auto;
            flex-shrink: 0;
            cursor: grab;
        }
        
        /* Стили для табов в профиле */
        .profile-tab {
            flex-grow: 1;
            text-align: center;
            padding: 0.75rem 0.5rem;
            font-weight: 600;
            color: var(--hint-color);
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }
        .profile-tab.active {
            color: var(--button-color);
            border-bottom-color: var(--button-color);
        }
        .profile-tab-content {
            display: none;
        }
        .profile-tab-content.active {
            display: block;
        }
        
        /* Стили для комментариев в модальном окне деталей */
        #detail-comments-section {
            border-top: 1px solid var(--border-color);
            padding: 1rem;
        }
        #detail-comment-input-form {
            padding: 0.5rem 1rem 1rem;
            border-top: 1px solid var(--border-color);
            background-color: var(--secondary-bg-color);
        }

        /* Скелетная загрузка */
        .skeleton {
            background-color: #e2e8f0;
            border-radius: 0.5rem;
            animation: pulse-bg 1.5s infinite;
        }
        @keyframes pulse-bg {
            50% { background-color: #cbd5e1; }
        }
        
        /* Улучшенные стили для инпутов */
        .form-input, .form-textarea {
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .form-input:focus, .form-textarea:focus {
            outline: none;
            border-color: var(--button-color);
            box-shadow: 0 0 0 2px rgba(var(--button-color-rgb), 0.2);
        }
    </style>
</head>
<body class="font-sans antialiased overflow-hidden">
    
    <!-- Начальный загрузчик -->
    <div id="initial-loader" class="fixed inset-0 flex flex-col items-center justify-center z-50">
        <svg class="animate-spin h-10 w-10 mb-4" style="color: var(--button-color);" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
        <p id="loader-text" class="text-lg font-semibold" style="color: var(--text-color);">Загрузка TerraRun...</p>
    </div>

    <!-- Экран-заглушка / Ошибка -->
    <div id="fallback-screen" class="fixed inset-0 flex items-center justify-center p-4 z-40 hidden">
        <div id="fallback-content" class="text-center card-bg p-8 rounded-2xl shadow-lg max-w-sm"></div>
    </div>

    <!-- Основной контейнер приложения -->
    <div id="app-container" class="hidden">
        <!-- Вид 1: Карта -->
        <div id="map-view" class="view active">
            <div id="map"></div>
            
            <!-- NEW: Centered container for geo request button -->
            <div id="map-center-controls" class="fixed inset-0 z-20 flex justify-center items-center pointer-events-none hidden">
                <button id="request-geo-btn" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-full shadow-lg flex items-center gap-2 pointer-events-auto">
                    <i class="fa-solid fa-location-arrow h-5 w-5"></i>
                    <span id="request-geo-text">Дать доступ к гео</span>
                    <svg id="request-geo-loader" class="animate-spin h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                </button>
            </div>
            
            <!-- Панель управления на карте -->
            <div id="map-top-panel">
                <div class="w-12"></div> <!-- Пустой див для баланса слева -->
                
                <div class="flex-grow flex justify-center">
                     <div id="mode-switcher" class="hidden">
                         <button id="mode-capture" class="mode-btn active">Захват</button>
                         <button id="mode-spots" class="mode-btn">Споты</button>
                         <button id="mode-routes" class="mode-btn">Маршруты</button>
                     </div>
                </div>

                <div id="map-controls-right" class="flex flex-col items-end gap-2">
                    <button id="recenter-btn" class="hidden bg-white/80 backdrop-blur-md p-3 rounded-full shadow-lg pointer-events-all">
                        <i class="fa-solid fa-location-crosshairs h-6 w-6 text-gray-700"></i>
                    </button>
                </div>
            </div>
            
            <!-- Основная кнопка действия на карте -->
            <div id="map-action-container" class="hidden fixed bottom-[100px] left-0 right-0 z-20 flex justify-center pointer-events-none">
                <button id="map-action-btn" class="text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all duration-300 flex items-center gap-2 pointer-events-auto">
                    <i id="map-action-icon" class="fa-solid fa-play h-5 w-5"></i>
                    <span id="map-action-text"></span>
                </button>
            </div>
        </div>

        <!-- Вид 2: Лента -->
        <div id="feed-view" class="view p-4 fade-in">
            <div class="flex justify-between items-center mb-6 px-2">
                <h1 class="text-3xl font-bold">Лента</h1>
                <button id="create-simple-post-btn" class="p-2 rounded-full hover:bg-gray-200" style="background-color: var(--secondary-bg-color);">
                    <i class="fa-solid fa-plus h-7 w-7" style="color: var(--button-color);"></i>
                </button>
            </div>
            <div id="feed-container" class="space-y-4"></div>
        </div>

        <!-- Вид 3: Топ пользователей -->
        <div id="top-view" class="view p-4 fade-in">
            <div class="flex justify-between items-center mb-6 px-2">
                <h1 class="text-3xl font-bold">Топ Бегунов</h1>
                <button id="scan-qr-btn" class="p-2 rounded-full hover:bg-gray-200" style="background-color: var(--secondary-bg-color);">
                    <i class="fa-solid fa-qrcode h-7 w-7" style="color: var(--hint-color);"></i>
                </button>
            </div>
            <div id="leaderboard" class="space-y-3"></div>
        </div>

        <!-- Вид 4: Профиль -->
        <div id="profile-view" class="view p-4 fade-in">
            <h1 class="text-3xl font-bold mb-6 px-2">Профиль</h1>
            <div class="card-bg rounded-2xl shadow-lg p-6 flex flex-col items-center space-y-4">
                <div id="profile-avatar-wrapper" class="w-24 h-24 rounded-full border-4 flex-shrink-0">
                    <img src="https://placehold.co/96x96/E2E8F0/4A5568?text=?" id="profile-avatar-img" class="w-full h-full rounded-full object-cover" alt="avatar">
                </div>
                <div class="text-center">
                    <h2 id="profile-name" class="text-2xl font-bold">Загрузка...</h2>
                    <p class="text-sm mt-2" style="color: var(--hint-color);">Общая площадь</p>
                    <p id="profile-area" class="text-3xl font-bold" style="color: var(--button-color);">0 м²</p>
                </div>
                <div class="w-full pt-4 mt-4 border-t" style="border-color: var(--border-color);">
                    <div class="flex justify-center gap-8 w-full">
                        <button id="share-profile-btn" class="flex flex-col items-center space-y-1 transition-opacity hover:opacity-70">
                            <div class="p-3 rounded-full" style="background-color: rgba(var(--button-color-rgb), 0.15);"><i class="fa-solid fa-arrow-up-from-bracket h-6 w-6" style="color: var(--button-color);"></i></div>
                            <span class="text-xs font-medium" style="color: var(--hint-color);">Поделиться</span>
                        </button>
                        <button id="show-qr-btn" class="flex flex-col items-center space-y-1 transition-opacity hover:opacity-70">
                            <div class="p-3 rounded-full" style="background-color: rgba(var(--button-color-rgb), 0.15);"><i class="fa-solid fa-qrcode h-6 w-6" style="color: var(--button-color);"></i></div>
                            <span class="text-xs font-medium" style="color: var(--hint-color);">Мой QR</span>
                        </button>
                    </div>
                </div>
            </div>
             <!-- Табы -->
            <div class="flex border-b mt-6 sticky top-0 z-10" style="background-color: var(--bg-color);">
                <div id="profile-tab-posts" class="profile-tab active" onclick="switchMainProfileTab('posts')">Посты</div>
                <div id="profile-tab-spots" class="profile-tab" onclick="switchMainProfileTab('spots')">Споты</div>
                <div id="profile-tab-routes" class="profile-tab" onclick="switchMainProfileTab('routes')">Маршруты</div>
            </div>

            <div id="profile-content-posts" class="profile-tab-content active mt-4 space-y-4"></div>
            <div id="profile-content-spots" class="profile-tab-content mt-4 space-y-4"></div>
            <div id="profile-content-routes" class="profile-tab-content mt-4 space-y-4"></div>
        </div>
    </div>

    <!-- Нижний навбар -->
    <nav id="bottom-navbar" class="hidden fixed bottom-0 left-0 right-0 flex justify-evenly items-center z-20">
        <button class="nav-btn active flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('map-view')"><i class="fa-solid fa-map-location-dot h-7 w-7"></i><span>Карта</span></button>
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('feed-view')"><i class="fa-solid fa-newspaper h-7 w-7"></i><span>Лента</span></button>
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('top-view')"><i class="fa-solid fa-ranking-star h-7 w-7"></i><span>Топ</span></button>
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('profile-view')"><i class="fa-solid fa-user h-7 w-7"></i><span>Профиль</span></button>
    </nav>
    
    <!-- Модальное окно создания простого поста (сверху вниз, 45%) -->
    <div id="simple-post-modal" class="modal-overlay" onclick="if(event.target === this) hideSimplePostModal()">
        <div id="simple-post-content" class="card-bg rounded-b-2xl shadow-2xl p-6 w-full max-w-lg space-y-4" style="height: 45vh;">
            <div class="flex justify-between items-center">
                <h2 class="text-2xl font-bold">Новый пост</h2>
                <button onclick="hideSimplePostModal()" class="p-2 rounded-full hover:bg-gray-200"><i class="fa-solid fa-times"></i></button>
            </div>
            <p style="color: var(--hint-color);">Поделитесь своими мыслями с сообществом.</p>
            <textarea id="simple-post-details" class="form-textarea mt-1 block w-full h-1/3" placeholder="Что у вас нового?"></textarea>
            <div id="simple-post-filename" class="text-sm text-gray-500 truncate"></div>
            <div class="flex justify-between items-center pt-4">
                 <label for="simple-post-photo-input" class="cursor-pointer p-2 rounded-full hover:bg-gray-200">
                     <i class="fa-solid fa-paperclip h-7 w-7" style="color: var(--hint-color);"></i>
                     <input id="simple-post-photo-input" type="file" class="sr-only" accept="image/*">
                 </label>
                <button onclick="handleSimplePostSave()" class="text-white font-bold py-2 px-6 rounded-full transition-all" style="background-color: var(--button-color);">Опубликовать</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно создания Спота/Маршрута/Поста (снизу вверх, 75%) -->
    <div id="creation-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideCreationModal()">
        <div class="bottom-sheet-content" style="height: 75%; max-height: calc(100vh - env(safe-area-inset-top) - 1rem);">
            <div class="grabber" onclick="hideCreationModal()"></div>
            <div id="creation-modal-body" class="flex-grow overflow-y-auto p-4 space-y-4">
                <h2 id="creation-modal-title" class="text-2xl font-bold"></h2>
                <p id="creation-modal-description" style="color: var(--hint-color);"></p>
                <div>
                    <label for="creation-modal-name" class="block text-sm font-medium mb-1">Название</label>
                    <input type="text" id="creation-modal-name" class="form-input w-full" placeholder="Например, 'Красивый вид'">
                </div>
                <div id="creation-modal-details-section">
                    <label for="creation-modal-details" class="block text-sm font-medium mb-1">Описание</label>
                    <textarea id="creation-modal-details" rows="3" class="form-textarea w-full" placeholder="Опишите это место или маршрут..."></textarea>
                </div>
                <div id="creation-modal-photo-section">
                    <label class="block text-sm font-medium mb-1">Фото</label>
                    <div class="mt-1 flex justify-center px-6 pt-5 pb-6 border-2 border-gray-300 border-dashed rounded-md">
                        <div class="space-y-1 text-center">
                            <img id="creation-modal-photo-preview" src="" alt="Предпросмотр фото" class="hidden mx-auto h-24 w-auto mb-4 rounded">
                            <i id="creation-modal-photo-icon" class="fa-solid fa-image mx-auto h-12 w-12 text-gray-400"></i>
                            <div class="flex text-sm text-gray-600">
                                <label for="creation-modal-photo-input" class="relative cursor-pointer rounded-md font-medium" style="color: var(--button-color);">
                                    <span>Загрузите файл</span>
                                    <input id="creation-modal-photo-input" type="file" class="sr-only" accept="image/*">
                                </label>
                                <p class="pl-1">или перетащите</p>
                            </div>
                            <p class="text-xs text-gray-500">PNG, JPG до 10MB</p>
                        </div>
                    </div>
                </div>
                <div class="flex justify-end space-x-3 pt-4">
                    <button onclick="hideCreationModal()" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-full transition-all">Отмена</button>
                    <button id="save-creation-btn" class="text-white font-bold py-2 px-4 rounded-full transition-all" style="background-color: var(--button-color);">Сохранить</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно деталей (выдвигается снизу) -->
    <div id="detail-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideDetailModal()">
        <div class="bottom-sheet-content" style="height: 90%; max-height: calc(100vh - env(safe-area-inset-top) - 1rem);">
            <div class="grabber" onclick="hideDetailModal()"></div>
            <div id="detail-modal-body" class="flex-grow overflow-y-auto"></div>
        </div>
    </div>

    <!-- Модальное окно с комментариями (ДЛЯ ПОСТОВ) -->
    <div id="comments-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideCommentsModal()">
        <div class="bottom-sheet-content" style="height: 75%;">
             <div class="grabber" onclick="hideCommentsModal()"></div>
             <h2 id="comments-modal-title" class="text-xl font-bold px-4 pb-2 flex-shrink-0">Комментарии</h2>
            <div id="comments-modal-body" class="flex-grow overflow-y-auto p-4"></div>
            <div id="comment-input-container" class="flex-shrink-0 p-2 border-t" style="background-color: var(--secondary-bg-color); border-color: var(--border-color);">
                <div id="reply-indicator" class="hidden text-xs px-2 pb-1 flex justify-between items-center" style="color: var(--hint-color);">
                    <span id="reply-indicator-text"></span>
                    <button onclick="cancelReply()" class="font-bold text-xl">&times;</button>
                </div>
                <div class="flex items-center space-x-2">
                    <textarea id="main-comment-input" class="form-textarea w-full" rows="1" placeholder="Написать комментарий..."></textarea>
                    <button id="main-comment-send-btn" onclick="postComment()" class="flex-shrink-0 text-white rounded-full p-2 hover:opacity-80 disabled:opacity-50" style="background-color: var(--button-color);">
                        <i class="fa-solid fa-paper-plane h-6 w-6"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно для QR-кода -->
    <div id="qr-modal" class="modal-overlay justify-center items-center p-4" onclick="if(event.target === this) hideQrModal()">
        <div class="card-bg rounded-2xl shadow-2xl p-6 w-full max-w-xs fade-in space-y-4 flex flex-col items-center">
            <h2 class="text-2xl font-bold">Мой QR-код</h2>
            <div id="qrcode" class="p-2 bg-white rounded-lg"></div>
            <p class="text-center text-sm" style="color: var(--hint-color);">Покажите этот код другу, чтобы он отсканировал его в приложении.</p>
            <button onclick="hideQrModal()" class="w-full mt-4 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-full transition-all">Закрыть</button>
        </div>
    </div>

    <script type="module">
        // --- КОНФИГУРАЦИЯ И КОНСТАНТЫ ---
        const SUPABASE_URL = 'https://jsnahjtoqwuwbjdmisuj.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpzbmFoanRvcXd1d2JqZG1pc3VqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMzOTQxMDQsImV4cCI6MjA2ODk3MDEwNH0.M3TWsNJppj1f-Cmj6nGCAUswy1HZgBLW8yJZfTwkrpI';
        const BOT_USERNAME = 'TerraRunBot'; // Имя вашего бота

        // --- ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ И СОСТОЯНИЕ ---
        const tg = window.Telegram.WebApp;
        let map;
        let supabase;
        let telegramUser = null;
        let locationWatchId = null;
        let scrollToPostId = null; 
        
        // Состояние приложения
        const AppState = {
            currentMode: 'capture', // 'capture', 'spots', 'routes'
            isRunning: false, // Для режимов 'capture' и 'routes'
            lastKnownLocation: null,
            userProfile: {
                id: null,
                name: '',
                color: '#3b82f6',
                territory: null,
                photo_url: null,
                area: 0,
            },
            currentRunPath: [],
            currentPathPolyline: null,
            currentUserMarker: null,
            allUserLayers: {},
            allSpots: [],
            allRoutes: [],
            allProfilesData: [],
            currentEditContext: {}, // Для модалки создания/редактирования
            currentDetailContext: {}, // Для модалки деталей
            currentReplyTarget: { type: null, id: null, parentCommentId: null },
        };
        
        // Коллекции геообъектов Yandex Maps
        let territoriesCollection, spotCollection, routeCollection;
        
        // --- ЭЛЕМЕНТЫ DOM ---
        const initialLoader = document.getElementById('initial-loader');
        const loaderText = document.getElementById('loader-text');
        const fallbackScreen = document.getElementById('fallback-screen');
        const fallbackContent = document.getElementById('fallback-content');
        const appContainer = document.getElementById('app-container');
        const bottomNavbar = document.getElementById('bottom-navbar');
        const modeSwitcher = document.getElementById('mode-switcher');
        
        // Модальные окна
        const detailModal = document.getElementById('detail-modal');
        const commentsModal = document.getElementById('comments-modal');
        const simplePostModal = document.getElementById('simple-post-modal');
        const creationModal = document.getElementById('creation-modal');
        const qrModal = document.getElementById('qr-modal');

        const leaderboardDiv = document.getElementById('leaderboard');
        const feedContainer = document.getElementById('feed-container');
        const profileName = document.getElementById('profile-name');
        const profileAreaDisplay = document.getElementById('profile-area');
        const profileAvatarImg = document.getElementById('profile-avatar-img');
        const profileAvatarWrapper = document.getElementById('profile-avatar-wrapper');
        const recenterBtn = document.getElementById('recenter-btn');
        const requestGeoBtn = document.getElementById('request-geo-btn');
        const mapCenterControls = document.getElementById('map-center-controls');
        const scanQrBtn = document.getElementById('scan-qr-btn');
        const shareProfileBtn = document.getElementById('share-profile-btn');
        const showQrBtn = document.getElementById('show-qr-btn');
        const createSimplePostBtn = document.getElementById('create-simple-post-btn');
        const mapActionContainer = document.getElementById('map-action-container');
        const mapActionBtn = document.getElementById('map-action-btn');

        // --- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ---
        
        /**
         * Осветляет или затемняет цвет в формате hex.
         * @param {string} color - Строка цвета в формате hex (например, "#RRGGBB").
         * @param {number} percent - Процент для осветления (положительный) или затемнения (отрицательный).
         * @returns {string} Новая строка цвета в формате hex.
         */
        function shadeColor(color, percent) {
            if (!color || !color.startsWith('#')) {
                return '#e5e7eb'; 
            }
            let R = parseInt(color.substring(1, 3), 16);
            let G = parseInt(color.substring(3, 5), 16);
            let B = parseInt(color.substring(5, 7), 16);

            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);

            R = (R < 255) ? R : 255;
            G = (G < 255) ? G : 255;
            B = (B < 255) ? B : 255;
            
            R = (R > 0) ? R : 0;
            G = (G > 0) ? G : 0;
            B = (B > 0) ? B : 0;

            const RR = ((R.toString(16).length === 1) ? "0" + R.toString(16) : R.toString(16));
            const GG = ((G.toString(16).length === 1) ? "0" + G.toString(16) : G.toString(16));
            const BB = ((B.toString(16).length === 1) ? "0" + B.toString(16) : B.toString(16));

            return "#" + RR + GG + BB;
        }

        /**
         * Преобразует цвет HEX в массив RGB.
         * @param {string} hex - Цвет в формате HEX.
         * @returns {number[] | null} Массив [R, G, B] или null.
         */
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16),
                parseInt(result[2], 16),
                parseInt(result[3], 16)
            ] : null;
        }

        /**
         * Генерирует диплинк и открывает диалог "Поделиться" в Telegram.
         * @param {'post' | 'route' | 'spot' | 'user'} type - Тип контента.
         * @param {number | string} id - ID контента.
         * @param {number | string} ownerId - ID владельца контента.
         */
        function shareContent(type, id, ownerId) {
            tg.HapticFeedback.impactOccurred('light');
            const isOwner = telegramUser && ownerId.toString() === telegramUser.id.toString();
            let text = '';

            switch (type) {
                case 'post':
                    text = isOwner ? 'Оцени мой пост в TerraRun!' : 'Смотри какой интересный пост в TerraRun!';
                    break;
                case 'route':
                    text = isOwner ? 'Зацени мой маршрут в TerraRun!' : 'Смотри какой интересный маршрут в TerraRun!';
                    break;
                case 'spot':
                    text = isOwner ? 'Смотри какой интересный спот в TerraRun!' : 'Смотри какой интересный спот в TerraRun!';
                    break;
                case 'user':
                    text = isOwner ? 'Это мой профиль в TerraRun, присоединяйся!' : 'Смотри профиль этого бегуна в TerraRun!';
                    break;
            }

            const url = `https://t.me/${BOT_USERNAME}?startapp=${type}_${id}`;
            tg.openTelegramLink(`https://t.me/share/url?url=${encodeURIComponent(url)}&text=${encodeURIComponent(text)}`);
        }

        /**
         * Экранирует HTML-строку для безопасного вывода.
         * @param {string} str - Входная строка.
         * @returns {string} Экранированная строка.
         */
        function escapeHTML(str) {
            if (!str) return '';
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
        }


        // --- ФУНКЦИИ UI ---
        function showView(viewId) {
            tg.HapticFeedback.selectionChanged();
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(viewId).classList.add('active');
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`button[onclick="showView('${viewId}')"]`).classList.add('active');
            
            const isMapView = viewId === 'map-view';
            
            if (isMapView && AppState.lastKnownLocation) {
                mapActionContainer.classList.remove('hidden');
            } else {
                mapActionContainer.classList.add('hidden');
            }

            modeSwitcher.classList.toggle('hidden', !isMapView || !AppState.lastKnownLocation);
            
            if (isMapView) {
                setTimeout(() => map?.container.fitToViewport(), 100);
            }
        }

        async function setMode(newMode) {
            if (AppState.currentMode === newMode || !map) return;
            
            if (AppState.isRunning) {
                showCustomAlert("Сначала завершите текущую активность (захват или запись маршрута).");
                return;
            }

            tg.HapticFeedback.selectionChanged();
            AppState.currentMode = newMode;
            
            tg.CloudStorage.setItem('currentMode', newMode);

            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.id === `mode-${newMode}`);
            });

            // Удаляем старый обработчик клика
            map.events.remove('click', handleMapClickForSpot);

            // Управляем видимостью коллекций
            territoriesCollection.options.set('visible', newMode === 'capture');
            spotCollection.options.set('visible', newMode === 'spots');
            routeCollection.options.set('visible', newMode === 'routes');
            
            if (newMode === 'spots') {
                map.events.add('click', handleMapClickForSpot);
            }

            updateMapActionButton();
        }

        function updateMapActionButton() {
            const icon = document.getElementById('map-action-icon');
            const text = document.getElementById('map-action-text');

            if (!AppState.lastKnownLocation) {
                mapActionContainer.classList.add('hidden');
                return;
            }
            
            mapActionContainer.classList.remove('hidden');

            switch (AppState.currentMode) {
                case 'capture':
                    if (AppState.isRunning) {
                        text.textContent = "Остановить захват";
                        mapActionBtn.style.backgroundColor = 'var(--destructive-color)';
                        icon.className = 'fa-solid fa-stop h-5 w-5';
                    } else {
                        text.textContent = "Начать захват";
                        mapActionBtn.style.backgroundColor = 'var(--button-color)';
                        icon.className = 'fa-solid fa-play h-5 w-5';
                    }
                    break;
                case 'spots':
                    text.textContent = "Добавить спот здесь";
                    mapActionBtn.style.backgroundColor = 'var(--success-color)';
                    icon.className = 'fa-solid fa-location-dot h-5 w-5';
                    break;
                case 'routes':
                    if (AppState.isRunning) {
                        text.textContent = "Завершить маршрут";
                        mapActionBtn.style.backgroundColor = 'var(--destructive-color)';
                        icon.className = 'fa-solid fa-stop h-5 w-5';
                    } else {
                        text.textContent = "Начать запись маршрута";
                        mapActionBtn.style.backgroundColor = 'var(--button-color)';
                        icon.className = 'fa-solid fa-route h-5 w-5';
                    }
                    break;
            }
        }
        
        async function mapActionButtonHandler() {
            mapActionBtn.disabled = true; // Предотвращаем двойные нажатия
            try {
                switch (AppState.currentMode) {
                    case 'capture':
                        AppState.isRunning ? await stopRun() : startRun();
                        break;
                    case 'spots':
                        if(AppState.lastKnownLocation) {
                            handleMapClickForSpot({ get: (key) => key === 'coords' ? AppState.lastKnownLocation : null });
                        } else {
                            showCustomAlert("Определяем ваше местоположение...");
                        }
                        break;
                    case 'routes':
                        AppState.isRunning ? await stopRouteRecording() : startRouteRecording();
                        break;
                }
            } finally {
                mapActionBtn.disabled = false;
            }
        }
        
        function generateColorFromId(id) {
            const strId = String(id);
            let hash = 0;
            for (let i = 0; i < strId.length; i++) {
                hash = strId.charCodeAt(i) + ((hash << 5) - hash);
            }
            const h = hash % 360;
            return `hsl(${h}, 80%, 65%)`;
        }

        // --- ЛОГИКА МОДАЛЬНЫХ ОКОН ---
        
        function showSimplePostModal() {
            document.getElementById('simple-post-details').value = '';
            document.getElementById('simple-post-photo-input').value = '';
            document.getElementById('simple-post-filename').textContent = '';
            simplePostModal.classList.add('visible');
            tg.BackButton.show();
        }

        function hideSimplePostModal() {
            simplePostModal.classList.remove('visible');
            tg.BackButton.hide();
        }
        
        function showCreationModal(type, context = {}) {
            AppState.currentEditContext = { type, ...context };
            const title = document.getElementById('creation-modal-title');
            const description = document.getElementById('creation-modal-description');
            const nameInput = document.getElementById('creation-modal-name');
            const detailsInput = document.getElementById('creation-modal-details');
            const detailsSection = document.getElementById('creation-modal-details-section');
            const photoSection = document.getElementById('creation-modal-photo-section');
            
            nameInput.value = '';
            detailsInput.value = '';
            document.getElementById('creation-modal-photo-input').value = '';
            document.getElementById('creation-modal-photo-preview').classList.add('hidden');
            document.getElementById('creation-modal-photo-icon').classList.remove('hidden');

            // Скрываем все секции по умолчанию
            detailsSection.style.display = 'none';
            photoSection.style.display = 'none';

            if (type === 'spot') {
                title.textContent = 'Создать новый спот';
                description.textContent = 'Отметьте интересное место на карте для других.';
                detailsSection.style.display = 'block';
                photoSection.style.display = 'block';
            } else if (type === 'route') {
                title.textContent = 'Сохранить новый маршрут';
                description.textContent = 'Дайте название и описание вашему маршруту.';
                detailsSection.style.display = 'block';
            } else if (type === 'post') {
                title.textContent = 'Новое достижение!';
                description.textContent = `Вы захватили ${context.area_captured_formatted}. Дайте название вашей новой территории.`;
                photoSection.style.display = 'block';
            }
            
            creationModal.classList.add('visible');
            tg.BackButton.show();
        }

        function hideCreationModal() {
            creationModal.classList.remove('visible');
            tg.BackButton.hide();
            AppState.currentEditContext = {};
        }

        function handleSave() {
            const { type } = AppState.currentEditContext;
            if (type === 'spot') saveSpot();
            else if (type === 'route') saveRoute();
            else if (type === 'post') handlePostSubmission();
        }
        
        function showDetailModal(type, id) {
             AppState.currentDetailContext = { type, id, mapInstances: [] };
             tg.HapticFeedback.impactOccurred('medium');
             tg.BackButton.show();
             
             detailModal.classList.add('visible');
             loadDetailContent();
        }
        
        function hideDetailModal() {
            // Уничтожаем все инстансы карт в модалке
            if (AppState.currentDetailContext.mapInstances) {
                AppState.currentDetailContext.mapInstances.forEach(mapInstance => mapInstance.destroy());
            }
            tg.BackButton.hide();
            detailModal.classList.remove('visible');
            AppState.currentDetailContext = {};
        }

        async function loadDetailContent() {
            const { type, id } = AppState.currentDetailContext;
            const body = document.getElementById('detail-modal-body');
            
            body.innerHTML = `<div class="text-center p-8"><svg class="animate-spin mx-auto h-8 w-8 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></div>`;

            const commentsHtml = `
                <div id="detail-comments-section" class="mt-4">
                    <h3 class="text-xl font-bold px-4">Комментарии</h3>
                    <div id="detail-comments-list" class="p-4 space-y-4">
                        <p class="text-center text-gray-500">Загрузка комментариев...</p>
                    </div>
                </div>
                <div id="detail-comment-input-form" class="flex-shrink-0 p-2 border-t" style="background-color: var(--secondary-bg-color); border-color: var(--border-color);">
                     <div id="detail-reply-indicator" class="hidden text-xs px-2 pb-1 flex justify-between items-center" style="color: var(--hint-color);">
                         <span id="detail-reply-indicator-text"></span>
                         <button onclick="cancelDetailReply()" class="font-bold text-xl">&times;</button>
                     </div>
                    <div class="flex items-center space-x-2">
                        <textarea id="detail-comment-input" class="form-textarea w-full" rows="1" placeholder="Написать комментарий..."></textarea>
                        <button onclick="postDetailComment()" class="flex-shrink-0 text-white rounded-full p-2 hover:opacity-80 disabled:opacity-50" style="background-color: var(--button-color);">
                           <i class="fa-solid fa-paper-plane h-6 w-6"></i>
                        </button>
                    </div>
                </div>
            `;

            if (type === 'spot') {
                const { data: spot, error } = await supabase.from('spots').select('*, profiles(id, name, photo_url), location_wkt:location::text').eq('id', id).single();
                if (error || !spot) {
                    body.innerHTML = `<p class="text-red-500 text-center p-4">Не удалось загрузить детали спота.</p>`;
                    return;
                }
                const author = spot.profiles || { name: 'Аноним', photo_url: null };
                const avatar = author.photo_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${author.name.charAt(0)}`;
                body.innerHTML = `
                    <div class="space-y-4 pb-4">
                        ${spot.photo_url ? `<img src="${spot.photo_url}" class="w-full h-64 object-cover" alt="Spot photo">` : ''}
                        <div class="px-4">
                            <div class="flex justify-between items-start">
                                <h2 class="text-3xl font-bold flex-1">${escapeHTML(spot.name)}</h2>
                                <button onclick="shareContent('spot', ${spot.id}, ${spot.user_id})" class="p-2 rounded-full hover:bg-gray-200 ml-2 flex-shrink-0">
                                    <i class="fa-solid fa-arrow-up-from-bracket h-6 w-6" style="color: var(--hint-color);"></i>
                                </button>
                            </div>
                            <div class="flex items-center space-x-3 mt-2 cursor-pointer" onclick="showDetailModal('user', ${spot.user_id})">
                                <img src="${avatar}" class="w-8 h-8 rounded-full" alt="author avatar">
                                <span class="font-semibold text-sm">Автор: ${escapeHTML(author.name)}</span>
                            </div>
                            <p class="mt-4" style="color: var(--text-color);">${escapeHTML(spot.description)}</p>
                        </div>
                    </div>
                    ${commentsHtml}
                `;
                loadAndRenderComments(type, id, 'detail-comments-list');
            } else if (type === 'route') {
                const { data: route, error } = await supabase.from('routes').select('*, profiles(id, name, photo_url), path_wkt:path::text').eq('id', id).single();
                if (error || !route) {
                    body.innerHTML = `<p class="text-red-500 text-center p-4">Не удалось загрузить детали маршрута.</p>`;
                    return;
                }
                const author = route.profiles || { name: 'Аноним', photo_url: null };
                const avatar = author.photo_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${author.name.charAt(0)}`;
                body.innerHTML = `
                    <div class="space-y-4 pb-4">
                        <div id="detail-mini-map" class="h-64 w-full bg-gray-200"></div>
                        <div class="px-4">
                             <div class="flex justify-between items-start">
                                 <h2 class="text-3xl font-bold flex-1">${escapeHTML(route.name)}</h2>
                                 <button onclick="shareContent('route', ${route.id}, ${route.user_id})" class="p-2 rounded-full hover:bg-gray-200 ml-2 flex-shrink-0">
                                     <i class="fa-solid fa-arrow-up-from-bracket h-6 w-6" style="color: var(--hint-color);"></i>
                                 </button>
                             </div>
                            <div class="flex items-center space-x-3 mt-2 cursor-pointer" onclick="showDetailModal('user', ${route.user_id})">
                                <img src="${avatar}" class="w-8 h-8 rounded-full" alt="author avatar">
                                <span class="font-semibold text-sm">Автор: ${escapeHTML(author.name)}</span>
                            </div>
                            ${route.description ? `<p class="mt-4" style="color: var(--text-color);">${escapeHTML(route.description)}</p>` : ''}
                        </div>
                    </div>
                     ${commentsHtml}
                `;
                setTimeout(() => {
                    const mapContainer = document.getElementById('detail-mini-map');
                    const routeGeoJson = parseWKT(route.path_wkt);
                    if (mapContainer && routeGeoJson) {
                        const miniMap = new ymaps.Map(mapContainer, { center: [55.75, 37.62], zoom: 9, controls: [] });
                        AppState.currentDetailContext.mapInstances.push(miniMap);
                        
                        const routeObject = new ymaps.Polyline(routeGeoJson.coordinates.map(c => [c[1], c[0]]), {}, { strokeColor: '#ff7800', strokeWidth: 3 });
                        miniMap.geoObjects.add(routeObject);
                        miniMap.setBounds(routeObject.geometry.getBounds(), { checkZoomRange: true, zoomMargin: 10 });
                    }
                }, 100);
                 loadAndRenderComments(type, id, 'detail-comments-list');
            } else if (type === 'user') {
                const [profileRes, postsRes, spotsRes, routesRes] = await Promise.all([
                    supabase.from('profiles').select('*').eq('id', id).single(),
                    supabase.from('posts').select('*').eq('user_id', id).order('created_at', { ascending: false }),
                    supabase.from('spots').select('*, location_wkt:location::text').eq('user_id', id).order('created_at', { ascending: false }),
                    supabase.from('routes').select('*, path_wkt:path::text').eq('user_id', id).order('created_at', { ascending: false })
                ]);

                if (profileRes.error) {
                    body.innerHTML = `<p class="text-red-500 text-center">Не удалось загрузить профиль.</p>`;
                    return;
                }
                const profile = profileRes.data;
                const posts = postsRes.data || [];
                const spots = spotsRes.data || [];
                const routes = routesRes.data || [];

                const postIds = posts.map(p => p.id);
                const likesByPost = {};
                const commentsByPost = {};
                if (postIds.length > 0) {
                    const { data: likes } = await supabase.from('likes').select('*').in('post_id', postIds);
                    const { data: comments } = await supabase.from('comments').select('id, post_id').in('post_id', postIds);
                    if(likes) likes.forEach(like => (likesByPost[like.post_id] = likesByPost[like.post_id] || []).push(like));
                    if(comments) comments.forEach(comment => (commentsByPost[comment.post_id] = commentsByPost[comment.post_id] || []).push(comment));
                }

                const avatar = profile.photo_url || `https://placehold.co/80x80/E5E7EB/4B5563?text=${profile.name.charAt(0)}`;
                const area = profile.area || 0;
                const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;

                body.innerHTML = `
                    <div class="p-4">
                        <div class="flex items-start space-x-4">
                            <img src="${avatar}" class="w-20 h-20 rounded-full" alt="avatar">
                            <div class="flex-1">
                                <h2 class="text-2xl font-bold">${escapeHTML(profile.name)}</h2>
                                <p class="text-sm" style="color: var(--hint-color);">Общая площадь</p>
                                <p class="text-xl font-bold" style="color: var(--button-color);">${formattedArea}</p>
                            </div>
                             <button onclick="shareContent('user', ${profile.id}, ${profile.id})" class="p-2 rounded-full hover:bg-gray-200 flex-shrink-0">
                                 <i class="fa-solid fa-arrow-up-from-bracket h-6 w-6" style="color: var(--hint-color);"></i>
                             </button>
                        </div>
                    </div>
                    
                    <div class="flex border-b mt-4 px-4">
                        <div id="tab-posts" class="profile-tab active" onclick="switchProfileTab('posts')">Посты (${posts.length})</div>
                        <div id="tab-spots" class="profile-tab" onclick="switchProfileTab('spots')">Споты (${spots.length})</div>
                        <div id="tab-routes" class="profile-tab" onclick="switchProfileTab('routes')">Маршруты (${routes.length})</div>
                    </div>

                    <div id="content-posts" class="profile-tab-content active p-4 space-y-4">
                        ${posts.length > 0 ? posts.map(p => generatePostHTML(p, likesByPost[p.id] || [], commentsByPost[p.id] || [])).join('') : '<p class="text-center text-gray-500 py-4">У пользователя нет постов.</p>'}
                    </div>
                    <div id="content-spots" class="profile-tab-content p-4 space-y-4">
                        ${spots.length > 0 ? spots.map(generateMiniSpotHTML).join('') : '<p class="text-center text-gray-500 py-4">У пользователя нет спотов.</p>'}
                    </div>
                    <div id="content-routes" class="profile-tab-content p-4 space-y-4">
                         ${routes.length > 0 ? routes.map(generateMiniRouteHTML).join('') : '<p class="text-center text-gray-500 py-4">У пользователя нет маршрутов.</p>'}
                    </div>
                `;

                setTimeout(() => {
                    posts.forEach(post => {
                        if (post.territory_captured) {
                            const mapContainer = body.querySelector(`#mini-map-${post.id}`);
                            if (mapContainer) {
                                const miniMap = new ymaps.Map(mapContainer, { center: [55.75, 37.62], zoom: 9, controls: [] });
                                AppState.currentDetailContext.mapInstances.push(miniMap);

                                const territoryObject = ymaps.geoQuery(post.territory_captured).addToMap(miniMap);
                                territoryObject.setOptions({
                                    fillColor: post.user_color,
                                    fillOpacity: 0.5,
                                    strokeColor: post.user_color,
                                    strokeWidth: 2,
                                    strokeOpacity: 0.8
                                });
                                miniMap.setBounds(territoryObject.getBounds(), { checkZoomRange: true, zoomMargin: 10 });
                            }
                        }
                    });
                }, 100);
            }
        }
        
        function switchProfileTab(tabName) {
            document.querySelectorAll('#detail-modal .profile-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('#detail-modal .profile-tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`tab-${tabName}`).classList.add('active');
            document.getElementById(`content-${tabName}`).classList.add('active');
        }

        function generateMiniSpotHTML(spot) {
             return `<div class="card-bg rounded-lg p-3 shadow-sm cursor-pointer hover:bg-gray-100" onclick="navigateToMapObject('spot', ${spot.id})">
                         <p class="font-semibold">${escapeHTML(spot.name)}</p>
                         <p class="text-sm text-gray-600 truncate">${escapeHTML(spot.description)}</p>
                         <p class="text-xs text-gray-400">${new Date(spot.created_at).toLocaleDateString()}</p>
                     </div>`;
        }
        function generateMiniRouteHTML(route) {
             return `<div class="card-bg rounded-lg p-3 shadow-sm cursor-pointer hover:bg-gray-100" onclick="navigateToMapObject('route', ${route.id})">
                         <p class="font-semibold">${escapeHTML(route.name)}</p>
                         <p class="text-xs text-gray-400">${new Date(route.created_at).toLocaleDateString()}</p>
                     </div>`;
        }

        function navigateToMapObject(type, id) {
            hideDetailModal(); 
            showView('map-view');
            
            let targetObject;
            if (type === 'spot') {
                setMode('spots');
                targetObject = AppState.allSpots.find(s => s.id === id);
                const geoJson = parseWKT(targetObject?.location_wkt);
                if (geoJson) {
                    const coords = [geoJson.coordinates[1], geoJson.coordinates[0]]; // lat, long
                    map.panTo(coords, { flying: true, duration: 1500 }).then(() => map.setZoom(17));
                }
            } else if (type === 'route') {
                setMode('routes');
                targetObject = AppState.allRoutes.find(r => r.id === id);
                const geoJson = parseWKT(targetObject?.path_wkt);
                 if (geoJson && geoJson.coordinates.length > 0) {
                    const yandexCoords = geoJson.coordinates.map(p => [p[1], p[0]]);
                    const polyline = new ymaps.Polyline(yandexCoords);
                    map.setBounds(polyline.geometry.getBounds(), { checkZoomRange: true, duration: 1000 });
                }
            }
        }

        /**
         * Улучшенная функция для парсинга WKT-строк в GeoJSON.
         * @param {string | object | null} wkt - Строка в формате Well-Known Text или уже GeoJSON объект.
         * @returns {object | null} GeoJSON-объект или null в случае ошибки.
         */
        function parseWKT(wkt) {
            if (!wkt) return null;
            if (typeof wkt === 'object' && wkt.type && wkt.coordinates) {
                return wkt;
            }
            if (typeof wkt !== 'string') return null;
            
            try {
                if (wkt.trim().startsWith('{')) {
                    const parsed = JSON.parse(wkt);
                    if (parsed.type && parsed.coordinates) {
                        return parsed;
                    }
                }

                const match = wkt.match(/(POINT|LINESTRING|POLYGON|MULTIPOLYGON)\s*\((.+)\)/i);
                if (!match) return null;

                const type = match[1].toUpperCase();
                let content = match[2];

                if (type === 'POINT') {
                    const coords = content.match(/-?\d+(\.\d+)?/g);
                    if (!coords || coords.length < 2) return null;
                    return { type: 'Point', coordinates: [parseFloat(coords[0]), parseFloat(coords[1])] };
                }

                if (type === 'LINESTRING') {
                    const coordinates = content.split(',').map(pair => {
                        const nums = pair.trim().match(/-?\d+(\.\d+)?/g);
                        return nums && nums.length >= 2 ? [parseFloat(nums[0]), parseFloat(nums[1])] : null;
                    }).filter(Boolean);
                    return coordinates.length >= 2 ? { type: 'LineString', coordinates } : null;
                }
                
                if (type === 'POLYGON' || type === 'MULTIPOLYGON') {
                    const rings = content.match(/\(([^()]+)\)/g);
                    if (!rings) return null;
                    
                    const coordinates = rings.map(ringContent => 
                        ringContent.replace(/[()]/g, '').split(',').map(pair => {
                            const nums = pair.trim().match(/-?\d+(\.\d+)?/g);
                            return nums && nums.length >= 2 ? [parseFloat(nums[0]), parseFloat(nums[1])] : null;
                        }).filter(Boolean)
                    );

                    if (type === 'POLYGON') {
                        return { type: 'Polygon', coordinates };
                    }
                    if (type === 'MULTIPOLYGON') {
                        return { type: 'MultiPolygon', coordinates: [coordinates] };
                    }
                }

            } catch (e) {
                console.error("Failed to parse WKT or JSON:", wkt, e);
                return null;
            }
            return null;
        }

        // --- ОСНОВНАЯ ЛОГИКА И ИНИЦИАЛИЗАЦИЯ ---
        async function runApp() {
            try {
                tg.ready();
                tg.expand();
                tg.enableClosingConfirmation();
                applyTheme(tg.themeParams);
                setupStaticEventListeners();

                if (!tg.initDataUnsafe?.user) {
                    showFallbackScreen('Требуется Telegram', 'Это приложение предназначено для работы исключительно внутри Telegram.', false);
                    return;
                }
                telegramUser = tg.initDataUnsafe.user;
                
                loaderText.textContent = 'Подключение к базе данных...';
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                
                loaderText.textContent = 'Загрузка данных...';
                initMap({ latitude: 55.751244, longitude: 37.618423 });
                
                await upsertUserProfile();
                updateUI();
                
                await Promise.all([
                    fetchAllProfilesAndDraw(),
                    renderFeed(),
                    loadInitialMapData(),
                    renderMyProfileContent()
                ]);

                listenToRealtimeChanges();
                setupDynamicEventListeners();
                initializeGeolocation();
                handleStartParam();

                initialLoader.classList.add('hidden');
                appContainer.classList.remove('hidden');
                bottomNavbar.classList.remove('hidden');
                
                tg.CloudStorage.getItem('currentMode', (error, value) => {
                    if (error) {
                        console.error("CloudStorage error:", error);
                        setMode('capture');
                        return;
                    }
                    setMode(value || 'capture');
                });

            } catch (error) {
                console.error("Критическая ошибка инициализации:", error);
                let message = error.message || "Не удалось запустить приложение. Пожалуйста, попробуйте перезагрузить его.";
                showFallbackScreen("Ошибка инициализации", message, true);
            }
        }

        function initMap(coords) {
            if (map) return;
            const latLng = [coords.latitude, coords.longitude];
            map = new ymaps.Map('map', { 
                center: latLng, 
                zoom: 5,
                controls: [] // Отключаем стандартные элементы управления
            });
            
            // Создаем коллекции для разных типов объектов
            territoriesCollection = new ymaps.GeoObjectCollection();
            spotCollection = new ymaps.GeoObjectCollection();
            routeCollection = new ymaps.GeoObjectCollection();

            map.geoObjects.add(territoriesCollection);
            map.geoObjects.add(spotCollection);
            map.geoObjects.add(routeCollection);
            
            setTimeout(() => map?.container.fitToViewport(), 100);
        }

        function updateUI() {
            const name = escapeHTML(telegramUser.first_name);
            profileName.textContent = name;
            
            if (telegramUser.photo_url) {
                profileAvatarImg.src = telegramUser.photo_url;
            } else {
                const initial = name.charAt(0).toUpperCase();
                profileAvatarImg.src = `https://placehold.co/96x96/E2E8F0/4A5568?text=${initial}`;
            }
            profileAvatarWrapper.style.borderColor = AppState.userProfile.color;
            updateMapActionButton();
            refreshAllStats();
            renderMyProfileContent();
        }
        
        function updateCurrentUserMarker(latLng) {
            if (!map) return;
            const userAvatarUrl = telegramUser.photo_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${telegramUser.first_name.charAt(0)}`;
            
            const iconLayout = ymaps.templateLayoutFactory.createClass(
                `<div class="avatar-marker current-user-marker" style="background-image: url(${userAvatarUrl}); width: 40px; height: 40px; border-color: ${AppState.userProfile.color};"></div>`
            );
            
            if (AppState.currentUserMarker) {
                AppState.currentUserMarker.geometry.setCoordinates(latLng);
            } else {
                AppState.currentUserMarker = new ymaps.Placemark(latLng, {}, {
                    iconLayout: iconLayout,
                    iconShape: {
                        type: 'Rectangle',
                        coordinates: [[-20, -20], [20, 20]]
                    }
                });
                map.geoObjects.add(AppState.currentUserMarker);
            }
        }
        
        // --- Логика геолокации ---
        async function initializeGeolocation() {
            if (!navigator.geolocation) {
                showCustomAlert("Геолокация не поддерживается вашим устройством.");
                return;
            }

            try {
                const permissionStatus = await navigator.permissions.query({ name: 'geolocation' });

                const handlePermissionChange = () => {
                    if (permissionStatus.state === 'granted') {
                        startGeoTracking();
                    } else {
                        AppState.lastKnownLocation = null;
                        mapActionContainer.classList.add('hidden');
                        modeSwitcher.classList.add('hidden');
                        mapCenterControls.classList.remove('hidden');
                    }
                };

                permissionStatus.onchange = handlePermissionChange;
                handlePermissionChange(); // Initial check

            } catch (e) {
                console.warn("API разрешений не поддерживается, используем старый метод.", e);
                mapCenterControls.classList.remove('hidden');
            }
        }

        function handleGeoRequest() {
            const geoLoader = document.getElementById('request-geo-loader');
            const geoText = document.getElementById('request-geo-text');

            geoText.textContent = 'Ждем ответа...';
            geoLoader.classList.remove('hidden');
            requestGeoBtn.disabled = true;
            
            startGeoTracking();
        }

        function startGeoTracking() {
             navigator.geolocation.getCurrentPosition(
                 (position) => {
                     tg.HapticFeedback.notificationOccurred('success');
                     const latLng = [position.coords.latitude, position.coords.longitude];
                     if (!AppState.lastKnownLocation) {
                         map.panTo(latLng, {flying: true, duration: 1500}).then(() => map.setZoom(16));
                     }
                     AppState.lastKnownLocation = latLng;
                     
                     updateCurrentUserMarker(latLng);

                     mapCenterControls.classList.add('hidden');
                     recenterBtn.classList.remove('hidden');
                     modeSwitcher.classList.remove('hidden');
                     mapActionContainer.classList.remove('hidden');
                     
                     updateMapActionButton();
                     
                     startWatchingLocation();
                 },
                 (error) => {
                     tg.HapticFeedback.notificationOccurred('error');
                     console.error("Geolocation error:", error);
                     showCustomAlert("Не удалось получить геолокацию. Проверьте разрешения в настройках вашего устройства.");
                     const geoText = document.getElementById('request-geo-text');
                     const geoLoader = document.getElementById('request-geo-loader');
                     geoText.textContent = 'Дать доступ к гео';
                     geoLoader.classList.add('hidden');
                     requestGeoBtn.disabled = false;
                 },
                 { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
             );
        }
        
        function startWatchingLocation() {
            if (locationWatchId) {
                navigator.geolocation.clearWatch(locationWatchId);
            }
            locationWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    const latLng = [position.coords.latitude, position.coords.longitude];
                    AppState.lastKnownLocation = latLng;
                    updateCurrentUserMarker(latLng);

                    if (AppState.isRunning && AppState.currentPathPolyline) {
                        const newPoint = [latLng[1], latLng[0]]; // lng, lat для Turf.js
                        AppState.currentRunPath.push(newPoint);
                        AppState.currentPathPolyline.geometry.append(latLng);
                    }
                },
                (error) => {
                    console.warn("Ошибка отслеживания геолокации:", error.message);
                },
                { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
            );
        }


        // --- ЛОГИКА РЕЖИМОВ ---
        
        function startRun() {
            if (!AppState.lastKnownLocation) {
                showCustomAlert("Сначала определите свое местоположение."); return;
            }
            AppState.isRunning = true;
            tg.HapticFeedback.impactOccurred('heavy');
            tg.isClosingConfirmationEnabled = true;
            updateMapActionButton();
            
            AppState.currentRunPath = [ [AppState.lastKnownLocation[1], AppState.lastKnownLocation[0]] ];
            if (AppState.currentPathPolyline) map.geoObjects.remove(AppState.currentPathPolyline);
            AppState.currentPathPolyline = new ymaps.Polyline([AppState.lastKnownLocation], {}, { 
                strokeColor: 'var(--destructive-color)', 
                strokeWidth: 5, 
                strokeOpacity: 0.9 
            });
            map.geoObjects.add(AppState.currentPathPolyline);
        }
        async function stopRun() {
            return new Promise(resolve => {
                showCustomConfirm("Завершить пробежку и захватить территорию?", async () => {
                    AppState.isRunning = false;
                    tg.HapticFeedback.notificationOccurred('success');
                    tg.isClosingConfirmationEnabled = false;
                    updateMapActionButton();
                    if (AppState.currentRunPath.length > 3) {
                        await processRunPath();
                    } else {
                        showCustomAlert('Слишком короткий маршрут для захвата.');
                    }
                    if (AppState.currentPathPolyline) {
                        map.geoObjects.remove(AppState.currentPathPolyline);
                        AppState.currentPathPolyline = null;
                    }
                    resolve();
                });
            });
        }
        
        function handleMapClickForSpot(e) {
            const coords = e.get('coords');
            const locationWKT = `POINT(${coords[1]} ${coords[0]})`;
            showCustomConfirm("Создать новый спот в этом месте?", () => {
                showCreationModal('spot', { location: locationWKT });
            });
        }

        async function saveSpot() {
            const { location } = AppState.currentEditContext;
            const name = document.getElementById('creation-modal-name').value.trim();
            const description = document.getElementById('creation-modal-details').value.trim();
            const file = document.getElementById('creation-modal-photo-input').files[0];

            if (!name || !description) {
                showCustomAlert("Название и описание обязательны."); return;
            }
            
            let photoUrl = null;
            if (file) {
                const filePath = `${telegramUser.id}/spots/${Date.now()}_${file.name}`;
                const { data, error } = await supabase.storage.from('photo').upload(filePath, file);
                if (error) { console.error("Ошибка загрузки фото:", error); showCustomAlert("Ошибка загрузки фото."); return; }
                const { data: urlData } = supabase.storage.from('photo').getPublicUrl(data.path);
                photoUrl = urlData.publicUrl;
            }
            
            const { error } = await supabase.rpc('create_spot', {
                user_id_in: telegramUser.id,
                name_in: name,
                description_in: description,
                photo_url_in: photoUrl,
                location_wkt_in: location
            });

            if (error) {
                console.error("Ошибка сохранения спота:", error); showCustomAlert("Не удалось сохранить спот.");
            } else {
                showCustomAlert("Спот успешно создан!");
                hideCreationModal();
            }
        }
        
        function addSpotToMap(spot) {
            try {
                const wkt = spot.location_wkt || spot.location;
                const geoJsonPoint = parseWKT(wkt);

                if (!geoJsonPoint || geoJsonPoint.type !== 'Point') {
                    console.warn(`Не удалось обработать геолокацию спота ${spot.id}:`, wkt);
                    return;
                }
                
                const coords = [geoJsonPoint.coordinates[1], geoJsonPoint.coordinates[0]]; // lat, long
                const spotPlacemark = new ymaps.Placemark(coords);
                spotPlacemark.events.add('click', () => showDetailModal('spot', spot.id));
                
                spotCollection.add(spotPlacemark);
            } catch (e) {
                console.error(`Ошибка при добавлении спота ${spot.id} на карту.`, e, spot);
            }
        }

        function startRouteRecording() {
            if (!AppState.lastKnownLocation) {
                showCustomAlert("Сначала определите свое местоположение."); return;
            }
            AppState.isRunning = true;
            tg.HapticFeedback.impactOccurred('heavy');
            tg.isClosingConfirmationEnabled = true;
            updateMapActionButton();
            
            AppState.currentRunPath = [ [AppState.lastKnownLocation[1], AppState.lastKnownLocation[0]] ];
            if (AppState.currentPathPolyline) map.geoObjects.remove(AppState.currentPathPolyline);
            AppState.currentPathPolyline = new ymaps.Polyline([AppState.lastKnownLocation], {}, { 
                strokeColor: 'var(--button-color)', 
                strokeWidth: 5, 
                strokeOpacity: 0.9 
            });
            map.geoObjects.add(AppState.currentPathPolyline);
        }

        async function stopRouteRecording() {
             return new Promise(resolve => {
                AppState.isRunning = false;
                tg.HapticFeedback.notificationOccurred('success');
                tg.isClosingConfirmationEnabled = false;
                updateMapActionButton();
                
                if (AppState.currentRunPath.length < 2) {
                    showCustomAlert("Слишком короткий маршрут.");
                    if (AppState.currentPathPolyline) map.geoObjects.remove(AppState.currentPathPolyline);
                    AppState.currentPathPolyline = null;
                    resolve();
                    return;
                }
                
                const pathCoordinates = AppState.currentRunPath.map(p => `${p[0]} ${p[1]}`).join(', ');
                const pathWKT = `LINESTRING(${pathCoordinates})`;
                showCreationModal('route', { path: pathWKT });

                if (AppState.currentPathPolyline) {
                    map.geoObjects.remove(AppState.currentPathPolyline);
                    AppState.currentPathPolyline = null;
                }
                resolve();
            });
        }

        async function saveRoute() {
            const { path } = AppState.currentEditContext;
            const name = document.getElementById('creation-modal-name').value.trim();
            const description = document.getElementById('creation-modal-details').value.trim();
            
            if (!name) { showCustomAlert("Название обязательно."); return; }

            const { error } = await supabase.rpc('create_route', {
                user_id_in: telegramUser.id,
                name_in: name,
                description_in: description,
                path_wkt_in: path
            });

            if (error) {
                console.error("Ошибка сохранения маршрута:", error); showCustomAlert("Не удалось сохранить маршрут.");
            } else {
                showCustomAlert("Маршрут сохранен!");
                hideCreationModal();
            }
        }
        
        function addRouteToMap(route) {
            try {
                const wkt = route.path_wkt || route.path;
                const geoJsonLine = parseWKT(wkt);

                if (!geoJsonLine || geoJsonLine.type !== 'LineString' || !Array.isArray(geoJsonLine.coordinates) || geoJsonLine.coordinates.length < 2) {
                    console.warn(`Не удалось обработать путь для маршрута ${route.id}:`, wkt);
                    return;
                }

                const yandexCoords = geoJsonLine.coordinates.map(c => [c[1], c[0]]); // lat, long
                const routePolyline = new ymaps.Polyline(yandexCoords, {}, {
                    strokeColor: '#ff7800', 
                    strokeWidth: 3
                });
                routePolyline.events.add('click', () => showDetailModal('route', route.id));
                routeCollection.add(routePolyline);
            } catch (e) {
                console.error(`Ошибка при добавлении маршрута ${route.id} на карту.`, e, route);
            }
        }

        // --- ЗАГРУЗКА ДАННЫХ ---
        async function loadInitialMapData() {
            const { data: spots, error: spotsError } = await supabase.from('spots').select('*, location_wkt:location::text');
            if (spotsError) {
                console.error("Ошибка загрузки спотов:", spotsError);
            } else {
                AppState.allSpots = spots;
                spotCollection.removeAll();
                AppState.allSpots.forEach(addSpotToMap);
            }

            const { data: routes, error: routesError } = await supabase.from('routes').select('*, path_wkt:path::text');
            if (routesError) {
                console.error("Ошибка загрузки маршрутов:", routesError);
            } else {
                AppState.allRoutes = routes;
                routeCollection.removeAll();
                AppState.allRoutes.forEach(addRouteToMap);
            }
        }

        // --- SUPABASE и ОБРАБОТЧИКИ ---
        function listenToRealtimeChanges() {
            supabase.channel('public-changes')
              .on('postgres_changes', { event: '*', schema: 'public', table: 'profiles' }, fetchAllProfilesAndDraw)
              .on('postgres_changes', { event: '*', schema: 'public', table: 'posts' }, () => { renderFeed(); renderMyProfileContent(); })
              .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'likes' }, renderFeed)
              .on('postgres_changes', { event: 'DELETE', schema: 'public', table: 'likes' }, renderFeed)
              .on('postgres_changes', { event: '*', schema: 'public', table: 'comments' }, (payload) => {
                  if (commentsModal.classList.contains('visible') && AppState.currentReplyTarget.type === 'post') {
                      const changedPostId = payload.new?.post_id || payload.old?.post_id;
                      if (changedPostId && changedPostId === AppState.currentReplyTarget.id) {
                          showPostComments(AppState.currentReplyTarget.id);
                      }
                  }
                  if (detailModal.classList.contains('visible') && (AppState.currentDetailContext.type === 'spot' || AppState.currentDetailContext.type === 'route')) {
                      const changedParentId = payload.new?.spot_id || payload.new?.route_id || payload.old?.spot_id || payload.old?.route_id;
                      if (changedParentId === AppState.currentDetailContext.id) {
                          loadAndRenderComments(AppState.currentDetailContext.type, AppState.currentDetailContext.id, 'detail-comments-list');
                      }
                  }
                  renderFeed();
              })
              .on('postgres_changes', { event: '*', schema: 'public', table: 'spots' }, () => { loadInitialMapData(); renderMyProfileContent(); })
              .on('postgres_changes', { event: '*', schema: 'public', table: 'routes' }, () => { loadInitialMapData(); renderMyProfileContent(); })
              .subscribe();
        }

        function setupStaticEventListeners() {
            tg.onEvent('themeChanged', () => applyTheme(tg.themeParams));
            tg.onEvent('backButtonClicked', () => {
                if (commentsModal.classList.contains('visible')) {
                    hideCommentsModal();
                } else if (detailModal.classList.contains('visible')) {
                    hideDetailModal();
                } else if (creationModal.classList.contains('visible')) {
                    hideCreationModal();
                } else if (simplePostModal.classList.contains('visible')) {
                    hideSimplePostModal();
                } else if (qrModal.classList.contains('visible')) {
                    hideQrModal();
                }
            });
            tg.onEvent('qrTextReceived', (data) => {
                if (data.data) {
                    try {
                        const url = new URL(data.data);
                        const startPayload = url.searchParams.get('startapp');
                        if (startPayload) {
                            handleStartParam({ start_param: startPayload });
                        }
                    } catch (e) {
                        console.error("Invalid QR code data", e);
                        showCustomAlert("Неверный QR-код.");
                    }
                }
            });
            tg.SettingsButton.onClick(() => {
                tg.HapticFeedback.impactOccurred('light');
                tg.openTelegramLink(`https://t.me/${BOT_USERNAME}`);
            });
        }

        function setupDynamicEventListeners() {
            document.getElementById('mode-capture').addEventListener('click', () => setMode('capture'));
            document.getElementById('mode-spots').addEventListener('click', () => setMode('spots'));
            document.getElementById('mode-routes').addEventListener('click', () => setMode('routes'));
            
            document.getElementById('save-creation-btn').addEventListener('click', handleSave);
            
            document.getElementById('creation-modal-photo-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const preview = document.getElementById('creation-modal-photo-preview');
                    preview.src = URL.createObjectURL(file);
                    preview.classList.remove('hidden');
                    document.getElementById('creation-modal-photo-icon').classList.add('hidden');
                }
            });
            document.getElementById('simple-post-photo-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    document.getElementById('simple-post-filename').textContent = file.name;
                }
            });

            requestGeoBtn.addEventListener('click', handleGeoRequest);

            recenterBtn.addEventListener('click', () => {
                tg.HapticFeedback.impactOccurred('medium');
                if (AppState.lastKnownLocation) map.panTo(AppState.lastKnownLocation, {flying: true});
            });
            
            scanQrBtn.addEventListener('click', () => {
                tg.HapticFeedback.impactOccurred('light');
                tg.showScanQrPopup({ text: 'Наведите на QR-код другого игрока' });
            });

            shareProfileBtn.addEventListener('click', () => {
                shareContent('user', telegramUser.id, telegramUser.id);
            });
            
            createSimplePostBtn.addEventListener('click', showSimplePostModal);
            
            showQrBtn.addEventListener('click', showQrModal);

            mapActionBtn.addEventListener('click', mapActionButtonHandler);
            

            document.body.addEventListener('click', (event) => {
                const button = event.target.closest('button[data-action], div[data-action]');
                if (!button) return;

                const action = button.dataset.action;
                const id = button.dataset.id || button.dataset.postId;

                if (!action || !id) return;

                if (action === 'like') {
                    toggleLike(button, id);
                } else if (action === 'comment' || action === 'show-post-comments') {
                    showPostComments(id);
                }
            });

            // Добавляем обработчики свайпов для модальных окон
            makeModalSwipeable(creationModal, creationModal.querySelector('.bottom-sheet-content'), hideCreationModal);
            makeModalSwipeable(detailModal, detailModal.querySelector('.bottom-sheet-content'), hideDetailModal);
            makeModalSwipeable(commentsModal, commentsModal.querySelector('.bottom-sheet-content'), hideCommentsModal);
        }
        
        function showFallbackScreen(title, message, showRetryButton = false) {
            fallbackContent.innerHTML = `
                <h1 class="text-2xl font-bold mb-4 ${showRetryButton ? 'text-red-500' : ''}">${escapeHTML(title)}</h1>
                <p class="mb-6" style="color: var(--hint-color);">${escapeHTML(message)}</p>
                ${showRetryButton ? `<button onclick="window.location.reload()" class="font-bold py-3 px-6 rounded-full" style="background-color: var(--button-color); color: var(--button-text-color);">Попробовать снова</button>` : ''}
            `;
            initialLoader.classList.add('hidden');
            fallbackScreen.classList.remove('hidden');
        }

        function applyTheme(themeParams) {
             const root = document.documentElement;
             root.style.setProperty('--bg-color', themeParams.bg_color || '#f3f4f6');
             root.style.setProperty('--secondary-bg-color', themeParams.secondary_bg_color || '#ffffff');
             root.style.setProperty('--text-color', themeParams.text_color || '#1f2937');
             root.style.setProperty('--hint-color', themeParams.hint_color || '#6b7280');
             root.style.setProperty('--button-color', themeParams.button_color || '#3b82f6');
             root.style.setProperty('--button-text-color', themeParams.button_text_color || '#ffffff');
             root.style.setProperty('--border-color', themeParams.bg_color ? shadeColor(themeParams.bg_color, -10) : '#e5e7eb');
             
             const buttonColorRgb = hexToRgb(themeParams.button_color || '#3b82f6');
             if (buttonColorRgb) {
                root.style.setProperty('--button-color-rgb', buttonColorRgb.join(', '));
             }
             const secondaryBgRgb = hexToRgb(themeParams.secondary_bg_color || '#ffffff');
             if (secondaryBgRgb) {
                root.style.setProperty('--secondary-bg-color-rgb', secondaryBgRgb.join(', '));
             }

             tg.setHeaderColor(themeParams.secondary_bg_color || '#ffffff');
             tg.setBackgroundColor(themeParams.bg_color || '#f3f4f6');
        }
        
        async function upsertUserProfile() {
            if (!telegramUser) throw new Error("Пользователь Telegram не определен для upsertUserProfile.");

            const { data, error } = await supabase.from('profiles').select('*').eq('id', telegramUser.id).single();
            
            if (error && error.code !== 'PGRST116') {
                console.error("Ошибка получения профиля:", error); 
                throw error; 
            } 
            
            if (data) {
                AppState.userProfile.color = data.color;
                AppState.userProfile.territory = parseWKT(data.territory_wkt) || parseWKT(data.territory) || data.territory;
            } else {
                AppState.userProfile.color = generateColorFromId(telegramUser.id);
                const { error: insertError } = await supabase.from('profiles').insert({ 
                    id: telegramUser.id, 
                    name: telegramUser.first_name, 
                    color: AppState.userProfile.color, 
                    area: 0, 
                    photo_url: telegramUser.photo_url || null, 
                    territory: null 
                });
                if (insertError) { 
                    console.error("Ошибка создания профиля:", insertError); 
                    throw insertError; 
                }
            }
        }
        
        async function processRunPath() {
            const startPoint = AppState.currentRunPath[0];
            const endPoint = AppState.currentRunPath[AppState.currentRunPath.length - 1];
            const distance = turf.distance(turf.point(startPoint), turf.point(endPoint), { units: 'meters' });
            if (distance > 50) {
                showCustomAlert('Маршрут не замкнут. Вернитесь к точке старта (в радиус 50м) для захвата.');
                return;
            }
            AppState.currentRunPath.push(startPoint);
            const line = turf.lineString(AppState.currentRunPath);
            const polygonized = turf.polygonize(line);
            if (polygonized.features.length === 0) {
                showCustomAlert('Не удалось сформировать замкнутую территорию. Вероятно, маршрут пересекал сам себя.');
                return;
            }
            let newCapture = polygonized.features[0];
            if (polygonized.features.length > 1) {
                try {
                    newCapture = turf.union(...polygonized.features);
                } catch (e) {
                    console.error("Turf union error:", e);
                }
            }
            await updateTerritory(newCapture);
        }

        async function updateTerritory(newCapture) {
            try {
                let combinedTerritory = AppState.userProfile.territory ? turf.union(AppState.userProfile.territory, newCapture) : newCapture;
                AppState.userProfile.territory = turf.cleanCoords(combinedTerritory);
                
                await saveUserData();
                refreshAllStats();
                tg.HapticFeedback.notificationOccurred('success');
                const area = turf.area(newCapture);
                const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;
                showCreationModal('post', { 
                    captureData: newCapture,
                    area_captured: area,
                    area_captured_formatted: formattedArea
                });
            } catch (error) {
                console.error("Ошибка в updateTerritory:", error);
                showCustomAlert("Ошибка обработки территории.");
            }
        }

        async function saveUserData() {
            let area = AppState.userProfile.territory ? turf.area(AppState.userProfile.territory) : 0;
            const userData = { id: telegramUser.id, name: telegramUser.first_name, photo_url: telegramUser.photo_url || null, color: AppState.userProfile.color, territory: AppState.userProfile.territory, area: area, updated_at: new Date().toISOString() };
            const { error } = await supabase.from('profiles').upsert(userData);
            if (error) console.error('Error saving user data:', error);
        }

        async function handlePostSubmission() {
            const { captureData, area_captured } = AppState.currentEditContext;
            const title = document.getElementById('creation-modal-name').value.trim();
            
            if (!title) { showCustomAlert("Пожалуйста, введите название."); return; }

            let photoUrl = null;
            const file = document.getElementById('creation-modal-photo-input').files[0];
            if (file) {
                const filePath = `${telegramUser.id}/${Date.now()}_${file.name}`;
                const { data, error } = await supabase.storage.from('photo').upload(filePath, file);
                if (error) { console.error("Error uploading photo:", error); showCustomAlert("Не удалось загрузить фото."); return; }
                photoUrl = supabase.storage.from('photo').getPublicUrl(data.path).data.publicUrl;
            }

            const postData = {
                user_id: telegramUser.id,
                title: title,
                description: null,
                photo_url: photoUrl,
                territory_captured: captureData,
                area_captured: area_captured,
                user_name: telegramUser.first_name,
                user_avatar_url: telegramUser.photo_url,
                user_color: AppState.userProfile.color
            };

            const { error: postError } = await supabase.from('posts').insert(postData);
            
            if (postError) {
                console.error("Error saving post:", postError); showCustomAlert("Не удалось сохранить пост.");
            } else {
                showCustomAlert("Пост успешно опубликован!");
                hideCreationModal();
            }
        }
        
        async function handleSimplePostSave() {
            const description = document.getElementById('simple-post-details').value.trim();
            if (!description) {
                showCustomAlert("Пожалуйста, введите текст поста.");
                return;
            }

            let photoUrl = null;
            const file = document.getElementById('simple-post-photo-input').files[0];
            if (file) {
                const filePath = `${telegramUser.id}/posts/${Date.now()}_${file.name}`;
                const { data, error } = await supabase.storage.from('photo').upload(filePath, file);
                if (error) { console.error("Error uploading photo:", error); showCustomAlert("Не удалось загрузить фото."); return; }
                photoUrl = supabase.storage.from('photo').getPublicUrl(data.path).data.publicUrl;
            }

            const postData = {
                user_id: telegramUser.id,
                title: description.substring(0, 50) + (description.length > 50 ? '...' : ''),
                description: description,
                photo_url: photoUrl,
                user_name: telegramUser.first_name,
                user_avatar_url: telegramUser.photo_url,
                user_color: AppState.userProfile.color
            };

            const { error: postError } = await supabase.from('posts').insert(postData);
            
            if (postError) {
                console.error("Error saving post:", postError); showCustomAlert("Не удалось сохранить пост.");
            } else {
                showCustomAlert("Пост успешно опубликован!");
                hideSimplePostModal();
            }
        }


        async function fetchAllProfilesAndDraw() {
            let { data: profiles, error } = await supabase.from('profiles').select('*, territory_wkt:territory::text');
            if (error) { console.error("Error fetching profiles:", error); return; }
            AppState.allProfilesData = profiles;
            
            territoriesCollection.removeAll();
            AppState.allUserLayers = {};

            profiles.forEach(profile => {
                if (telegramUser && profile.id === telegramUser.id) {
                    AppState.userProfile.territory = parseWKT(profile.territory_wkt) || profile.territory;
                    AppState.userProfile.color = profile.color;
                    refreshAllStats();
                }
                const territoryGeoJson = parseWKT(profile.territory_wkt || profile.territory);
                if (territoryGeoJson) {
                    const territoryObject = ymaps.geoQuery(territoryGeoJson).addTo(territoriesCollection);
                    territoryObject.setOptions({
                        fillColor: profile.color,
                        fillOpacity: 0.4,
                        strokeColor: profile.color,
                        strokeWidth: 2,
                        strokeOpacity: 0.8
                    });
                }
            });
            updateLeaderboard(profiles);
        }

        function updateLeaderboard(profiles) {
            profiles.sort((a, b) => (b.area || 0) - (a.area || 0));
            leaderboardDiv.innerHTML = profiles.map((u, index) => {
                const isCurrentUser = telegramUser && u.id === telegramUser.id;
                const name = escapeHTML(u.name);
                const displayName = isCurrentUser ? `${name} (Вы)` : name;
                const avatar = u.photo_url || `https://placehold.co/50x50/E5E7EB/4B5563?text=${name.charAt(0)}`;
                const area = u.area || 0;
                const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;
                return `<div class="card-bg rounded-xl shadow-md p-4 flex items-center space-x-4 cursor-pointer hover:bg-gray-50 transition" onclick="showDetailModal('user', ${u.id})">
                            <span class="text-xl font-bold w-8" style="color: var(--hint-color);">${index + 1}</span>
                            <img src="${avatar}" class="w-12 h-12 rounded-full" alt="avatar">
                            <div class="flex-grow">
                                <p class="font-bold">${displayName}</p>
                                <p class="text-sm" style="color: var(--hint-color);">${formattedArea}</p>
                            </div>
                        </div>`
            }).join('');
        }

        function refreshAllStats() {
            let area = 0;
            if (AppState.userProfile.territory) {
                try {
                    area = turf.area(AppState.userProfile.territory);
                } catch(e) {
                    console.warn("Could not calculate area for user territory", e);
                    area = 0;
                }
            }
            if (isNaN(area)) area = 0;
            const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;
            profileAreaDisplay.textContent = formattedArea;
        }

        async function renderFeed() {
            const { data: posts, error: postsError } = await supabase.from('posts').select('*').order('created_at', { ascending: false });
            if (postsError) { console.error("Error fetching posts:", postsError); return; }
            const postIds = posts.map(p => p.id);
            if (postIds.length === 0) {
                feedContainer.innerHTML = '<p class="text-center text-gray-500">В ленте пока нет постов.</p>';
                return;
            }
            const { data: likes, error: likesError } = await supabase.from('likes').select('*').in('post_id', postIds);
            const { data: comments, error: commentsError } = await supabase.from('comments').select('id, post_id').in('post_id', postIds);
            if (likesError || commentsError) { console.error("Error fetching activity:", likesError, commentsError); return; }
            const likesByPost = likes.reduce((acc, like) => { (acc[like.post_id] = acc[like.post_id] || []).push(like); return acc; }, {});
            const commentsByPost = comments.reduce((acc, comment) => { (acc[comment.post_id] = acc[comment.post_id] || []).push(comment); return acc; }, {});
            
            const feedHTML = posts.map(post => generatePostHTML(post, likesByPost[post.id] || [], commentsByPost[post.id] || [])).join('');
            feedContainer.innerHTML = feedHTML || '<p class="text-center text-gray-500">В ленте пока нет постов.</p>';
            
            posts.forEach(post => {
                if (post.territory_captured) {
                    const mapContainer = document.getElementById(`mini-map-${post.id}`);
                    if (mapContainer) {
                         const miniMap = new ymaps.Map(mapContainer, { center: [55.75, 37.62], zoom: 9, controls: [] });
                         const territoryObject = ymaps.geoQuery(post.territory_captured).addTo(miniMap);
                         territoryObject.setOptions({
                             fillColor: post.user_color,
                             fillOpacity: 0.5,
                             strokeColor: post.user_color,
                             strokeWidth: 2,
                             strokeOpacity: 0.8
                         });
                         miniMap.setBounds(territoryObject.getBounds(), { checkZoomRange: true, zoomMargin: 10 });
                    }
                }
            });

            if (scrollToPostId) {
                const postElement = document.getElementById(`post-${scrollToPostId}`);
                if (postElement) {
                    setTimeout(() => {
                        postElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        postElement.style.transition = 'background-color 0.5s ease';
                        postElement.style.backgroundColor = 'rgba(var(--button-color-rgb), 0.15)';
                        setTimeout(() => {
                            postElement.style.backgroundColor = '';
                        }, 2500);
                    }, 200);
                }
                scrollToPostId = null;
            }
        }
        
        function generatePostHTML(post, likes, comments) {
            const avatar = post.user_avatar_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${post.user_name.charAt(0)}`;
            const area = post.area_captured || 0;
            const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;
            const userHasLiked = telegramUser && likes.some(like => like.user_id === telegramUser.id);
            return `<div class="card-bg rounded-2xl shadow-lg overflow-hidden" id="post-${post.id}">
                        <div class="p-4">
                            <div class="flex items-center space-x-3 cursor-pointer" onclick="showDetailModal('user', ${post.user_id})"><img src="${avatar}" class="w-10 h-10 rounded-full" alt="avatar"><div><p class="font-bold">${escapeHTML(post.user_name)}</p><p class="text-xs" style="color: var(--hint-color);">${new Date(post.created_at).toLocaleString('ru-RU')}</p></div></div>
                            <p class="mt-4 font-semibold">${escapeHTML(post.title)}</p>
                            ${post.description ? `<p class="mt-2 text-sm" style="color: var(--text-color);">${escapeHTML(post.description)}</p>` : ''}
                        </div>
                        ${post.photo_url ? `<img src="${post.photo_url}" class="w-full h-64 object-cover" alt="Post photo">` : ''}
                        ${post.territory_captured ? `<div id="mini-map-${post.id}" class="h-48 w-full mini-map"></div>` : ''}
                        <div class="p-4">
                            ${post.area_captured ? `<p class="font-semibold">Захвачено: <span class="font-bold" style="color: var(--button-color);">${formattedArea}</span></p>` : ''}
                            <div class="flex items-center justify-between mt-3">
                                <div class="flex items-center space-x-6" style="color: var(--hint-color);">
                                    <button class="like-btn flex items-center space-x-1 hover:text-red-500 transition ${userHasLiked ? 'liked' : ''}" data-action="like" data-post-id="${post.id}">
                                        <i class="fa-${userHasLiked ? 'solid' : 'regular'} fa-heart h-6 w-6"></i>
                                        <span data-likes-count>${likes.length}</span>
                                    </button>
                                    <button class="flex items-center space-x-1 hover:text-blue-500 transition" data-action="comment" data-post-id="${post.id}">
                                        <i class="fa-regular fa-comment h-6 w-6"></i>
                                        <span>${comments.length}</span>
                                    </button>
                                </div>
                                <button class="flex items-center space-x-1 hover:text-blue-500 transition" onclick="shareContent('post', ${post.id}, ${post.user_id})" style="color: var(--hint-color);">
                                    <i class="fa-solid fa-arrow-up-from-bracket h-5 w-5"></i>
                                </button>
                            </div>
                        </div>
                    </div>`;
        }

        async function toggleLike(buttonElement, postId) {
            if (!telegramUser) {
                showCustomAlert('Пользователь не определен. Попробуйте перезагрузить приложение.');
                return;
            }
            tg.HapticFeedback.impactOccurred('light');
            
            const hasLiked = buttonElement.classList.contains('liked');
            const countSpan = buttonElement.querySelector('[data-likes-count]');
            const icon = buttonElement.querySelector('i');
            let currentCount = parseInt(countSpan.textContent, 10);

            buttonElement.classList.toggle('liked');
            icon.classList.toggle('fa-solid', !hasLiked);
            icon.classList.toggle('fa-regular', hasLiked);
            countSpan.textContent = hasLiked ? currentCount - 1 : currentCount + 1;

            try {
                if (hasLiked) {
                    await supabase.from('likes').delete().match({ post_id: postId, user_id: telegramUser.id });
                } else {
                    await supabase.from('likes').insert({ post_id: postId, user_id: telegramUser.id });
                }
            } catch (error) {
                console.error("Ошибка лайка:", error);
                buttonElement.classList.toggle('liked');
                icon.classList.toggle('fa-solid');
                icon.classList.toggle('fa-regular');
                countSpan.textContent = currentCount;
                showCustomAlert('Не удалось поставить лайк. Попробуйте снова.');
            }
        }
        
        // --- СИСТЕМА КОММЕНТАРИЕВ ---

        async function fetchComments(type, id) {
            let query = supabase.from('comments').select('*, profiles(id, name, photo_url)');
            if (type === 'post') {
                query = query.eq('post_id', id);
            } else if (type === 'spot') {
                query = query.eq('spot_id', id);
            } else if (type === 'route') {
                query = query.eq('route_id', id);
            }
            const { data, error } = await query.order('created_at', { ascending: true });
            return { data, error };
        }
        
        async function showPostComments(postId) {
            tg.HapticFeedback.impactOccurred('medium');
            tg.BackButton.show();
            AppState.currentReplyTarget = { type: 'post', id: postId, parentCommentId: null };
            cancelReply();
            
            const modalBody = document.getElementById('comments-modal-body');
            modalBody.innerHTML = '<div class="text-center p-8"><svg class="animate-spin mx-auto h-8 w-8 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></div>';
            commentsModal.classList.add('visible');
            
            const { data: comments, error } = await fetchComments('post', postId);
            if (error) { modalBody.innerHTML = `<p class="text-center p-4 text-red-500">Ошибка загрузки комментариев</p>`; return; }

            renderCommentTree(comments, modalBody);
        }

        async function loadAndRenderComments(type, id, containerId) {
             const container = document.getElementById(containerId);
             if (!container) return;
             container.innerHTML = '<p class="text-center text-gray-500">Загрузка комментариев...</p>';
             
             const { data: comments, error } = await fetchComments(type, id);
             if (error) { container.innerHTML = `<p class="text-center p-4 text-red-500">Ошибка загрузки комментариев</p>`; return; }

             renderCommentTree(comments, container, 'detail');
        }

        function renderCommentTree(comments, container, context = 'post') {
            const commentsByParent = comments.reduce((acc, comment) => { (acc[comment.parent_comment_id || 'root'] = acc[comment.parent_comment_id || 'root'] || []).push(comment); return acc; }, {});
            const rootComments = commentsByParent['root'] || [];
            container.innerHTML = rootComments.length ? rootComments.map(c => generateCommentHTML(c, commentsByParent, context)).join('') : '<p class="text-center text-gray-500 py-4">Нет комментариев</p>';
        }

        function hideCommentsModal() {
            tg.BackButton.hide();
            commentsModal.classList.remove('visible');
        }

        function generateCommentHTML(comment, commentsByParent, context = 'post') {
            const replies = commentsByParent[comment.id] || [];
            const profileName = comment.profiles ? escapeHTML(comment.profiles.name) : 'Аноним';
            const avatar = comment.profiles ? (comment.profiles.photo_url || `https://placehold.co/32x32/E5E7EB/4B5563?text=${profileName.charAt(0)}`) : 'https://placehold.co/32x32';
            const replyFn = context === 'post' ? 'setReplyMode' : 'setDetailReplyMode';
            const parentId = comment.post_id || comment.spot_id || comment.route_id;

            return `<div class="flex items-start space-x-3 mt-4">
                        <img src="${avatar}" class="w-8 h-8 rounded-full">
                        <div class="flex-1">
                            <div class="rounded-lg p-2" style="background-color: var(--bg-color);">
                                <p class="font-bold text-sm">${profileName}</p>
                                <p class="text-sm">${escapeHTML(comment.content)}</p>
                            </div>
                            <div class="text-xs mt-1">
                                <button onclick="${replyFn}('${parentId}', ${comment.id}, '${profileName.replace(/'/g, "\\'")}')" class="font-medium" style="color: var(--hint-color);">Ответить</button>
                            </div>
                            <div class="pl-4 border-l-2">${replies.map(reply => generateCommentHTML(reply, commentsByParent, context)).join('')}</div>
                        </div>
                    </div>`;
        }
        
        function setReplyMode(postId, parentCommentId, parentAuthorName) {
            AppState.currentReplyTarget = { type: 'post', id: postId, parentCommentId };
            document.getElementById('reply-indicator-text').textContent = `Ответ: ${parentAuthorName}`;
            document.getElementById('reply-indicator').classList.remove('hidden');
            document.getElementById('main-comment-input').focus();
        }

        function cancelReply() {
            AppState.currentReplyTarget.parentCommentId = null;
            document.getElementById('reply-indicator').classList.add('hidden');
        }

        async function postComment() {
            const { type, id, parentCommentId } = AppState.currentReplyTarget;
            if (!id || !telegramUser) return;
            const inputElement = document.getElementById('main-comment-input');
            const content = inputElement.value.trim();
            if (!content) return;
            
            const commentData = { 
                post_id: id,
                user_id: telegramUser.id, 
                parent_comment_id: parentCommentId, 
                content: content 
            };
            const { error } = await supabase.from('comments').insert(commentData);
            if (error) { showCustomAlert('Ошибка отправки'); } else { inputElement.value = ''; cancelReply(); }
        }

        function setDetailReplyMode(id, parentCommentId, parentAuthorName) {
            AppState.currentDetailContext.replyTo = { parentCommentId };
            document.getElementById('detail-reply-indicator-text').textContent = `Ответ: ${parentAuthorName}`;
            document.getElementById('detail-reply-indicator').classList.remove('hidden');
            document.getElementById('detail-comment-input').focus();
        }
        
        function cancelDetailReply() {
            AppState.currentDetailContext.replyTo = null;
            document.getElementById('detail-reply-indicator').classList.add('hidden');
        }

        async function postDetailComment() {
            const { type, id, replyTo } = AppState.currentDetailContext;
            if (!id || !telegramUser) return;
            const inputElement = document.getElementById('detail-comment-input');
            const content = inputElement.value.trim();
            if (!content) return;

            const parentCommentId = replyTo ? replyTo.parentCommentId : null;

            const commentData = {
                user_id: telegramUser.id,
                parent_comment_id: parentCommentId,
                content: content
            };
            if (type === 'spot') {
                commentData.spot_id = id;
            } else if (type === 'route') {
                commentData.route_id = id;
            }

            const { error } = await supabase.from('comments').insert(commentData);

            if (error) { 
                showCustomAlert('Ошибка отправки комментария.'); 
                console.error("Comment post error:", error);
            } else { 
                inputElement.value = ''; 
                cancelDetailReply();
                loadAndRenderComments(type, id, 'detail-comments-list');
            }
        }


        function switchMainProfileTab(tabName) {
            document.querySelectorAll('#profile-view .profile-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('#profile-view .profile-tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`profile-tab-${tabName}`).classList.add('active');
            document.getElementById(`profile-content-${tabName}`).classList.add('active');
        }

        async function renderMyProfileContent() {
            if (!telegramUser) return;
            const userId = telegramUser.id;

            const [postsRes, spotsRes, routesRes] = await Promise.all([
                supabase.from('posts').select('*').eq('user_id', userId).order('created_at', { ascending: false }),
                supabase.from('spots').select('*, location_wkt:location::text').eq('user_id', userId).order('created_at', { ascending: false }),
                supabase.from('routes').select('*, path_wkt:path::text').eq('user_id', userId).order('created_at', { ascending: false })
            ]);

            const posts = postsRes.data || [];
            const postIds = posts.map(p => p.id);
            const likesByPost = {};
            const commentsByPost = {};
            if (postIds.length > 0) {
                const { data: likes } = await supabase.from('likes').select('*').in('post_id', postIds);
                const { data: comments } = await supabase.from('comments').select('id, post_id').in('post_id', postIds);
                if(likes) likes.forEach(like => (likesByPost[like.post_id] = likesByPost[like.post_id] || []).push(like));
                if(comments) comments.forEach(comment => (commentsByPost[comment.post_id] = commentsByPost[comment.post_id] || []).push(comment));
            }
            const postsContainer = document.getElementById('profile-content-posts');
            postsContainer.innerHTML = posts.length > 0 ? posts.map(p => generatePostHTML(p, likesByPost[p.id] || [], commentsByPost[p.id] || [])).join('') : '<p class="text-center text-gray-500 py-4">У вас нет постов.</p>';
            document.getElementById('profile-tab-posts').textContent = `Посты (${posts.length})`;

            const spots = spotsRes.data || [];
            const spotsContainer = document.getElementById('profile-content-spots');
            spotsContainer.innerHTML = spots.length > 0 ? spots.map(generateMiniSpotHTML).join('') : '<p class="text-center text-gray-500 py-4">У вас нет спотов.</p>';
            document.getElementById('profile-tab-spots').textContent = `Споты (${spots.length})`;

            const routes = routesRes.data || [];
            const routesContainer = document.getElementById('profile-content-routes');
            routesContainer.innerHTML = routes.length > 0 ? routes.map(generateMiniRouteHTML).join('') : '<p class="text-center text-gray-500 py-4">У вас нет маршрутов.</p>';
            document.getElementById('profile-tab-routes').textContent = `Маршруты (${routes.length})`;
        }
        
        // --- QR Code Modal ---
        function showQrModal() {
            tg.HapticFeedback.impactOccurred('light');
            const qrContainer = document.getElementById('qrcode');
            qrContainer.innerHTML = '';
            new QRCode(qrContainer, {
                text: `https://t.me/${BOT_USERNAME}?startapp=user_${telegramUser.id}`,
                width: 200,
                height: 200,
                colorDark : "#000000",
                colorLight : "#ffffff",
                correctLevel : QRCode.CorrectLevel.H
            });
            qrModal.classList.add('visible');
            tg.BackButton.show();
        }

        function hideQrModal() {
            qrModal.classList.remove('visible');
            tg.BackButton.hide();
        }
        
        // --- Handle Start Param ---
        function handleStartParam() {
            const startParam = tg.initDataUnsafe.start_param;
            if (!startParam) return;

            const parts = startParam.split('_');
            const type = parts.length > 1 ? parts[0] : 'user'; // Default to 'user' for old links
            const id = parts.length > 1 ? parts[1] : startParam;
            const numericId = parseInt(id, 10);

            if (isNaN(numericId)) {
                console.warn("Invalid ID in start_param:", startParam);
                return;
            }

            setTimeout(() => {
                switch (type) {
                    case 'user':
                        showDetailModal('user', numericId);
                        break;
                    case 'post':
                        showView('feed-view');
                        scrollToPostId = numericId;
                        break;
                    case 'route':
                        showDetailModal('route', numericId);
                        break;
                    case 'spot':
                        showDetailModal('spot', numericId);
                        break;
                    default:
                        console.warn("Unknown start_param type:", type);
                        if (/^\d+$/.test(startParam)) {
                            showDetailModal('user', parseInt(startParam));
                        }
                }
            }, 500); 
        }
        
        // --- Custom Alert/Confirm ---
        function showCustomAlert(message) {
            tg.showAlert(message);
        }

        function showCustomConfirm(message, callback) {
            tg.showConfirm(message, (ok) => {
                if (ok) callback();
            });
        }

        // Функция для свайпа модальных окон
        function makeModalSwipeable(modalElement, contentElement, closeCallback) {
            let startY, currentY, isDragging = false;

            const onTouchStart = (e) => {
                if (e.target.classList.contains('grabber') || e.touches[0].clientY < contentElement.offsetTop + 40) {
                    isDragging = true;
                    startY = e.touches[0].clientY;
                    contentElement.style.transition = 'none';
                }
            };

            const onTouchMove = (e) => {
                if (!isDragging) return;
                currentY = e.touches[0].clientY;
                let deltaY = currentY - startY;
                if (deltaY > 0) { // Только свайп вниз
                    contentElement.style.transform = `translateY(${deltaY}px)`;
                }
            };

            const onTouchEnd = (e) => {
                if (!isDragging) return;
                isDragging = false;
                let deltaY = currentY - startY;
                contentElement.style.transition = 'transform 0.3s ease-in-out';
                if (deltaY > contentElement.clientHeight * 0.3) {
                    closeCallback();
                } else {
                    contentElement.style.transform = 'translateY(0)';
                }
            };
            
            modalElement.addEventListener('touchstart', onTouchStart, { passive: true });
            modalElement.addEventListener('touchmove', onTouchMove, { passive: true });
            modalElement.addEventListener('touchend', onTouchEnd, { passive: true });
        }


        // --- ПРИВЯЗКА ГЛОБАЛЬНЫХ ФУНКЦИЙ И ЗАПУСК ---
        window.showView = showView;
        window.hideDetailModal = hideDetailModal;
        window.toggleLike = toggleLike;
        window.showPostComments = showPostComments;
        window.hideCommentsModal = hideCommentsModal;
        window.setReplyMode = setReplyMode;
        window.cancelReply = cancelReply;
        window.postComment = postComment;
        window.showDetailModal = showDetailModal;
        window.switchProfileTab = switchProfileTab;
        window.switchMainProfileTab = switchMainProfileTab;
        window.navigateToMapObject = navigateToMapObject;
        window.hideSimplePostModal = hideSimplePostModal;
        window.handleSimplePostSave = handleSimplePostSave;
        window.hideCreationModal = hideCreationModal;
        window.postDetailComment = postDetailComment;
        window.setDetailReplyMode = setDetailReplyMode;
        window.cancelDetailReply = cancelDetailReply;
        window.hideQrModal = hideQrModal;
        window.shareContent = shareContent;
        
        // Запускаем приложение после загрузки API Яндекс Карт
        document.addEventListener('DOMContentLoaded', () => ymaps.ready(runApp));
    </script>

</body>
</html>
