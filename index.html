<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>TerraRun | Обновление</title>

    <!-- Подключение Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- ПОДКЛЮЧЕНИЕ YANDEX MAPS API -->
    <script src="https://api-maps.yandex.ru/2.1/?apikey=6559b722-5ab3-4376-b85c-ce2c99df7d46&lang=ru_RU" type="text/javascript"></script>

    <!-- Подключение Turf.js для гео-анализа -->
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
    
    <!-- Подключение Telegram Web App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- Подключение Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <!-- Подключение QR Code Generator -->
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

    <!-- Иконочные шрифты -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">
    
    <!-- Шрифты Google -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #f3f4f6;
            --secondary-bg-color: #ffffff;
            --text-color: #1f2937;
            --hint-color: #6b7280;
            --button-color: #3b82f6;
            --button-text-color: #ffffff;
            --destructive-color: #ef4444;
            --success-color: #22c55e;
            --star-color: #facc15;
            --border-color: #e5e7eb;
            --button-color-rgb: 59, 130, 246;
            --secondary-bg-color-rgb: 255, 255, 255;
        }

        /* Адаптация под безопасные зоны iOS */
        body {
            padding-top: constant(safe-area-inset-top);
            padding-top: env(safe-area-inset-top);
        }

        body {
            overscroll-behavior: none;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            font-family: 'Inter', sans-serif;
        }
        .mini-map, #detail-mini-map, #event-map-picker {
            z-index: 10;
            background-color: var(--bg-color);
        }
        
        #map {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        .view {
            display: none;
            height: 100vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            transition: opacity 0.3s ease-in-out;
            background-color: var(--bg-color);
            box-sizing: border-box;
        }
        
        #feed-view, #top-view, #profile-view {
            padding-bottom: calc(80px + 1rem + env(safe-area-inset-bottom));
        }

        .view.active {
            display: block;
        }
        .nav-btn.active i, .nav-btn.active span {
            color: var(--button-color);
        }
        .nav-btn span, .nav-btn i {
             color: var(--hint-color);
        }
        .card-bg {
            background-color: var(--secondary-bg-color);
        }
        #bottom-navbar {
            height: calc(80px + env(safe-area-inset-bottom));
            padding-bottom: env(safe-area-inset-bottom);
            background-color: rgba(var(--secondary-bg-color-rgb), 0.8);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-top: 1px solid var(--border-color);
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .avatar-marker {
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 15px rgba(0,0,0,0.4);
            background-size: cover;
            background-position: center;
            transition: transform 0.2s ease-in-out, left 0.5s linear, top 0.5s linear;
        }
        .avatar-marker:hover {
            transform: scale(1.1);
        }
        .current-user-marker {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 2px 15px rgba(0,0,0,0.4), 0 0 0 0 rgba(var(--button-color-rgb), 0.7); }
            70% { box-shadow: 0 2px 15px rgba(0,0,0,0.4), 0 0 0 15px rgba(var(--button-color-rgb), 0); }
            100% { box-shadow: 0 2px 15px rgba(0,0,0,0.4), 0 0 0 0 rgba(var(--button-color-rgb), 0); }
        }
        .like-btn.liked i {
            color: var(--destructive-color);
            font-weight: 900; /* Solid heart */
        }
        #initial-loader {
            background-color: var(--bg-color);
        }
        #map-top-panel {
            position: fixed;
            top: calc(1rem + env(safe-area-inset-top));
            left: 0;
            right: 0;
            z-index: 20;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0 1rem;
            pointer-events: none;
        }
        #mode-switcher {
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 9999px;
            padding: 0.25rem;
            display: flex;
            gap: 0.25rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            pointer-events: all;
        }
        #map-controls-right {
            pointer-events: all;
        }
        .mode-btn {
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--hint-color);
            transition: all 0.2s ease-in-out;
            border: none;
            background-color: transparent;
        }
        .mode-btn.active {
            background-color: var(--button-color);
            color: var(--button-text-color);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        #map-action-container {
            position: fixed;
            left: 0;
            right: 0;
            z-index: 20;
            display: flex;
            justify-content: center;
            pointer-events: none;
            bottom: calc(80px + 1rem + env(safe-area-inset-bottom));
            transition: bottom 0.3s ease-in-out;
        }
        
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0,0,0,0.4);
            display: flex;
            z-index: 50;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        /* FIX: Prevent background scroll when modal is open */
        body.modal-open .view.active {
            overflow-y: hidden;
        }

        .bottom-sheet-modal {
            align-items: flex-end;
        }
        .bottom-sheet-content {
            width: 100%;
            background-color: var(--secondary-bg-color);
            border-radius: 1.5rem 1.5rem 0 0;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform 0.3s ease-in-out;
        }
        .modal-overlay.visible .bottom-sheet-content {
            transform: translateY(0);
        }
        .grabber {
            width: 3rem;
            height: 0.375rem;
            background-color: #d1d5db;
            border-radius: 9999px;
            margin: 0.75rem auto;
            flex-shrink: 0;
        }
        
        .profile-tab, .feed-tab {
            flex-grow: 1;
            text-align: center;
            padding: 0.75rem 0.5rem;
            font-weight: 600;
            color: var(--hint-color);
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .profile-tab.active, .feed-tab.active {
            color: var(--button-color);
            border-bottom-color: var(--button-color);
        }
        .profile-tab-content, .feed-tab-content {
            display: none;
        }
        .profile-tab-content.active, .feed-tab-content.active {
            display: block;
        }
        
        #detail-comments-section, #event-comments-section {
            border-top: 1px solid var(--border-color);
        }
        #detail-comment-input-form, #event-comment-input-form {
            padding: 0.5rem 1rem 1rem;
            border-top: 1px solid var(--border-color);
            background-color: var(--secondary-bg-color);
        }

        .skeleton {
            background-color: #e2e8f0;
            border-radius: 0.5rem;
            animation: pulse-bg 1.5s infinite;
        }
        @keyframes pulse-bg {
            50% { background-color: #cbd5e1; }
        }
        
        .form-input, .form-textarea, .form-select {
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
            width: 100%;
        }
        .form-input:focus, .form-textarea:focus, .form-select:focus {
            outline: none;
            border-color: var(--button-color);
            box-shadow: 0 0 0 2px rgba(var(--button-color-rgb), 0.2);
        }
        /* Стили для кастомного инпута даты-времени */
        .datetime-input-wrapper {
            position: relative;
        }
        .datetime-input-wrapper input[type="datetime-local"]::-webkit-calendar-picker-indicator {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            color: transparent;
            background: transparent;
            cursor: pointer;
        }
    </style>
</head>
<body class="font-sans antialiased overflow-hidden">
    
    <!-- Начальный загрузчик -->
    <div id="initial-loader" class="fixed inset-0 flex flex-col items-center justify-center z-50">
        <svg class="animate-spin h-10 w-10 mb-4" style="color: var(--button-color);" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
        <p id="loader-text" class="text-lg font-semibold" style="color: var(--text-color);">Загрузка TerraRun...</p>
    </div>

    <!-- Экран-заглушка / Ошибка -->
    <div id="fallback-screen" class="fixed inset-0 flex items-center justify-center p-4 z-40 hidden">
        <div id="fallback-content" class="text-center card-bg p-8 rounded-2xl shadow-lg max-w-sm"></div>
    </div>

    <!-- Основной контейнер приложения -->
    <div id="app-container" class="hidden">
        <!-- Вид 1: Карта -->
        <div id="map-view" class="view active">
            <div id="map"></div>
            
            <div id="map-center-controls" class="fixed inset-0 z-20 flex justify-center items-center pointer-events-none hidden">
                <button id="request-geo-btn" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-full shadow-lg flex items-center gap-2 pointer-events-auto">
                    <i class="fa-solid fa-location-arrow h-5 w-5"></i>
                    <span id="request-geo-text">Дать доступ к гео</span>
                    <svg id="request-geo-loader" class="animate-spin h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                </button>
            </div>
            
            <div id="map-top-panel">
                <div class="w-12"></div>
                <div class="flex-grow flex justify-center">
                     <div id="mode-switcher" class="hidden">
                         <button id="mode-capture" class="mode-btn active">Захват</button>
                         <button id="mode-spots" class="mode-btn">Споты</button>
                         <button id="mode-routes" class="mode-btn">Маршруты</button>
                     </div>
                </div>
                <div id="map-controls-right" class="flex flex-col items-end gap-2">
                    <button id="recenter-btn" class="hidden bg-white/80 backdrop-blur-md p-3 rounded-full shadow-lg pointer-events-all">
                        <i class="fa-solid fa-location-crosshairs h-6 w-6 text-gray-700"></i>
                    </button>
                </div>
            </div>
            
            <div id="map-action-container" class="hidden">
                <button id="map-action-btn" class="text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all duration-300 flex items-center gap-2 pointer-events-auto">
                    <i id="map-action-icon" class="fa-solid fa-play h-5 w-5"></i>
                    <span id="map-action-text"></span>
                </button>
            </div>
        </div>

        <!-- Вид 2: Лента -->
        <div id="feed-view" class="view p-4 fade-in">
            <div class="flex justify-between items-center mb-4 px-2">
                <h1 class="text-3xl font-bold">Лента</h1>
                <button id="feed-create-btn" class="p-2 rounded-full hover:bg-gray-200" style="background-color: var(--secondary-bg-color);">
                    <i class="fa-solid fa-plus h-7 w-7" style="color: var(--button-color);"></i>
                </button>
            </div>
            
            <!-- NEW: Табы в ленте -->
            <div class="flex border-b sticky top-0 z-10 overflow-x-auto" style="background-color: var(--bg-color);">
                <div id="feed-tab-posts" class="feed-tab active" onclick="switchFeedTab('posts')">Посты</div>
                <div id="feed-tab-events" class="feed-tab" onclick="switchFeedTab('events')">Покатушки</div>
                <div id="feed-tab-spots" class="feed-tab" onclick="switchFeedTab('spots')">Споты</div>
                <div id="feed-tab-routes" class="feed-tab" onclick="switchFeedTab('routes')">Маршруты</div>
            </div>

            <!-- Контент для табов -->
            <div id="feed-content-posts" class="feed-tab-content active mt-4 space-y-4"></div>
            <div id="feed-content-events" class="feed-tab-content mt-4 space-y-4"></div>
            <div id="feed-content-spots" class="feed-tab-content mt-4 space-y-4"></div>
            <div id="feed-content-routes" class="feed-tab-content mt-4 space-y-4"></div>
        </div>

        <!-- Вид 3: Топ пользователей -->
        <div id="top-view" class="view p-4 fade-in">
            <div class="flex justify-between items-center mb-6 px-2">
                <h1 class="text-3xl font-bold">Топ Бегунов</h1>
                <button id="scan-qr-btn" class="p-2 rounded-full hover:bg-gray-200" style="background-color: var(--secondary-bg-color);">
                    <i class="fa-solid fa-qrcode h-7 w-7" style="color: var(--hint-color);"></i>
                </button>
            </div>
            <div id="leaderboard" class="space-y-3"></div>
        </div>

        <!-- Вид 4: Профиль -->
        <div id="profile-view" class="view p-4 fade-in">
            <h1 class="text-3xl font-bold mb-6 px-2">Профиль</h1>
            <div class="card-bg rounded-2xl shadow-lg p-6 flex flex-col items-center space-y-4">
                <div id="profile-avatar-wrapper" class="w-24 h-24 rounded-full border-4 flex-shrink-0">
                    <img src="https://placehold.co/96x96/E2E8F0/4A5568?text=?" id="profile-avatar-img" class="w-full h-full rounded-full object-cover" alt="avatar">
                </div>
                <div class="text-center">
                    <h2 id="profile-name" class="text-2xl font-bold">Загрузка...</h2>
                    <p class="text-sm mt-2" style="color: var(--hint-color);">Общая площадь</p>
                    <p id="profile-area" class="text-3xl font-bold" style="color: var(--button-color);">0 м²</p>
                </div>
                <div class="w-full pt-4 mt-4 border-t" style="border-color: var(--border-color);">
                    <div class="flex justify-center gap-8 w-full">
                        <button id="share-profile-btn" class="flex flex-col items-center space-y-1 transition-opacity hover:opacity-70">
                            <div class="p-3 rounded-full" style="background-color: rgba(var(--button-color-rgb), 0.15);"><i class="fa-solid fa-arrow-up-from-bracket h-6 w-6" style="color: var(--button-color);"></i></div>
                            <span class="text-xs font-medium" style="color: var(--hint-color);">Поделиться</span>
                        </button>
                        <button id="show-qr-btn" class="flex flex-col items-center space-y-1 transition-opacity hover:opacity-70">
                            <div class="p-3 rounded-full" style="background-color: rgba(var(--button-color-rgb), 0.15);"><i class="fa-solid fa-qrcode h-6 w-6" style="color: var(--button-color);"></i></div>
                            <span class="text-xs font-medium" style="color: var(--hint-color);">Мой QR</span>
                        </button>
                    </div>
                </div>
            </div>
             <!-- Табы -->
            <div class="flex border-b mt-6 sticky top-0 z-10" style="background-color: var(--bg-color);">
                <div id="profile-tab-posts" class="profile-tab active" onclick="switchMainProfileTab('posts')">Посты</div>
                <!-- NEW: Таб покатушек в профиле -->
                <div id="profile-tab-events" class="profile-tab" onclick="switchMainProfileTab('events')">Покатушки</div>
                <div id="profile-tab-spots" class="profile-tab" onclick="switchMainProfileTab('spots')">Споты</div>
                <div id="profile-tab-routes" class="profile-tab" onclick="switchMainProfileTab('routes')">Маршруты</div>
            </div>

            <div id="profile-content-posts" class="profile-tab-content active mt-4 space-y-4"></div>
            <div id="profile-content-events" class="profile-tab-content mt-4 space-y-4"></div>
            <div id="profile-content-spots" class="profile-tab-content mt-4 space-y-4"></div>
            <div id="profile-content-routes" class="profile-tab-content mt-4 space-y-4"></div>
        </div>
    </div>

    <!-- Нижний навбар -->
    <nav id="bottom-navbar" class="hidden fixed bottom-0 left-0 right-0 flex justify-evenly items-center z-20">
        <button class="nav-btn active flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('map-view')"><i class="fa-solid fa-map-location-dot h-7 w-7"></i><span>Карта</span></button>
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('feed-view')"><i class="fa-solid fa-newspaper h-7 w-7"></i><span>Лента</span></button>
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('top-view')"><i class="fa-solid fa-ranking-star h-7 w-7"></i><span>Топ</span></button>
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" onclick="showView('profile-view')"><i class="fa-solid fa-user h-7 w-7"></i><span>Профиль</span></button>
    </nav>
    
    <!-- Модальное окно создания простого поста -->
    <div id="simple-post-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideSimplePostModal()">
        <div id="simple-post-content" class="bottom-sheet-content" style="height: auto; max-height: 90vh;">
            <div class="grabber" onclick="hideSimplePostModal()"></div>
            <div class="p-4 space-y-4 flex flex-col flex-grow">
                <div class="flex justify-between items-center flex-shrink-0">
                    <h2 class="text-2xl font-bold">Новый пост</h2>
                    <button onclick="hideSimplePostModal()" class="p-2 rounded-full hover:bg-gray-200"><i class="fa-solid fa-times"></i></button>
                </div>
                <div class="flex-grow overflow-y-auto space-y-4">
                    <p style="color: var(--hint-color);">Поделитесь своими мыслями с сообществом.</p>
                    <textarea id="simple-post-details" class="form-textarea mt-1 block w-full" rows="4" placeholder="Что у вас нового?"></textarea>
                    <div id="simple-post-filename" class="text-sm text-gray-500 truncate"></div>
                </div>
                <div class="flex justify-between items-center pt-4 flex-shrink-0">
                    <div class="flex items-center gap-2">
                        <button id="simple-post-gallery-btn" class="cursor-pointer p-2 rounded-full hover:bg-gray-200">
                            <i class="fa-solid fa-images h-7 w-7" style="color: var(--hint-color);"></i>
                        </button>
                        <button id="simple-post-camera-btn" class="cursor-pointer p-2 rounded-full hover:bg-gray-200">
                            <i class="fa-solid fa-camera h-7 w-7" style="color: var(--hint-color);"></i>
                        </button>
                    </div>
                    <button onclick="handleSimplePostSave()" class="text-white font-bold py-2 px-6 rounded-full transition-all" style="background-color: var(--button-color);">Опубликовать</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно создания Спота/Маршрута/Поста (захват) -->
    <div id="creation-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideCreationModal()">
        <div class="bottom-sheet-content" style="height: 75%; max-height: calc(100vh - env(safe-area-inset-top) - 1rem);">
            <div class="grabber" onclick="hideCreationModal()"></div>
            <div id="creation-modal-body" class="flex-grow overflow-y-auto p-4 space-y-4">
                <h2 id="creation-modal-title" class="text-2xl font-bold"></h2>
                <p id="creation-modal-description" style="color: var(--hint-color);"></p>
                <div>
                    <label for="creation-modal-name" class="block text-sm font-medium mb-1">Название</label>
                    <input type="text" id="creation-modal-name" class="form-input w-full" placeholder="Например, 'Красивый вид'">
                </div>
                <div id="creation-modal-details-section">
                    <label for="creation-modal-details" class="block text-sm font-medium mb-1">Описание</label>
                    <textarea id="creation-modal-details" rows="3" class="form-textarea w-full" placeholder="Опишите это место или маршрут..."></textarea>
                </div>
                <div id="creation-modal-photo-section">
                    <label class="block text-sm font-medium mb-1">Фото</label>
                    <div class="mt-1">
                        <img id="creation-modal-photo-preview" src="" alt="Предпросмотр фото" class="hidden w-full h-auto mb-4 rounded-lg object-cover max-h-48">
                        <div class="flex gap-3">
                            <button id="creation-gallery-btn" class="w-full flex items-center justify-center gap-2 p-3 rounded-xl" style="background-color: var(--bg-color); color: var(--text-color);">
                                <i class="fa-solid fa-images"></i>
                                <span>Из галереи</span>
                            </button>
                            <button id="creation-camera-btn" class="w-full flex items-center justify-center gap-2 p-3 rounded-xl text-white" style="background-color: var(--button-color);">
                                <i class="fa-solid fa-camera"></i>
                                <span>Сделать снимок</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="flex justify-end space-x-3 pt-4">
                    <button onclick="hideCreationModal()" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-full transition-all">Отмена</button>
                    <button id="save-creation-btn" class="text-white font-bold py-2 px-4 rounded-full transition-all" style="background-color: var(--button-color);">Сохранить</button>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW: Модальное окно создания Покатушки (Мероприятия) -->
    <div id="event-creation-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideEventCreationModal()">
        <div class="bottom-sheet-content" style="height: 90%; max-height: calc(100vh - env(safe-area-inset-top) - 1rem);">
            <div class="grabber" onclick="hideEventCreationModal()"></div>
            <div class="p-4 flex-shrink-0">
                 <h2 class="text-2xl font-bold">Новое мероприятие</h2>
            </div>
            <div id="event-creation-modal-body" class="flex-grow overflow-y-auto p-4 space-y-4">
                <div>
                    <label for="event-title" class="block text-sm font-medium mb-1">Название</label>
                    <input type="text" id="event-title" class="form-input" placeholder="Вечерний прохват">
                </div>
                <div>
                    <label for="event-description" class="block text-sm font-medium mb-1">Описание</label>
                    <textarea id="event-description" rows="3" class="form-textarea" placeholder="Собираемся, общаемся, катаемся!"></textarea>
                </div>
                <div>
                    <label for="event-datetime" class="block text-sm font-medium mb-1">Дата и время</label>
                    <div class="datetime-input-wrapper">
                        <input type="datetime-local" id="event-datetime" class="form-input">
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Точка сбора</label>
                    <div id="event-map-picker" class="h-48 w-full rounded-lg bg-gray-200 mt-1"></div>
                    <p id="event-map-hint" class="text-xs text-gray-500 mt-1">Кликните на карту, чтобы выбрать точку сбора.</p>
                </div>
                <div>
                    <label for="event-route-select" class="block text-sm font-medium mb-1">Маршрут (необязательно)</label>
                    <select id="event-route-select" class="form-select"></select>
                </div>
            </div>
            <div class="p-4 flex-shrink-0 border-t" style="border-color: var(--border-color);">
                 <button onclick="handleEventSave()" class="w-full text-white font-bold py-3 px-6 rounded-full transition-all" style="background-color: var(--button-color);">Создать мероприятие</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно деталей (универсальное) -->
    <div id="detail-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideDetailModal()">
        <div class="bottom-sheet-content" style="height: 90%; max-height: calc(100vh - env(safe-area-inset-top) - 1rem);">
            <div class="grabber" onclick="hideDetailModal()"></div>
            <div id="detail-modal-body" class="flex-grow overflow-y-auto"></div>
        </div>
    </div>

    <!-- Модальное окно с комментариями (ДЛЯ ПОСТОВ) -->
    <div id="comments-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideCommentsModal()">
        <div class="bottom-sheet-content" style="height: 75%;">
             <div class="grabber" onclick="hideCommentsModal()"></div>
             <h2 id="comments-modal-title" class="text-xl font-bold px-4 pb-2 flex-shrink-0">Комментарии</h2>
            <div id="comments-modal-body" class="flex-grow overflow-y-auto p-4"></div>
            <div id="comment-input-container" class="flex-shrink-0 p-2 border-t" style="background-color: var(--secondary-bg-color); border-color: var(--border-color);">
                <div id="reply-indicator" class="hidden text-xs px-2 pb-1 flex justify-between items-center" style="color: var(--hint-color);">
                    <span id="reply-indicator-text"></span>
                    <button onclick="cancelReply()" class="font-bold text-xl">&times;</button>
                </div>
                <div class="flex items-center space-x-2">
                    <textarea id="main-comment-input" class="form-textarea w-full" rows="1" placeholder="Написать комментарий..."></textarea>
                    <button id="main-comment-send-btn" onclick="postComment()" class="flex-shrink-0 text-white rounded-full p-2 hover:opacity-80 disabled:opacity-50" style="background-color: var(--button-color);">
                        <i class="fa-solid fa-paper-plane h-6 w-6"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- NEW: Модальное окно списка участников -->
    <div id="participants-modal" class="modal-overlay bottom-sheet-modal" onclick="if(event.target === this) hideParticipantsModal()">
        <div class="bottom-sheet-content" style="height: 75%;">
            <div class="grabber" onclick="hideParticipantsModal()"></div>
            <h2 id="participants-modal-title" class="text-xl font-bold px-4 pb-2 flex-shrink-0">Участники</h2>
            <div id="participants-modal-body" class="flex-grow overflow-y-auto p-4 space-y-3"></div>
        </div>
    </div>

    <!-- Модальное окно для QR-кода -->
    <div id="qr-modal" class="modal-overlay justify-center items-center p-4" onclick="if(event.target === this) hideQrModal()">
        <div class="card-bg rounded-2xl shadow-2xl p-6 w-full max-w-xs fade-in space-y-4 flex flex-col items-center">
            <h2 class="text-2xl font-bold">Мой QR-код</h2>
            <div id="qrcode" class="p-2 bg-white rounded-lg"></div>
            <p class="text-center text-sm" style="color: var(--hint-color);">Покажите этот код другу, чтобы он отсканировал его в приложении.</p>
            <button onclick="hideQrModal()" class="w-full mt-4 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-full transition-all">Закрыть</button>
        </div>
    </div>

    <input id="gallery-input" type="file" class="sr-only" accept="image/*">
    <input id="camera-input" type="file" class="sr-only" accept="image/*" capture="user">


    <script type="module">
        // --- КОНФИГУРАЦИЯ И КОНСТАНТЫ ---
        const SUPABASE_URL = 'https://jsnahjtoqwuwbjdmisuj.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpzbmFoanRvcXd1d2JqZG1pc3VqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMzOTQxMDQsImV4cCI6MjA2ODk3MDEwNH0.M3TWsNJppj1f-Cmj6nGCAUswy1HZgBLW8yJZfTwkrpI';
        const BOT_USERNAME = 'TerraRunBot';

        // --- ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ И СОСТОЯНИЕ ---
        const tg = window.Telegram.WebApp;
        let map;
        let eventPickerMap; // Карта для выбора точки сбора
        let supabase;
        let telegramUser = null;
        let locationWatchId = null;
        let scrollToPostId = null; 
        let countdownTimers = []; // Массив для хранения интервалов таймеров

        const AppState = {
            currentMapMode: 'capture', // 'capture', 'spots', 'routes'
            currentFeedTab: 'posts', // 'posts', 'events', 'spots', 'routes'
            isRunning: false,
            lastKnownLocation: null,
            userProfile: {
                id: null, name: '', color: '#3b82f6', territory: null, photo_url: null, area: 0,
            },
            currentRunPath: [],
            currentPathPolyline: null,
            currentUserMarker: null,
            allUserLayers: {},
            allSpots: [],
            allRoutes: [],
            allEvents: [], // NEW
            allProfilesData: [],
            currentEditContext: {},
            currentDetailContext: {},
            currentReplyTarget: { type: null, id: null, parentCommentId: null },
            photoContext: null,
            simplePostContext: {},
            eventCreationContext: {}, // NEW
        };
        
        let territoriesCollection, spotCollection, routeCollection, eventCollection; // NEW: eventCollection
        
        // --- ЭЛЕМЕНТЫ DOM ---
        const initialLoader = document.getElementById('initial-loader');
        const loaderText = document.getElementById('loader-text');
        const fallbackScreen = document.getElementById('fallback-screen');
        const fallbackContent = document.getElementById('fallback-content');
        const appContainer = document.getElementById('app-container');
        const bottomNavbar = document.getElementById('bottom-navbar');
        const modeSwitcher = document.getElementById('mode-switcher');
        const feedCreateBtn = document.getElementById('feed-create-btn');
        
        // Модальные окна
        const detailModal = document.getElementById('detail-modal');
        const commentsModal = document.getElementById('comments-modal');
        const simplePostModal = document.getElementById('simple-post-modal');
        const creationModal = document.getElementById('creation-modal');
        const qrModal = document.getElementById('qr-modal');
        const eventCreationModal = document.getElementById('event-creation-modal'); // NEW
        const participantsModal = document.getElementById('participants-modal'); // NEW

        const leaderboardDiv = document.getElementById('leaderboard');
        const profileName = document.getElementById('profile-name');
        const profileAreaDisplay = document.getElementById('profile-area');
        const profileAvatarImg = document.getElementById('profile-avatar-img');
        const profileAvatarWrapper = document.getElementById('profile-avatar-wrapper');
        const recenterBtn = document.getElementById('recenter-btn');
        const requestGeoBtn = document.getElementById('request-geo-btn');
        const mapCenterControls = document.getElementById('map-center-controls');
        const scanQrBtn = document.getElementById('scan-qr-btn');
        const shareProfileBtn = document.getElementById('share-profile-btn');
        const showQrBtn = document.getElementById('show-qr-btn');
        const mapActionContainer = document.getElementById('map-action-container');
        const mapActionBtn = document.getElementById('map-action-btn');

        // --- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ---
        
        function shadeColor(color, percent) {
            if (!color || !color.startsWith('#')) return '#e5e7eb'; 
            let R = parseInt(color.substring(1, 3), 16);
            let G = parseInt(color.substring(3, 5), 16);
            let B = parseInt(color.substring(5, 7), 16);
            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);
            R = (R < 255) ? R : 255;
            G = (G < 255) ? G : 255;
            B = (B < 255) ? B : 255;
            R = (R > 0) ? R : 0;
            G = (G > 0) ? G : 0;
            B = (B > 0) ? B : 0;
            const RR = ((R.toString(16).length === 1) ? "0" + R.toString(16) : R.toString(16));
            const GG = ((G.toString(16).length === 1) ? "0" + G.toString(16) : G.toString(16));
            const BB = ((B.toString(16).length === 1) ? "0" + B.toString(16) : B.toString(16));
            return "#" + RR + GG + BB;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : null;
        }

        function shareContent(type, id, ownerId) {
            tg.HapticFeedback.impactOccurred('light');
            const isOwner = telegramUser && ownerId.toString() === telegramUser.id.toString();
            let text = '';
            switch (type) {
                case 'post': text = isOwner ? 'Оцени мой пост в TerraRun!' : 'Смотри какой интересный пост в TerraRun!'; break;
                case 'route': text = isOwner ? 'Зацени мой маршрут в TerraRun!' : 'Смотри какой интересный маршрут в TerraRun!'; break;
                case 'spot': text = isOwner ? 'Смотри какой интересный спот в TerraRun!' : 'Смотри какой интересный спот в TerraRun!'; break;
                case 'event': text = isOwner ? 'Присоединяйся к моей покатушке в TerraRun!' : 'Смотри, какая покатушка намечается в TerraRun!'; break;
                case 'user': text = isOwner ? 'Это мой профиль в TerraRun, присоединяйся!' : 'Смотри профиль этого бегуна в TerraRun!'; break;
            }
            const url = `https://t.me/${BOT_USERNAME}?startapp=${type}_${id}`;
            tg.openTelegramLink(`https://t.me/share/url?url=${encodeURIComponent(url)}&text=${encodeURIComponent(text)}`);
        }

        function escapeHTML(str) {
            if (!str) return '';
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
        }

        // --- ФУНКЦИИ UI ---
        function showView(viewId) {
            tg.HapticFeedback.selectionChanged();
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(viewId).classList.add('active');
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`button[onclick="showView('${viewId}')"]`).classList.add('active');
            
            const isMapView = viewId === 'map-view';
            
            if (isMapView && AppState.lastKnownLocation) {
                mapActionContainer.classList.remove('hidden');
            } else {
                mapActionContainer.classList.add('hidden');
            }
            modeSwitcher.classList.toggle('hidden', !isMapView || !AppState.lastKnownLocation);
            
            if (isMapView) {
                setTimeout(() => map?.container.fitToViewport(), 100);
            }
        }
        
        // Переключение табов в ленте
        function switchFeedTab(tabName) {
            if (AppState.currentFeedTab === tabName) return;
            tg.HapticFeedback.selectionChanged();
            AppState.currentFeedTab = tabName;

            document.querySelectorAll('.feed-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.feed-tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`feed-tab-${tabName}`).classList.add('active');
            document.getElementById(`feed-content-${tabName}`).classList.add('active');

            // Обновляем видимость и назначение кнопки создания
            const createIcon = feedCreateBtn.querySelector('i');
            if (tabName === 'posts') {
                feedCreateBtn.classList.remove('hidden');
                feedCreateBtn.onclick = showSimplePostModal;
                createIcon.className = 'fa-solid fa-plus h-7 w-7';
            } else if (tabName === 'events') {
                feedCreateBtn.classList.remove('hidden');
                feedCreateBtn.onclick = showEventCreationModal;
                createIcon.className = 'fa-solid fa-calendar-plus h-7 w-7';
            } else { // Для 'spots' и 'routes'
                feedCreateBtn.classList.add('hidden');
            }
            
            // Загружаем контент для таба
            renderCurrentFeedTab();
        }
        
        // Загрузка контента для активного таба ленты
        function renderCurrentFeedTab() {
            clearCountdownTimers(); // Очищаем старые таймеры перед рендером
            switch(AppState.currentFeedTab) {
                case 'posts': renderFeedPosts(); break;
                case 'events': renderFeedEvents(); break;
                case 'spots': renderFeedSpots(); break;
                case 'routes': renderFeedRoutes(); break;
            }
        }


        async function setMapMode(newMode) {
            if (AppState.currentMapMode === newMode || !map) return;
            
            if (AppState.isRunning) {
                showCustomAlert("Сначала завершите текущую активность (захват или запись маршрута).");
                return;
            }
            tg.HapticFeedback.selectionChanged();
            AppState.currentMapMode = newMode;
            
            tg.CloudStorage.setItem('currentMapMode', newMode);

            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.id === `mode-${newMode}`);
            });

            map.events.remove('click', handleMapClickForSpot);

            territoriesCollection.options.set('visible', newMode === 'capture');
            spotCollection.options.set('visible', newMode === 'spots');
            routeCollection.options.set('visible', newMode === 'routes');
            
            if (newMode === 'spots') {
                map.events.add('click', handleMapClickForSpot);
            }

            updateMapActionButton();
        }

        function updateMapActionButton() {
            const icon = document.getElementById('map-action-icon');
            const text = document.getElementById('map-action-text');

            if (!AppState.lastKnownLocation) {
                mapActionContainer.classList.add('hidden');
                return;
            }
            
            mapActionContainer.classList.remove('hidden');

            switch (AppState.currentMapMode) {
                case 'capture':
                    if (AppState.isRunning) {
                        text.textContent = "Остановить захват";
                        mapActionBtn.style.backgroundColor = 'var(--destructive-color)';
                        icon.className = 'fa-solid fa-stop h-5 w-5';
                    } else {
                        text.textContent = "Начать захват";
                        mapActionBtn.style.backgroundColor = 'var(--button-color)';
                        icon.className = 'fa-solid fa-play h-5 w-5';
                    }
                    break;
                case 'spots':
                    text.textContent = "Добавить спот здесь";
                    mapActionBtn.style.backgroundColor = 'var(--success-color)';
                    icon.className = 'fa-solid fa-location-dot h-5 w-5';
                    break;
                case 'routes':
                    if (AppState.isRunning) {
                        text.textContent = "Завершить маршрут";
                        mapActionBtn.style.backgroundColor = 'var(--destructive-color)';
                        icon.className = 'fa-solid fa-stop h-5 w-5';
                    } else {
                        text.textContent = "Начать запись маршрута";
                        mapActionBtn.style.backgroundColor = 'var(--button-color)';
                        icon.className = 'fa-solid fa-route h-5 w-5';
                    }
                    break;
            }
        }
        
        async function mapActionButtonHandler() {
            mapActionBtn.disabled = true; 
            try {
                switch (AppState.currentMapMode) {
                    case 'capture':
                        AppState.isRunning ? await stopRun() : startRun();
                        break;
                    case 'spots':
                        if(AppState.lastKnownLocation) {
                            handleMapClickForSpot({ get: (key) => key === 'coords' ? AppState.lastKnownLocation : null });
                        } else {
                            showCustomAlert("Определяем ваше местоположение...");
                        }
                        break;
                    case 'routes':
                        AppState.isRunning ? await stopRouteRecording() : startRouteRecording();
                        break;
                }
            } finally {
                mapActionBtn.disabled = false;
            }
        }
        
        function generateColorFromId(id) {
            const strId = String(id);
            let hash = 0;
            for (let i = 0; i < strId.length; i++) {
                hash = strId.charCodeAt(i) + ((hash << 5) - hash);
            }
            const h = hash % 360;
            return `hsl(${h}, 80%, 65%)`;
        }

        // --- ЛОГИКА МОДАЛЬНЫХ ОКОН ---
        
        function showSimplePostModal() {
            document.getElementById('simple-post-details').value = '';
            document.getElementById('simple-post-filename').textContent = '';
            AppState.simplePostContext = {};
            simplePostModal.classList.add('visible');
            document.body.classList.add('modal-open');
            tg.BackButton.show();
        }

        function hideSimplePostModal() {
            simplePostModal.classList.remove('visible');
            document.body.classList.remove('modal-open');
            tg.BackButton.hide();
        }
        
        function showCreationModal(type, context = {}) {
            AppState.currentEditContext = { type, ...context };
            const title = document.getElementById('creation-modal-title');
            const description = document.getElementById('creation-modal-description');
            const nameInput = document.getElementById('creation-modal-name');
            const detailsInput = document.getElementById('creation-modal-details');
            const detailsSection = document.getElementById('creation-modal-details-section');
            const photoSection = document.getElementById('creation-modal-photo-section');
            
            nameInput.value = '';
            detailsInput.value = '';
            const preview = document.getElementById('creation-modal-photo-preview');
            preview.classList.add('hidden');
            preview.src = '';

            detailsSection.style.display = 'none';
            photoSection.style.display = 'none';

            if (type === 'spot') {
                title.textContent = 'Создать новый спот';
                description.textContent = 'Отметьте интересное место на карте для других.';
                detailsSection.style.display = 'block';
                photoSection.style.display = 'block';
            } else if (type === 'route') {
                title.textContent = 'Сохранить новый маршрут';
                description.textContent = 'Дайте название и описание вашему маршруту.';
                detailsSection.style.display = 'block';
            } else if (type === 'post') {
                title.textContent = 'Новое достижение!';
                description.textContent = `Вы захватили ${context.area_captured_formatted}. Дайте название вашей новой территории.`;
                photoSection.style.display = 'block';
            }
            
            creationModal.classList.add('visible');
            document.body.classList.add('modal-open');
            tg.BackButton.show();
        }

        function hideCreationModal() {
            creationModal.classList.remove('visible');
            document.body.classList.remove('modal-open');
            tg.BackButton.hide();
            AppState.currentEditContext = {};
        }

        function handleSave() {
            const { type } = AppState.currentEditContext;
            if (type === 'spot') saveSpot();
            else if (type === 'route') saveRoute();
            else if (type === 'post') handlePostSubmission();
        }
        
        function showDetailModal(type, id) {
             AppState.currentDetailContext = { type, id, mapInstances: [] };
             tg.HapticFeedback.impactOccurred('medium');
             tg.BackButton.show();
             
             detailModal.classList.add('visible');
             document.body.classList.add('modal-open');
             loadDetailContent();
        }
        
        function hideDetailModal() {
            if (AppState.currentDetailContext.mapInstances) {
                AppState.currentDetailContext.mapInstances.forEach(mapInstance => mapInstance.destroy());
            }
            tg.BackButton.hide();
            detailModal.classList.remove('visible');
            document.body.classList.remove('modal-open');
            AppState.currentDetailContext = {};
        }

        // --- ФУНКЦИИ ДЛЯ ВЫБОРА ФОТО ---
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (AppState.photoContext === 'creation') {
                const preview = document.getElementById('creation-modal-photo-preview');
                preview.src = URL.createObjectURL(file);
                preview.classList.remove('hidden');
                AppState.currentEditContext.file = file;
            } else if (AppState.photoContext === 'simple') {
                document.getElementById('simple-post-filename').textContent = file.name;
                AppState.simplePostContext = { file: file };
            }
            event.target.value = '';
        }
        
        async function generateUserProfileDetailHTML(profile, posts, spots, routes, events, likesByPost, commentsByPost) {
            const profileName = escapeHTML(profile.name);
            const avatar = profile.photo_url || `https://placehold.co/96x96/E2E8F0/4A5568?text=${profileName.charAt(0)}`;
            const area = profile.area || 0;
            const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;

            const postsHTML = posts.length > 0
                ? posts.map(p => generatePostHTML(p, likesByPost[p.id] || [], commentsByPost[p.id] || [])).join('')
                : '<p class="text-center text-gray-500 py-4">У этого пользователя нет постов.</p>';

            const eventsHTML = events.length > 0
                ? (await Promise.all(events.map(e => generateEventCardHTML(e)))).join('')
                : '<p class="text-center text-gray-500 py-4">Этот пользователь не участвует в мероприятиях.</p>';

            const spotsHTML = spots.length > 0
                ? spots.map(s => generateMiniSpotHTML(s, false)).join('')
                : '<p class="text-center text-gray-500 py-4">У этого пользователя нет спотов.</p>';

            const routesHTML = routes.length > 0
                ? routes.map(r => generateMiniRouteHTML(r)).join('')
                : '<p class="text-center text-gray-500 py-4">У этого пользователя нет маршрутов.</p>';

            return `
                <div class="p-4">
                    <div class="card-bg rounded-2xl shadow-lg p-6 flex flex-col items-center space-y-4">
                        <div class="w-24 h-24 rounded-full border-4 flex-shrink-0" style="border-color: ${profile.color || '#ccc'};">
                            <img src="${avatar}" class="w-full h-full rounded-full object-cover" alt="avatar">
                        </div>
                        <div class="text-center">
                            <h2 class="text-2xl font-bold">${profileName}</h2>
                            <p class="text-sm mt-2" style="color: var(--hint-color);">Общая площадь</p>
                            <p class="text-3xl font-bold" style="color: var(--button-color);">${formattedArea}</p>
                        </div>
                        <div class="w-full pt-4 mt-4 border-t" style="border-color: var(--border-color);">
                            <div class="flex justify-center gap-8 w-full">
                                <button onclick="shareContent('user', ${profile.id}, ${profile.id})" class="flex flex-col items-center space-y-1 transition-opacity hover:opacity-70">
                                    <div class="p-3 rounded-full" style="background-color: rgba(var(--button-color-rgb), 0.15);"><i class="fa-solid fa-arrow-up-from-bracket h-6 w-6" style="color: var(--button-color);"></i></div>
                                    <span class="text-xs font-medium" style="color: var(--hint-color);">Поделиться</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="flex border-b sticky top-0 z-10 overflow-x-auto" style="background-color: var(--bg-color);">
                    <div id="tab-posts" class="profile-tab active" onclick="switchProfileTab('posts')">Посты (${posts.length})</div>
                    <div id="tab-events" class="profile-tab" onclick="switchProfileTab('events')">Покатушки (${events.length})</div>
                    <div id="tab-spots" class="profile-tab" onclick="switchProfileTab('spots')">Споты (${spots.length})</div>
                    <div id="tab-routes" class="profile-tab" onclick="switchProfileTab('routes')">Маршруты (${routes.length})</div>
                </div>
                <div class="p-4 space-y-4">
                    <div id="content-posts" class="profile-tab-content active space-y-4">${postsHTML}</div>
                    <div id="content-events" class="profile-tab-content space-y-4">${eventsHTML}</div>
                    <div id="content-spots" class="profile-tab-content grid grid-cols-1 md:grid-cols-2 gap-4">${spotsHTML}</div>
                    <div id="content-routes" class="profile-tab-content space-y-4">${routesHTML}</div>
                </div>
            `;
        }

        async function loadDetailContent() {
            const { type, id } = AppState.currentDetailContext;
            const body = document.getElementById('detail-modal-body');
            
            body.innerHTML = `<div class="text-center p-8"><svg class="animate-spin mx-auto h-8 w-8 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></div>`;
            
            if (type === 'spot') {
                const { data: spot, error } = await supabase.from('spots').select('*, profiles(id, name, photo_url), location_wkt:location::text').eq('id', id).single();
                if (error || !spot) {
                    body.innerHTML = `<p class="text-red-500 text-center p-4">Не удалось загрузить детали спота.</p>`;
                    return;
                }
                body.innerHTML = generateSpotDetailHTML(spot);
                loadAndRenderComments('spot', id, 'detail-comments-list');
            } else if (type === 'route') {
                 const { data: route, error } = await supabase.from('routes').select('*, profiles(id, name, photo_url), path_wkt:path::text').eq('id', id).single();
                if (error || !route) {
                    body.innerHTML = `<p class="text-red-500 text-center p-4">Не удалось загрузить детали маршрута.</p>`;
                    return;
                }
                body.innerHTML = generateRouteDetailHTML(route);
                setTimeout(() => renderMiniMapForRoute(route), 100);
                loadAndRenderComments('route', id, 'detail-comments-list');
            } else if (type === 'event') {
                const { data: event, error } = await supabase.from('events').select('*, profiles(id, name, photo_url), routes(*), meeting_point_wkt:meeting_point::text').eq('id', id).single();
                 if (error || !event) {
                    body.innerHTML = `<p class="text-red-500 text-center p-4">Не удалось загрузить детали мероприятия.</p>`;
                    return;
                }
                body.innerHTML = await generateEventDetailHTML(event);
                setTimeout(() => renderMiniMapForEvent(event), 100);
                loadAndRenderComments('event', id, 'event-comments-list');
            } else if (type === 'user') {
                const [profileRes, postsRes, spotsRes, routesRes, eventsRes] = await Promise.all([
                    supabase.from('profiles').select('*').eq('id', id).single(),
                    supabase.from('posts').select('*').eq('user_id', id).order('created_at', { ascending: false }),
                    supabase.from('spots').select('*, location_wkt:location::text').eq('user_id', id).order('created_at', { ascending: false }),
                    supabase.from('routes').select('*, path_wkt:path::text').eq('user_id', id).order('created_at', { ascending: false }),
                    supabase.rpc('get_user_events', { p_user_id: id })
                ]);

                if (profileRes.error) {
                    body.innerHTML = `<p class="text-red-500 text-center p-4">Не удалось загрузить профиль.</p>`;
                    return;
                }
                const profile = profileRes.data;
                const posts = postsRes.data || [];
                const spots = spotsRes.data || [];
                const routes = routesRes.data || [];
                const events = eventsRes.data || [];

                const postIds = posts.map(p => p.id);
                const likesByPost = {};
                const commentsByPost = {};
                if (postIds.length > 0) {
                    const { data: likes } = await supabase.from('likes').select('*').in('post_id', postIds);
                    const { data: comments } = await supabase.from('comments').select('id, post_id').in('post_id', postIds);
                    if(likes) likes.forEach(like => (likesByPost[like.post_id] = likesByPost[like.post_id] || []).push(like));
                    if(comments) comments.forEach(comment => (commentsByPost[comment.post_id] = commentsByPost[comment.post_id] || []).push(comment));
                }

                body.innerHTML = await generateUserProfileDetailHTML(profile, posts, spots, routes, events, likesByPost, commentsByPost);
                
                setTimeout(() => {
                    posts.forEach(post => {
                        if (post.territory_captured) {
                            renderMiniMapForPost(post, body);
                        }
                    });
                }, 100);
            }
        }
        
        function switchProfileTab(tabName, containerIdPrefix = 'content') {
            const context = document.getElementById('detail-modal-body');
            context.querySelectorAll('.profile-tab').forEach(t => t.classList.remove('active'));
            context.querySelectorAll('.profile-tab-content').forEach(c => c.classList.remove('active'));
            context.querySelector(`#tab-${tabName}`).classList.add('active');
            context.querySelector(`#${containerIdPrefix}-${tabName}`).classList.add('active');
        }

        function generateMiniSpotHTML(spot, isFeed = false) {
             const buttonHTML = isFeed 
                ? `<button onclick="event.stopPropagation(); navigateToMapObject('spot', '${spot.id}')" class="mt-2 w-full text-sm text-center font-semibold p-2 rounded-lg" style="background-color: var(--bg-color); color: var(--button-color);">Показать на карте</button>` 
                : '';
             return `<div class="card-bg rounded-xl p-4 shadow-sm cursor-pointer hover:shadow-md transition-shadow" onclick="showDetailModal('spot', '${spot.id}')">
                        ${spot.photo_url ? `<img src="${spot.photo_url}" class="w-full h-32 object-cover rounded-lg mb-3" alt="Фото спота">` : ''}
                        <p class="font-bold">${escapeHTML(spot.name)}</p>
                        <p class="text-sm text-gray-600 truncate mt-1">${escapeHTML(spot.description)}</p>
                        <p class="text-xs text-gray-400 mt-2">${new Date(spot.created_at).toLocaleDateString()}</p>
                        ${buttonHTML}
                      </div>`;
        }
        function generateMiniRouteHTML(route) {
             return `<div class="card-bg rounded-xl p-4 shadow-sm cursor-pointer hover:shadow-md transition-shadow" onclick="showDetailModal('route', '${route.id}')">
                            <p class="font-bold flex items-center gap-2"><i class="fa-solid fa-route" style="color: var(--hint-color);"></i> ${escapeHTML(route.name)}</p>
                            <p class="text-sm text-gray-600 truncate mt-1">${escapeHTML(route.description)}</p>
                            <p class="text-xs text-gray-400 mt-2">${new Date(route.created_at).toLocaleDateString()}</p>
                          </div>`;
        }

        function navigateToMapObject(type, id) {
            hideDetailModal(); 
            showView('map-view');
            
            setTimeout(() => {
                let targetObject;
                if (type === 'spot') {
                    setMapMode('spots');
                    targetObject = AppState.allSpots.find(s => s.id === id);
                    const geoJson = parseWKT(targetObject?.location_wkt);
                    if (geoJson) {
                        const coords = [geoJson.coordinates[1], geoJson.coordinates[0]]; // lat, long
                        map.panTo(coords, { flying: true, duration: 1500 }).then(() => map.setZoom(17));
                    }
                } else if (type === 'route') {
                    setMapMode('routes');
                    targetObject = AppState.allRoutes.find(r => r.id === id);
                    const geoJson = parseWKT(targetObject?.path_wkt);
                     if (geoJson && geoJson.coordinates.length > 0) {
                        const yandexCoords = geoJson.coordinates.map(p => [p[1], p[0]]);
                        const polyline = new ymaps.Polyline(yandexCoords);
                        map.setBounds(polyline.geometry.getBounds(), { checkZoomRange: true, duration: 1000 });
                    }
                }
            }, 150);
        }

        function parseWKT(wkt) {
            if (!wkt) return null;
            if (typeof wkt === 'object' && wkt.type && wkt.coordinates) return wkt;
            if (typeof wkt !== 'string') return null;
            try {
                if (wkt.trim().startsWith('{')) {
                    const parsed = JSON.parse(wkt);
                    if (parsed.type && parsed.coordinates) return parsed;
                }
                const match = wkt.match(/(POINT|LINESTRING|POLYGON|MULTIPOLYGON)\s*\((.+)\)/i);
                if (!match) return null;
                const type = match[1].toUpperCase();
                let content = match[2];
                if (type === 'POINT') {
                    const coords = content.match(/-?\d+(\.\d+)?/g);
                    if (!coords || coords.length < 2) return null;
                    return { type: 'Point', coordinates: [parseFloat(coords[0]), parseFloat(coords[1])] };
                }
                if (type === 'LINESTRING') {
                    const coordinates = content.split(',').map(pair => {
                        const nums = pair.trim().match(/-?\d+(\.\d+)?/g);
                        return nums && nums.length >= 2 ? [parseFloat(nums[0]), parseFloat(nums[1])] : null;
                    }).filter(Boolean);
                    return coordinates.length >= 2 ? { type: 'LineString', coordinates } : null;
                }
                if (type === 'POLYGON' || type === 'MULTIPOLYGON') {
                    const rings = content.match(/\(([^()]+)\)/g);
                    if (!rings) return null;
                    const coordinates = rings.map(ringContent => 
                        ringContent.replace(/[()]/g, '').split(',').map(pair => {
                            const nums = pair.trim().match(/-?\d+(\.\d+)?/g);
                            return nums && nums.length >= 2 ? [parseFloat(nums[0]), parseFloat(nums[1])] : null;
                        }).filter(Boolean)
                    );
                    if (type === 'POLYGON') return { type: 'Polygon', coordinates };
                    if (type === 'MULTIPOLYGON') return { type: 'MultiPolygon', coordinates: [coordinates] };
                }
            } catch (e) {
                console.error("Failed to parse WKT or JSON:", wkt, e);
                return null;
            }
            return null;
        }

        // --- ОСНОВНАЯ ЛОГИКА И ИНИЦИАЛИЗАЦИЯ ---
        async function runApp() {
            try {
                tg.ready();
                tg.expand();
                tg.enableClosingConfirmation();
                applyTheme(tg.themeParams);
                setupStaticEventListeners();

                if (!tg.initDataUnsafe?.user) {
                    showFallbackScreen('Требуется Telegram', 'Это приложение предназначено для работы исключительно внутри Telegram.', false);
                    return;
                }
                telegramUser = tg.initDataUnsafe.user;
                
                loaderText.textContent = 'Подключение к базе данных...';
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                
                loaderText.textContent = 'Загрузка данных...';
                initMap({ latitude: 55.751244, longitude: 37.618423 });
                
                await upsertUserProfile();
                updateUI();
                
                await Promise.all([
                    fetchAllProfilesAndDraw(),
                    renderCurrentFeedTab(), // Загружаем контент для первого таба
                    loadInitialMapData(),
                    renderMyProfileContent()
                ]);

                listenToRealtimeChanges();
                setupDynamicEventListeners();
                initializeGeolocation();
                handleStartParam();

                initialLoader.classList.add('hidden');
                appContainer.classList.remove('hidden');
                bottomNavbar.classList.remove('hidden');
                
                tg.CloudStorage.getItem('currentMapMode', (error, value) => {
                    if (error) {
                        console.error("CloudStorage error:", error);
                        setMapMode('capture');
                        return;
                    }
                    setMapMode(value || 'capture');
                });

            } catch (error) {
                console.error("Критическая ошибка инициализации:", error);
                let message = error.message || "Не удалось запустить приложение. Пожалуйста, попробуйте перезагрузить его.";
                showFallbackScreen("Ошибка инициализации", message, true);
            }
        }

        function initMap(coords) {
            if (map) return;
            const latLng = [coords.latitude, coords.longitude];
            map = new ymaps.Map('map', { 
                center: latLng, 
                zoom: 5,
                controls: []
            });
            
            territoriesCollection = new ymaps.GeoObjectCollection();
            spotCollection = new ymaps.GeoObjectCollection();
            routeCollection = new ymaps.GeoObjectCollection();
            eventCollection = new ymaps.GeoObjectCollection(); // NEW

            map.geoObjects.add(territoriesCollection);
            map.geoObjects.add(spotCollection);
            map.geoObjects.add(routeCollection);
            map.geoObjects.add(eventCollection); // NEW
            
            setTimeout(() => map?.container.fitToViewport(), 100);
        }

        function updateUI() {
            const name = escapeHTML(telegramUser.first_name);
            profileName.textContent = name;
            
            if (telegramUser.photo_url) {
                profileAvatarImg.src = telegramUser.photo_url;
            } else {
                const initial = name.charAt(0).toUpperCase();
                profileAvatarImg.src = `https://placehold.co/96x96/E2E8F0/4A5568?text=${initial}`;
            }
            profileAvatarWrapper.style.borderColor = AppState.userProfile.color;
            updateMapActionButton();
            refreshAllStats();
            renderMyProfileContent();
        }
        
        function updateCurrentUserMarker(latLng) {
            if (!map) return;
            const userAvatarUrl = telegramUser.photo_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${telegramUser.first_name.charAt(0)}`;
            
            const iconLayout = ymaps.templateLayoutFactory.createClass(
                `<div class="avatar-marker current-user-marker" style="background-image: url(${userAvatarUrl}); width: 40px; height: 40px; border-color: ${AppState.userProfile.color};"></div>`
            );
            
            if (AppState.currentUserMarker) {
                AppState.currentUserMarker.geometry.setCoordinates(latLng);
            } else {
                AppState.currentUserMarker = new ymaps.Placemark(latLng, {}, {
                    iconLayout: iconLayout,
                    iconShape: { type: 'Rectangle', coordinates: [[-20, -20], [20, 20]] }
                });
                map.geoObjects.add(AppState.currentUserMarker);
            }
        }
        
        // --- Логика геолокации ---
        async function initializeGeolocation() {
            if (!navigator.geolocation) {
                showCustomAlert("Геолокация не поддерживается вашим устройством.");
                return;
            }
            try {
                const permissionStatus = await navigator.permissions.query({ name: 'geolocation' });
                const handlePermissionChange = () => {
                    if (permissionStatus.state === 'granted') {
                        startGeoTracking();
                    } else {
                        AppState.lastKnownLocation = null;
                        mapActionContainer.classList.add('hidden');
                        modeSwitcher.classList.add('hidden');
                        mapCenterControls.classList.remove('hidden');
                    }
                };
                permissionStatus.onchange = handlePermissionChange;
                handlePermissionChange();
            } catch (e) {
                console.warn("API разрешений не поддерживается, используем старый метод.", e);
                mapCenterControls.classList.remove('hidden');
            }
        }

        function handleGeoRequest() {
            const geoLoader = document.getElementById('request-geo-loader');
            const geoText = document.getElementById('request-geo-text');
            geoText.textContent = 'Ждем ответа...';
            geoLoader.classList.remove('hidden');
            requestGeoBtn.disabled = true;
            startGeoTracking();
        }

        function startGeoTracking() {
             navigator.geolocation.getCurrentPosition(
                (position) => {
                    tg.HapticFeedback.notificationOccurred('success');
                    const latLng = [position.coords.latitude, position.coords.longitude];
                    if (!AppState.lastKnownLocation) {
                        map.panTo(latLng, {flying: true, duration: 1500}).then(() => map.setZoom(16));
                    }
                    AppState.lastKnownLocation = latLng;
                    
                    updateCurrentUserMarker(latLng);
                    mapCenterControls.classList.add('hidden');
                    recenterBtn.classList.remove('hidden');
                    modeSwitcher.classList.remove('hidden');
                    mapActionContainer.classList.remove('hidden');
                    
                    updateMapActionButton();
                    startWatchingLocation();
                },
                (error) => {
                    tg.HapticFeedback.notificationOccurred('error');
                    console.error("Geolocation error:", error);
                    showCustomAlert("Не удалось получить геолокацию. Проверьте разрешения в настройках вашего устройства.");
                    const geoText = document.getElementById('request-geo-text');
                    const geoLoader = document.getElementById('request-geo-loader');
                    geoText.textContent = 'Дать доступ к гео';
                    geoLoader.classList.add('hidden');
                    requestGeoBtn.disabled = false;
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        }
        
        function startWatchingLocation() {
            if (locationWatchId) {
                navigator.geolocation.clearWatch(locationWatchId);
            }
            locationWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    const latLng = [position.coords.latitude, position.coords.longitude];
                    AppState.lastKnownLocation = latLng;
                    updateCurrentUserMarker(latLng);

                    if (AppState.isRunning && AppState.currentPathPolyline) {
                        const newPoint = [latLng[1], latLng[0]]; // lng, lat для Turf.js
                        AppState.currentRunPath.push(newPoint);
                        AppState.currentPathPolyline.geometry.append(latLng);
                    }
                },
                (error) => {
                    console.warn("Ошибка отслеживания геолокации:", error.message);
                },
                { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
            );
        }

        // --- ЛОГИКА РЕЖИМОВ ---
        function startRun() {
            if (!AppState.lastKnownLocation) {
                showCustomAlert("Сначала определите свое местоположение."); return;
            }
            AppState.isRunning = true;
            tg.HapticFeedback.impactOccurred('heavy');
            tg.isClosingConfirmationEnabled = true;
            updateMapActionButton();
            
            AppState.currentRunPath = [ [AppState.lastKnownLocation[1], AppState.lastKnownLocation[0]] ];
            if (AppState.currentPathPolyline) map.geoObjects.remove(AppState.currentPathPolyline);
            AppState.currentPathPolyline = new ymaps.Polyline([AppState.lastKnownLocation], {}, { 
                strokeColor: 'var(--destructive-color)', 
                strokeWidth: 5, 
                strokeOpacity: 0.9 
            });
            map.geoObjects.add(AppState.currentPathPolyline);
        }
        async function stopRun() {
            return new Promise(resolve => {
                showCustomConfirm("Завершить пробежку и захватить территорию?", async () => {
                    AppState.isRunning = false;
                    tg.HapticFeedback.notificationOccurred('success');
                    tg.isClosingConfirmationEnabled = false;
                    updateMapActionButton();
                    if (AppState.currentRunPath.length > 3) {
                        await processRunPath();
                    } else {
                        showCustomAlert('Слишком короткий маршрут для захвата.');
                    }
                    if (AppState.currentPathPolyline) {
                        map.geoObjects.remove(AppState.currentPathPolyline);
                        AppState.currentPathPolyline = null;
                    }
                    resolve();
                });
            });
        }
        
        function handleMapClickForSpot(e) {
            const coords = e.get('coords');
            const locationWKT = `POINT(${coords[1]} ${coords[0]})`;
            showCustomConfirm("Создать новый спот в этом месте?", () => {
                showCreationModal('spot', { location: locationWKT });
            });
        }

        async function saveSpot() {
            const { location } = AppState.currentEditContext;
            const name = document.getElementById('creation-modal-name').value.trim();
            const description = document.getElementById('creation-modal-details').value.trim();
            const file = AppState.currentEditContext.file;

            if (!name || !description) {
                showCustomAlert("Название и описание обязательны.");
                return;
            }

            let photoUrl = null;
            if (file) {
                const filePath = `${telegramUser.id}/spots/${Date.now()}_${file.name}`;
                const { data, error } = await supabase.storage.from('photo').upload(filePath, file);
                if (error) {
                    console.error("Ошибка загрузки фото:", error);
                    showCustomAlert("Ошибка загрузки фото.");
                    return;
                }
                const { data: urlData } = supabase.storage.from('photo').getPublicUrl(data.path);
                photoUrl = urlData.publicUrl;
            }

            /*
            ВАЖНО: Для работы этого метода в вашей базе данных Supabase должна быть создана SQL-функция.
            Перейдите в SQL Editor в вашей панели Supabase и выполните следующий код:

            CREATE OR REPLACE FUNCTION create_spot(
                p_user_id bigint,
                p_name text,
                p_description text,
                p_photo_url text,
                p_location_wkt text
            )
            RETURNS void AS $$
            BEGIN
                INSERT INTO public.spots (user_id, name, description, photo_url, location)
                VALUES (p_user_id, p_name, p_description, p_photo_url, ST_SetSRID(ST_GeomFromText(p_location_wkt), 4326));
            END;
            $$ LANGUAGE plpgsql;

            Эта функция будет принимать данные и корректно преобразовывать текстовую геометрию (WKT) в тип geometry.
            */
            const { error } = await supabase.rpc('create_spot', {
                p_user_id: telegramUser.id,
                p_name: name,
                p_description: description,
                p_photo_url: photoUrl,
                p_location_wkt: location
            });

            if (error) {
                console.error("Ошибка сохранения спота через RPC:", error);
                showCustomAlert("Не удалось сохранить спот. Убедитесь, что SQL-функция 'create_spot' создана в базе данных.");
            } else {
                showCustomAlert("Спот успешно создан!");
                hideCreationModal();
                loadInitialMapData();
                renderMyProfileContent();
                if (AppState.currentFeedTab === 'spots') renderFeedSpots();
            }
        }
        
        function addSpotToMap(spot) {
            try {
                const wkt = spot.location_wkt || spot.location;
                const geoJsonPoint = parseWKT(wkt);

                if (!geoJsonPoint || geoJsonPoint.type !== 'Point') {
                    console.warn(`Не удалось обработать геолокацию спота ${spot.id}:`, wkt);
                    return;
                }
                
                const coords = [geoJsonPoint.coordinates[1], geoJsonPoint.coordinates[0]]; // lat, long
                const spotPlacemark = new ymaps.Placemark(coords, {
                    hintContent: escapeHTML(spot.name)
                }, {
                    preset: 'islands#violetDotIcon'
                });
                spotPlacemark.events.add('click', () => showDetailModal('spot', spot.id));
                
                spotCollection.add(spotPlacemark);
            } catch (e) {
                console.error(`Ошибка при добавлении спота ${spot.id} на карту.`, e, spot);
            }
        }

        function startRouteRecording() {
            if (!AppState.lastKnownLocation) {
                showCustomAlert("Сначала определите свое местоположение."); return;
            }
            AppState.isRunning = true;
            tg.HapticFeedback.impactOccurred('heavy');
            tg.isClosingConfirmationEnabled = true;
            updateMapActionButton();
            
            AppState.currentRunPath = [ [AppState.lastKnownLocation[1], AppState.lastKnownLocation[0]] ];
            if (AppState.currentPathPolyline) map.geoObjects.remove(AppState.currentPathPolyline);
            AppState.currentPathPolyline = new ymaps.Polyline([AppState.lastKnownLocation], {}, { 
                strokeColor: 'var(--button-color)', 
                strokeWidth: 5, 
                strokeOpacity: 0.9 
            });
            map.geoObjects.add(AppState.currentPathPolyline);
        }

        async function stopRouteRecording() {
             return new Promise(resolve => {
                AppState.isRunning = false;
                tg.HapticFeedback.notificationOccurred('success');
                tg.isClosingConfirmationEnabled = false;
                updateMapActionButton();
                
                if (AppState.currentRunPath.length < 2) {
                    showCustomAlert("Слишком короткий маршрут.");
                    if (AppState.currentPathPolyline) map.geoObjects.remove(AppState.currentPathPolyline);
                    AppState.currentPathPolyline = null;
                    resolve();
                    return;
                }
                
                const pathCoordinates = AppState.currentRunPath.map(p => `${p[0]} ${p[1]}`).join(', ');
                const pathWKT = `LINESTRING(${pathCoordinates})`;
                showCreationModal('route', { path: pathWKT });

                if (AppState.currentPathPolyline) {
                    map.geoObjects.remove(AppState.currentPathPolyline);
                    AppState.currentPathPolyline = null;
                }
                resolve();
            });
        }

        async function saveRoute() {
            const { path } = AppState.currentEditContext;
            const name = document.getElementById('creation-modal-name').value.trim();
            const description = document.getElementById('creation-modal-details').value.trim();
            
            if (!name) {
                showCustomAlert("Название обязательно.");
                return;
            }

            /*
            ВАЖНО: Для работы этого метода в вашей базе данных Supabase должна быть создана SQL-функция.
            Перейдите в SQL Editor в вашей панели Supabase и выполните следующий код:

            CREATE OR REPLACE FUNCTION create_route(
                p_user_id bigint,
                p_name text,
                p_description text,
                p_path_wkt text
            )
            RETURNS void AS $$
            BEGIN
                INSERT INTO public.routes (user_id, name, description, path)
                VALUES (p_user_id, p_name, p_description, ST_SetSRID(ST_GeomFromText(p_path_wkt), 4326));
            END;
            $$ LANGUAGE plpgsql;

            Эта функция будет принимать данные и корректно преобразовывать текстовую геометрию (WKT) в тип geometry.
            */
            const { error } = await supabase.rpc('create_route', {
                p_user_id: telegramUser.id,
                p_name: name,
                p_description: description,
                p_path_wkt: path
            });

            if (error) {
                console.error("Ошибка сохранения маршрута через RPC:", error);
                showCustomAlert("Не удалось сохранить маршрут. Убедитесь, что SQL-функция 'create_route' создана в базе данных.");
            } else {
                showCustomAlert("Маршрут сохранен!");
                hideCreationModal();
                loadInitialMapData();
                renderMyProfileContent();
                if (AppState.currentFeedTab === 'routes') renderFeedRoutes();
            }
        }
        
        function addRouteToMap(route) {
            try {
                const wkt = route.path_wkt || route.path;
                const geoJsonLine = parseWKT(wkt);

                if (!geoJsonLine || geoJsonLine.type !== 'LineString' || !Array.isArray(geoJsonLine.coordinates) || geoJsonLine.coordinates.length < 2) {
                    console.warn(`Не удалось обработать путь для маршрута ${route.id}:`, wkt);
                    return;
                }

                const yandexCoords = geoJsonLine.coordinates.map(c => [c[1], c[0]]); // lat, long
                const routePolyline = new ymaps.Polyline(yandexCoords, {}, {
                    strokeColor: '#ff7800', 
                    strokeWidth: 3
                });
                routePolyline.events.add('click', () => showDetailModal('route', route.id));
                routeCollection.add(routePolyline);
            } catch (e) {
                console.error(`Ошибка при добавлении маршрута ${route.id} на карту.`, e, route);
            }
        }

        function addEventToMap(event) {
            try {
                const wkt = event.meeting_point_wkt || event.meeting_point;
                const geoJsonPoint = parseWKT(wkt);

                if (!geoJsonPoint || geoJsonPoint.type !== 'Point') {
                    console.warn(`Не удалось обработать геолокацию мероприятия ${event.id}:`, wkt);
                    return;
                }
                
                const coords = [geoJsonPoint.coordinates[1], geoJsonPoint.coordinates[0]]; // lat, long
                const eventPlacemark = new ymaps.Placemark(coords, {
                    hintContent: escapeHTML(event.title)
                }, {
                    preset: 'islands#greenDotIcon' // A distinct icon for events
                });
                eventPlacemark.events.add('click', () => showDetailModal('event', event.id));
                
                eventCollection.add(eventPlacemark);
            } catch (e) {
                console.error(`Ошибка при добавлении мероприятия ${event.id} на карту.`, e, event);
            }
        }
        
        // --- ЗАГРУЗКА ДАННЫХ ---
        async function loadInitialMapData() {
            // Загрузка Спотов
            const { data: spots, error: spotsError } = await supabase.from('spots').select('*, location_wkt:location::text');
            if (spotsError) console.error("Ошибка загрузки спотов:", spotsError);
            else {
                AppState.allSpots = spots;
                spotCollection.removeAll();
                AppState.allSpots.forEach(addSpotToMap);
            }

            // Загрузка Маршрутов
            const { data: routes, error: routesError } = await supabase.from('routes').select('*, path_wkt:path::text');
            if (routesError) console.error("Ошибка загрузки маршрутов:", routesError);
            else {
                AppState.allRoutes = routes;
                routeCollection.removeAll();
                AppState.allRoutes.forEach(addRouteToMap);
            }
            
            // NEW: Загрузка Мероприятий
            const { data: events, error: eventsError } = await supabase.from('events').select('*, meeting_point_wkt:meeting_point::text');
            if(eventsError) console.error("Ошибка загрузки мероприятий:", eventsError);
            else {
                AppState.allEvents = events;
                eventCollection.removeAll();
                AppState.allEvents.forEach(addEventToMap);
            }
        }

        // --- SUPABASE и ОБРАБОТЧИКИ ---
        function listenToRealtimeChanges() {
            supabase.channel('public-changes')
              .on('postgres_changes', { event: '*', schema: 'public', table: 'profiles' }, fetchAllProfilesAndDraw)
              .on('postgres_changes', { event: '*', schema: 'public', table: 'posts' }, () => { renderFeedPosts(); renderMyProfileContent(); })
              .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'likes' }, payload => handleLikeChange(payload.new.post_id))
              .on('postgres_changes', { event: 'DELETE', schema: 'public', table: 'likes' }, payload => handleLikeChange(payload.old.post_id))
              .on('postgres_changes', { event: '*', schema: 'public', table: 'comments' }, (payload) => {
                  // Обновляем комментарии в открытых модальных окнах
              })
              .on('postgres_changes', { event: '*', schema: 'public', table: 'spots' }, () => { loadInitialMapData(); renderMyProfileContent(); renderFeedSpots(); })
              .on('postgres_changes', { event: '*', schema: 'public', table: 'routes' }, () => { loadInitialMapData(); renderMyProfileContent(); renderFeedRoutes(); })
              .on('postgres_changes', { event: '*', schema: 'public', table: 'events' }, () => { loadInitialMapData(); renderMyProfileContent(); renderFeedEvents(); })
              .on('postgres_changes', { event: '*', schema: 'public', table: 'event_participants' }, (payload) => {
                  const eventId = payload.new?.event_id || payload.old?.event_id;
                  if (eventId) {
                      updateEventCard(eventId);
                      if (participantsModal.classList.contains('visible') && AppState.currentDetailContext.id === eventId) {
                          showParticipants(eventId);
                      }
                  }
              })
              .subscribe();
        }
        
        function handleLikeChange(postId) {
            // Эта функция может быть расширена для обновления только конкретного поста, а не всей ленты.
            renderFeedPosts();
        }

        function setupStaticEventListeners() {
            tg.onEvent('themeChanged', () => applyTheme(tg.themeParams));
            tg.onEvent('backButtonClicked', () => {
                if (participantsModal.classList.contains('visible')) hideParticipantsModal();
                else if (eventCreationModal.classList.contains('visible')) hideEventCreationModal();
                else if (commentsModal.classList.contains('visible')) hideCommentsModal();
                else if (detailModal.classList.contains('visible')) hideDetailModal();
                else if (creationModal.classList.contains('visible')) hideCreationModal();
                else if (simplePostModal.classList.contains('visible')) hideSimplePostModal();
                else if (qrModal.classList.contains('visible')) hideQrModal();
            });
            tg.onEvent('qrTextReceived', (data) => {
                if (data.data) {
                    try {
                        const url = new URL(data.data);
                        const startPayload = url.searchParams.get('startapp');
                        if (startPayload) {
                            handleStartParam({ start_param: startPayload });
                        }
                    } catch (e) {
                        console.error("Invalid QR code data", e);
                        showCustomAlert("Неверный QR-код.");
                    }
                }
            });
            tg.SettingsButton.onClick(() => {
                tg.HapticFeedback.impactOccurred('light');
                tg.openTelegramLink(`https://t.me/${BOT_USERNAME}`);
            });
        }

        function setupDynamicEventListeners() {
            document.getElementById('mode-capture').addEventListener('click', () => setMapMode('capture'));
            document.getElementById('mode-spots').addEventListener('click', () => setMapMode('spots'));
            document.getElementById('mode-routes').addEventListener('click', () => setMapMode('routes'));
            
            document.getElementById('save-creation-btn').addEventListener('click', handleSave);
            
            // --- ОБРАБОТЧИКИ ДЛЯ ВЫБОРА ФОТО ---
            document.getElementById('simple-post-gallery-btn').addEventListener('click', () => {
                AppState.photoContext = 'simple';
                document.getElementById('gallery-input').click();
            });
            document.getElementById('simple-post-camera-btn').addEventListener('click', () => {
                AppState.photoContext = 'simple';
                document.getElementById('camera-input').click();
            });
            document.getElementById('creation-gallery-btn').addEventListener('click', () => {
                AppState.photoContext = 'creation';
                document.getElementById('gallery-input').click();
            });
            document.getElementById('creation-camera-btn').addEventListener('click', () => {
                AppState.photoContext = 'creation';
                document.getElementById('camera-input').click();
            });
            document.getElementById('camera-input').addEventListener('change', handleFileSelect);
            document.getElementById('gallery-input').addEventListener('change', handleFileSelect);

            requestGeoBtn.addEventListener('click', handleGeoRequest);
            recenterBtn.addEventListener('click', () => {
                tg.HapticFeedback.impactOccurred('medium');
                if (AppState.lastKnownLocation) map.panTo(AppState.lastKnownLocation, {flying: true});
            });
            
            scanQrBtn.addEventListener('click', () => {
                tg.HapticFeedback.impactOccurred('light');
                tg.showScanQrPopup({ text: 'Наведите на QR-код другого игрока' });
            });

            shareProfileBtn.addEventListener('click', () => {
                shareContent('user', telegramUser.id, telegramUser.id);
            });
            
            showQrBtn.addEventListener('click', showQrModal);
            mapActionBtn.addEventListener('click', mapActionButtonHandler);
            feedCreateBtn.onclick = showSimplePostModal; // Изначально на создание поста
            
            // Глобальный обработчик для динамических кнопок
            document.body.addEventListener('click', (event) => {
                const button = event.target.closest('[data-action]');
                if (!button) return;

                const action = button.dataset.action;
                const id = button.dataset.id;
                if (!action || !id) return;
                
                switch(action) {
                    case 'like-post': toggleLike(button, id, 'post'); break;
                    case 'comment-post': showPostComments(id); break;
                    case 'like-event': toggleLike(button, id, 'event'); break;
                    case 'comment-event': showDetailModal('event', id); break; // Открываем детали для комментирования
                    case 'join-event': joinEvent(id); break;
                    case 'leave-event': leaveEvent(id); break;
                    case 'show-participants': showParticipants(id); break;
                }
            });
        }
        
        function showFallbackScreen(title, message, showRetryButton = false) {
            fallbackContent.innerHTML = `
                <h1 class="text-2xl font-bold mb-4 ${showRetryButton ? 'text-red-500' : ''}">${escapeHTML(title)}</h1>
                <p class="mb-6" style="color: var(--hint-color);">${escapeHTML(message)}</p>
                ${showRetryButton ? `<button onclick="window.location.reload()" class="font-bold py-3 px-6 rounded-full" style="background-color: var(--button-color); color: var(--button-text-color);">Попробовать снова</button>` : ''}
            `;
            initialLoader.classList.add('hidden');
            fallbackScreen.classList.remove('hidden');
        }

        function applyTheme(themeParams) {
             const root = document.documentElement;
             root.style.setProperty('--bg-color', themeParams.bg_color || '#f3f4f6');
             root.style.setProperty('--secondary-bg-color', themeParams.secondary_bg_color || '#ffffff');
             root.style.setProperty('--text-color', themeParams.text_color || '#1f2937');
             root.style.setProperty('--hint-color', themeParams.hint_color || '#6b7280');
             root.style.setProperty('--button-color', themeParams.button_color || '#3b82f6');
             root.style.setProperty('--button-text-color', themeParams.button_text_color || '#ffffff');
             root.style.setProperty('--border-color', themeParams.bg_color ? shadeColor(themeParams.bg_color, -10) : '#e5e7eb');
             
             const buttonColorRgb = hexToRgb(themeParams.button_color || '#3b82f6');
             if (buttonColorRgb) root.style.setProperty('--button-color-rgb', buttonColorRgb.join(', '));
             
             const secondaryBgRgb = hexToRgb(themeParams.secondary_bg_color || '#ffffff');
             if (secondaryBgRgb) root.style.setProperty('--secondary-bg-color-rgb', secondaryBgRgb.join(', '));

             tg.setHeaderColor(themeParams.secondary_bg_color || '#ffffff');
             tg.setBackgroundColor(themeParams.bg_color || '#f3f4f6');
       }
        
        async function upsertUserProfile() {
            if (!telegramUser) throw new Error("Пользователь Telegram не определен для upsertUserProfile.");

            const { data, error } = await supabase.from('profiles').select('*').eq('id', telegramUser.id).single();
            
            if (error && error.code !== 'PGRST116') {
                console.error("Ошибка получения профиля:", error); 
                throw error; 
            } 
            
            if (data) {
                AppState.userProfile.color = data.color;
                AppState.userProfile.territory = parseWKT(data.territory_wkt) || parseWKT(data.territory) || data.territory;
            } else {
                AppState.userProfile.color = generateColorFromId(telegramUser.id);
                const { error: insertError } = await supabase.from('profiles').insert({ 
                    id: telegramUser.id, 
                    name: telegramUser.first_name, 
                    color: AppState.userProfile.color, 
                    area: 0, 
                    photo_url: telegramUser.photo_url || null, 
                    territory: null 
                });
                if (insertError) { 
                    console.error("Ошибка создания профиля:", insertError); 
                    throw insertError; 
                }
            }
        }
        
        async function processRunPath() {
            const startPoint = AppState.currentRunPath[0];
            const endPoint = AppState.currentRunPath[AppState.currentRunPath.length - 1];
            const distance = turf.distance(turf.point(startPoint), turf.point(endPoint), { units: 'meters' });
            if (distance > 50) {
                showCustomAlert('Маршрут не замкнут. Вернитесь к точке старта (в радиус 50м) для захвата.');
                return;
            }
            AppState.currentRunPath.push(startPoint);
            const line = turf.lineString(AppState.currentRunPath);
            const polygonized = turf.polygonize(line);
            if (polygonized.features.length === 0) {
                showCustomAlert('Не удалось сформировать замкнутую территорию. Вероятно, маршрут пересекал сам себя.');
                return;
            }
            let newCapture = polygonized.features[0];
            if (polygonized.features.length > 1) {
                try {
                    newCapture = turf.union(...polygonized.features);
                } catch (e) {
                    console.error("Turf union error:", e);
                }
            }
            await updateTerritory(newCapture);
        }

        async function updateTerritory(newCapture) {
            try {
                let combinedTerritory = AppState.userProfile.territory ? turf.union(AppState.userProfile.territory, newCapture) : newCapture;
                AppState.userProfile.territory = turf.cleanCoords(combinedTerritory);
                
                await saveUserData();
                refreshAllStats();
                tg.HapticFeedback.notificationOccurred('success');
                const area = turf.area(newCapture);
                const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;
                showCreationModal('post', { 
                    captureData: newCapture,
                    area_captured: area,
                    area_captured_formatted: formattedArea
                });
            } catch (error) {
                console.error("Ошибка в updateTerritory:", error);
                showCustomAlert("Ошибка обработки территории.");
            }
        }

        async function saveUserData() {
            let area = AppState.userProfile.territory ? turf.area(AppState.userProfile.territory) : 0;
            const userData = { id: telegramUser.id, name: telegramUser.first_name, photo_url: telegramUser.photo_url || null, color: AppState.userProfile.color, territory: AppState.userProfile.territory, area: area, updated_at: new Date().toISOString() };
            const { error } = await supabase.from('profiles').upsert(userData);
            if (error) console.error('Error saving user data:', error);
        }

        async function handlePostSubmission() {
            const { captureData, area_captured } = AppState.currentEditContext;
            const title = document.getElementById('creation-modal-name').value.trim();
            const file = AppState.currentEditContext.file;
            
            if (!title) { showCustomAlert("Пожалуйста, введите название."); return; }

            let photoUrl = null;
            if (file) {
                const filePath = `${telegramUser.id}/${Date.now()}_${file.name}`;
                const { data, error } = await supabase.storage.from('photo').upload(filePath, file);
                if (error) { console.error("Error uploading photo:", error); showCustomAlert("Не удалось загрузить фото."); return; }
                photoUrl = supabase.storage.from('photo').getPublicUrl(data.path).data.publicUrl;
            }

            const postData = {
                user_id: telegramUser.id,
                title: title,
                description: null,
                photo_url: photoUrl,
                territory_captured: captureData,
                area_captured: area_captured,
                user_name: telegramUser.first_name,
                user_avatar_url: telegramUser.photo_url,
                user_color: AppState.userProfile.color
            };

            const { error: postError } = await supabase.from('posts').insert(postData);
            
            if (postError) {
                console.error("Error saving post:", postError); showCustomAlert("Не удалось сохранить пост.");
            } else {
                showCustomAlert("Пост успешно опубликован!");
                hideCreationModal();
            }
        }
        
        async function handleSimplePostSave() {
            const description = document.getElementById('simple-post-details').value.trim();
            const file = AppState.simplePostContext?.file;

            if (!description) {
                showCustomAlert("Пожалуйста, введите текст поста.");
                return;
            }

            let photoUrl = null;
            if (file) {
                const filePath = `${telegramUser.id}/posts/${Date.now()}_${file.name}`;
                const { data, error } = await supabase.storage.from('photo').upload(filePath, file);
                if (error) { console.error("Error uploading photo:", error); showCustomAlert("Не удалось загрузить фото."); return; }
                photoUrl = supabase.storage.from('photo').getPublicUrl(data.path).data.publicUrl;
            }

            const postData = {
                user_id: telegramUser.id,
                title: description.substring(0, 50) + (description.length > 50 ? '...' : ''),
                description: description,
                photo_url: photoUrl,
                user_name: telegramUser.first_name,
                user_avatar_url: telegramUser.photo_url,
                user_color: AppState.userProfile.color
            };

            const { error: postError } = await supabase.from('posts').insert(postData);
            
            if (postError) {
                console.error("Error saving post:", postError); showCustomAlert("Не удалось сохранить пост.");
            } else {
                showCustomAlert("Пост успешно опубликован!");
                hideSimplePostModal();
            }
        }

        async function fetchAllProfilesAndDraw() {
            let { data: profiles, error } = await supabase.from('profiles').select('*, territory_wkt:territory::text');
            if (error) { console.error("Error fetching profiles:", error); return; }
            AppState.allProfilesData = profiles;
            
            territoriesCollection.removeAll();
            AppState.allUserLayers = {};

            profiles.forEach(profile => {
                if (telegramUser && profile.id === telegramUser.id) {
                    AppState.userProfile.territory = parseWKT(profile.territory_wkt) || profile.territory;
                    AppState.userProfile.color = profile.color;
                    refreshAllStats();
                }
                const territoryGeoJson = parseWKT(profile.territory_wkt || profile.territory);
                if (territoryGeoJson) {
                    const territoryObject = ymaps.geoQuery(territoryGeoJson).addTo(territoriesCollection);
                    territoryObject.setOptions({
                        fillColor: profile.color,
                        fillOpacity: 0.4,
                        strokeColor: profile.color,
                        strokeWidth: 2,
                        strokeOpacity: 0.8
                    });
                }
            });
            updateLeaderboard(profiles);
        }

        function updateLeaderboard(profiles) {
            profiles.sort((a, b) => (b.area || 0) - (a.area || 0));
            leaderboardDiv.innerHTML = profiles.map((u, index) => {
                const isCurrentUser = telegramUser && u.id === telegramUser.id;
                const name = escapeHTML(u.name);
                const displayName = isCurrentUser ? `${name} (Вы)` : name;
                const avatar = u.photo_url || `https://placehold.co/50x50/E5E7EB/4B5563?text=${name.charAt(0)}`;
                const area = u.area || 0;
                const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;
                return `<div class="card-bg rounded-xl shadow-md p-4 flex items-center space-x-4 cursor-pointer hover:bg-gray-50 transition" onclick="showDetailModal('user', ${u.id})">
                                    <span class="text-xl font-bold w-8" style="color: var(--hint-color);">${index + 1}</span>
                                    <img src="${avatar}" class="w-12 h-12 rounded-full" alt="avatar">
                                    <div class="flex-grow">
                                        <p class="font-bold">${displayName}</p>
                                        <p class="text-sm" style="color: var(--hint-color);">${formattedArea}</p>
                                    </div>
                                </div>`
            }).join('');
        }

        function refreshAllStats() {
            let area = 0;
            if (AppState.userProfile.territory) {
                try {
                    area = turf.area(AppState.userProfile.territory);
                } catch(e) {
                    console.warn("Could not calculate area for user territory", e);
                    area = 0;
                }
            }
            if (isNaN(area)) area = 0;
            const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;
            profileAreaDisplay.textContent = formattedArea;
        }

        async function renderFeedPosts() {
            const container = document.getElementById('feed-content-posts');
            container.innerHTML = '<div class="text-center p-8"><svg class="animate-spin mx-auto h-8 w-8 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></div>';
            
            const { data: posts, error: postsError } = await supabase.from('posts').select('*').order('created_at', { ascending: false });
            if (postsError) { console.error("Error fetching posts:", postsError); return; }
            
            if (posts.length === 0) {
                container.innerHTML = '<p class="text-center text-gray-500 py-8">В ленте пока нет постов.</p>';
                return;
            }
            const postIds = posts.map(p => p.id);
            const { data: likes, error: likesError } = await supabase.from('likes').select('*').in('post_id', postIds);
            const { data: comments, error: commentsError } = await supabase.from('comments').select('id, post_id').in('post_id', postIds);
            if (likesError || commentsError) { console.error("Error fetching activity:", likesError, commentsError); return; }
            const likesByPost = (likes || []).reduce((acc, like) => { (acc[like.post_id] = acc[like.post_id] || []).push(like); return acc; }, {});
            const commentsByPost = (comments || []).reduce((acc, comment) => { (acc[comment.post_id] = acc[comment.post_id] || []).push(comment); return acc; }, {});
            
            container.innerHTML = posts.map(post => generatePostHTML(post, likesByPost[post.id] || [], commentsByPost[post.id] || [])).join('');
            
            posts.forEach(post => {
                if (post.territory_captured) {
                    renderMiniMapForPost(post, container);
                }
            });

            if (scrollToPostId) {
                const postElement = document.getElementById(`post-${scrollToPostId}`);
                if (postElement) {
                    setTimeout(() => {
                        postElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        postElement.style.transition = 'background-color 0.5s ease';
                        postElement.style.backgroundColor = 'rgba(var(--button-color-rgb), 0.15)';
                        setTimeout(() => {
                            postElement.style.backgroundColor = '';
                        }, 2500);
                    }, 200);
                }
                scrollToPostId = null;
            }
        }
        
        function renderMiniMapForPost(post, container) {
             const mapContainer = container.querySelector(`#mini-map-${post.id}`);
             if (mapContainer) {
                 const miniMap = new ymaps.Map(mapContainer, { center: [55.75, 37.62], zoom: 9, controls: [] });
                 const territoryObject = ymaps.geoQuery(post.territory_captured).addTo(miniMap);
                 territoryObject.setOptions({
                     fillColor: post.user_color, fillOpacity: 0.5,
                     strokeColor: post.user_color, strokeWidth: 2, strokeOpacity: 0.8
                 });
                 miniMap.setBounds(territoryObject.getBounds(), { checkZoomRange: true, zoomMargin: 10 });
             }
        }
        
        function generatePostHTML(post, likes, comments) {
            const avatar = post.user_avatar_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${post.user_name.charAt(0)}`;
            const area = post.area_captured || 0;
            const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;
            const userHasLiked = telegramUser && likes.some(like => like.user_id === telegramUser.id);
            return `<div class="card-bg rounded-2xl shadow-lg overflow-hidden" id="post-${post.id}">
                        <div class="p-4">
                            <div class="flex items-center space-x-3 cursor-pointer" onclick="showDetailModal('user', ${post.user_id})"><img src="${avatar}" class="w-10 h-10 rounded-full" alt="avatar"><div><p class="font-bold">${escapeHTML(post.user_name)}</p><p class="text-xs" style="color: var(--hint-color);">${new Date(post.created_at).toLocaleString('ru-RU')}</p></div></div>
                            <p class="mt-4 font-semibold">${escapeHTML(post.title)}</p>
                            ${post.description ? `<p class="mt-2 text-sm" style="color: var(--text-color);">${escapeHTML(post.description)}</p>` : ''}
                        </div>
                        ${post.photo_url ? `<img src="${post.photo_url}" class="w-full h-64 object-cover" alt="Post photo">` : ''}
                        ${post.territory_captured ? `<div id="mini-map-${post.id}" class="h-48 w-full mini-map"></div>` : ''}
                        <div class="p-4">
                            ${post.area_captured ? `<p class="font-semibold">Захвачено: <span class="font-bold" style="color: var(--button-color);">${formattedArea}</span></p>` : ''}
                            <div class="flex items-center justify-between mt-3">
                                <div class="flex items-center space-x-6" style="color: var(--hint-color);">
                                    <button class="like-btn flex items-baseline space-x-1 hover:text-red-500 transition ${userHasLiked ? 'liked' : ''}" data-action="like-post" data-id="${post.id}">
                                        <i class="fa-${userHasLiked ? 'solid' : 'regular'} fa-heart h-6 w-6"></i>
                                        <span data-likes-count>${likes.length}</span>
                                    </button>
                                    <button class="flex items-baseline space-x-1 hover:text-blue-500 transition" data-action="comment-post" data-id="${post.id}">
                                        <i class="fa-regular fa-comment h-6 w-6"></i>
                                        <span>${comments.length}</span>
                                    </button>
                                </div>
                                <button class="flex items-center space-x-1 hover:text-blue-500 transition" onclick="shareContent('post', ${post.id}, ${post.user_id})" style="color: var(--hint-color);">
                                    <i class="fa-solid fa-arrow-up-from-bracket h-5 w-5"></i>
                                </button>
                            </div>
                        </div>
                    </div>`;
        }

        async function toggleLike(buttonElement, targetId, type) {
            if (!telegramUser) {
                showCustomAlert('Пользователь не определен. Попробуйте перезагрузить приложение.');
                return;
            }
            tg.HapticFeedback.impactOccurred('light');
            
            const hasLiked = buttonElement.classList.contains('liked');
            const countSpan = buttonElement.querySelector('[data-likes-count]');
            const icon = buttonElement.querySelector('i');
            let currentCount = parseInt(countSpan.textContent, 10);

            // Оптимистичное обновление UI
            buttonElement.classList.toggle('liked');
            icon.classList.toggle('fa-solid', !hasLiked);
            icon.classList.toggle('fa-regular', hasLiked);
            countSpan.textContent = hasLiked ? currentCount - 1 : currentCount + 1;

            try {
                const likeData = { user_id: telegramUser.id };
                if (type === 'post') likeData.post_id = targetId;
                if (type === 'event') likeData.event_id = targetId;

                if (hasLiked) {
                    await supabase.from('likes').delete().match(likeData);
                } else {
                    await supabase.from('likes').insert(likeData);
                }
            } catch (error) {
                console.error("Ошибка лайка:", error);
                // Откат UI в случае ошибки
                buttonElement.classList.toggle('liked');
                icon.classList.toggle('fa-solid');
                icon.classList.toggle('fa-regular');
                countSpan.textContent = currentCount;
                showCustomAlert('Не удалось обработать лайк. Попробуйте снова.');
            }
        }
        
        // --- СИСТЕМА КОММЕНТАРИЕВ (ОБЩАЯ) ---
        async function fetchComments(type, id) {
            let query = supabase.from('comments').select('*, profiles(id, name, photo_url)');
            
            if (type === 'post') query = query.eq('post_id', id);
            else if (type === 'spot') query = query.eq('spot_id', id);
            else if (type === 'route') query = query.eq('route_id', id);
            else if (type === 'event') query = query.eq('event_id', id);

            const { data, error } = await query.order('created_at', { ascending: true });
            return { data, error };
        }
        
        async function showPostComments(postId) {
            tg.HapticFeedback.impactOccurred('medium');
            tg.BackButton.show();
            AppState.currentReplyTarget = { type: 'post', id: postId, parentCommentId: null };
            cancelReply();
            
            const modalBody = document.getElementById('comments-modal-body');
            modalBody.innerHTML = '<div class="text-center p-8"><svg class="animate-spin mx-auto h-8 w-8 text-gray-500" ...></svg></div>';
            commentsModal.classList.add('visible');
            document.body.classList.add('modal-open');
            
            const { data: comments, error } = await fetchComments('post', postId);
            if (error) { modalBody.innerHTML = `<p class="text-center p-4 text-red-500">Ошибка загрузки комментариев</p>`; return; }

            renderCommentTree(comments, modalBody);
        }

        async function loadAndRenderComments(type, id, containerId) {
             const container = document.querySelector(`#${containerId}`);
             if (!container) return;
             container.innerHTML = '<p class="text-center text-gray-500">Загрузка комментариев...</p>';
             
             const { data: comments, error } = await fetchComments(type, id);
             if (error) { container.innerHTML = `<p class="text-center p-4 text-red-500">Ошибка загрузки</p>`; return; }

             renderCommentTree(comments, container, 'detail');
        }

        function renderCommentTree(comments, container, context = 'post') {
            const commentsByParent = (comments || []).reduce((acc, comment) => { (acc[comment.parent_comment_id || 'root'] = acc[comment.parent_comment_id || 'root'] || []).push(comment); return acc; }, {});
            const rootComments = commentsByParent['root'] || [];
            container.innerHTML = rootComments.length ? rootComments.map(c => generateCommentHTML(c, commentsByParent, context)).join('') : '<p class="text-center text-gray-500 py-4">Нет комментариев</p>';
        }

        function hideCommentsModal() {
            tg.BackButton.hide();
            commentsModal.classList.remove('visible');
            document.body.classList.remove('modal-open');
        }

        function generateCommentHTML(comment, commentsByParent, context = 'post') {
            const replies = commentsByParent[comment.id] || [];
            const profileName = comment.profiles ? escapeHTML(comment.profiles.name) : 'Аноним';
            const avatar = comment.profiles ? (comment.profiles.photo_url || `https://placehold.co/32x32/E5E7EB/4B5563?text=${profileName.charAt(0)}`) : 'https://placehold.co/32x32';
            const replyFn = context === 'post' ? 'setReplyMode' : 'setDetailReplyMode';
            const parentId = comment.post_id || comment.spot_id || comment.route_id || comment.event_id;

            return `<div class="flex items-start space-x-3 mt-4">
                        <img src="${avatar}" class="w-8 h-8 rounded-full">
                        <div class="flex-1">
                            <div class="rounded-lg p-2" style="background-color: var(--bg-color);">
                                <p class="font-bold text-sm">${profileName}</p>
                                <p class="text-sm">${escapeHTML(comment.content)}</p>
                            </div>
                            <div class="text-xs mt-1">
                                <button onclick="${replyFn}('${parentId}', ${comment.id}, '${profileName.replace(/'/g, "\\'")}')" class="font-medium" style="color: var(--hint-color);">Ответить</button>
                            </div>
                            <div class="pl-4 border-l-2">${replies.map(reply => generateCommentHTML(reply, commentsByParent, context)).join('')}</div>
                        </div>
                    </div>`;
        }
        
        function setReplyMode(postId, parentCommentId, parentAuthorName) {
            AppState.currentReplyTarget = { type: 'post', id: postId, parentCommentId };
            document.getElementById('reply-indicator-text').textContent = `Ответ: ${parentAuthorName}`;
            document.getElementById('reply-indicator').classList.remove('hidden');
            document.getElementById('main-comment-input').focus();
        }

        function cancelReply() {
            AppState.currentReplyTarget.parentCommentId = null;
            document.getElementById('reply-indicator').classList.add('hidden');
        }

        async function postComment() {
            const { type, id, parentCommentId } = AppState.currentReplyTarget;
            if (!id || !telegramUser) return;
            const inputElement = document.getElementById('main-comment-input');
            const content = inputElement.value.trim();
            if (!content) return;
            
            const commentData = { 
                post_id: id, user_id: telegramUser.id, 
                parent_comment_id: parentCommentId, content: content 
            };
            const { error } = await supabase.from('comments').insert(commentData);
            if (error) { showCustomAlert('Ошибка отправки'); } else { inputElement.value = ''; cancelReply(); }
        }

        function setDetailReplyMode(id, parentCommentId, parentAuthorName) {
            const contextType = AppState.currentDetailContext.type;
            AppState.currentReplyTarget = { type: contextType, id: id, parentCommentId: parentCommentId };

            const indicator = document.querySelector(`#${contextType}-comments-section #detail-reply-indicator`);
            if(indicator) {
                indicator.querySelector('#detail-reply-indicator-text').textContent = `Ответ: ${parentAuthorName}`;
                indicator.classList.remove('hidden');
                indicator.closest('div').querySelector('textarea').focus();
            }
        }
        
        function cancelDetailReply() {
            const contextType = AppState.currentDetailContext.type;
            AppState.currentReplyTarget.parentCommentId = null;
            const indicator = document.querySelector(`#${contextType}-comments-section #detail-reply-indicator`);
            if(indicator) indicator.classList.add('hidden');
        }

        async function postDetailComment() {
            const { type, id, parentCommentId } = AppState.currentReplyTarget;
            if (!id || !telegramUser) return;
            
            const inputElement = document.querySelector(`#${type}-comments-section textarea`);
            const content = inputElement.value.trim();
            if (!content) return;

            const commentData = {
                user_id: telegramUser.id,
                parent_comment_id: parentCommentId,
                content: content
            };
            commentData[`${type}_id`] = id;

            const { error } = await supabase.from('comments').insert(commentData);

            if (error) { 
                showCustomAlert('Ошибка отправки комментария.'); 
                console.error("Comment post error:", error);
            } else { 
                inputElement.value = ''; 
                cancelDetailReply();
                loadAndRenderComments(type, id, `${type}-comments-list`);
            }
        }

        function switchMainProfileTab(tabName) {
            document.querySelectorAll('#profile-view .profile-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('#profile-view .profile-tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`profile-tab-${tabName}`).classList.add('active');
            document.getElementById(`profile-content-${tabName}`).classList.add('active');
        }

        async function renderMyProfileContent() {
            if (!telegramUser) return;
            const userId = telegramUser.id;

            const [postsRes, spotsRes, routesRes, eventsRes] = await Promise.all([
                supabase.from('posts').select('*').eq('user_id', userId).order('created_at', { ascending: false }),
                supabase.from('spots').select('*, location_wkt:location::text').eq('user_id', userId).order('created_at', { ascending: false }),
                supabase.from('routes').select('*, path_wkt:path::text').eq('user_id', userId).order('created_at', { ascending: false }),
                supabase.rpc('get_user_events', { p_user_id: userId })
            ]);

            // Посты
            const posts = postsRes.data || [];
            const postIds = posts.map(p => p.id);
            const likesByPost = {};
            const commentsByPost = {};
            if (postIds.length > 0) {
                const { data: likes } = await supabase.from('likes').select('*').in('post_id', postIds);
                const { data: comments } = await supabase.from('comments').select('id, post_id').in('post_id', postIds);
                if(likes) likes.forEach(like => (likesByPost[like.post_id] = likesByPost[like.post_id] || []).push(like));
                if(comments) comments.forEach(comment => (commentsByPost[comment.post_id] = commentsByPost[comment.post_id] || []).push(comment));
            }
            const postsContainer = document.getElementById('profile-content-posts');
            postsContainer.innerHTML = posts.length > 0 ? posts.map(p => generatePostHTML(p, likesByPost[p.id] || [], commentsByPost[p.id] || [])).join('') : '<p class="text-center text-gray-500 py-4">У вас нет постов.</p>';
            document.getElementById('profile-tab-posts').textContent = `Посты (${posts.length})`;
            posts.forEach(p => renderMiniMapForPost(p, postsContainer));
            
            // Споты
            const spots = spotsRes.data || [];
            const spotsContainer = document.getElementById('profile-content-spots');
            spotsContainer.innerHTML = spots.length > 0 ? spots.map(s => generateMiniSpotHTML(s, false)).join('') : '<p class="text-center text-gray-500 py-4">У вас нет спотов.</p>';
            document.getElementById('profile-tab-spots').textContent = `Споты (${spots.length})`;

            // Маршруты
            const routes = routesRes.data || [];
            const routesContainer = document.getElementById('profile-content-routes');
            routesContainer.innerHTML = routes.length > 0 ? routes.map(generateMiniRouteHTML).join('') : '<p class="text-center text-gray-500 py-4">У вас нет маршрутов.</p>';
            document.getElementById('profile-tab-routes').textContent = `Маршруты (${routes.length})`;
            
            // Мероприятия
            const events = eventsRes.data || [];
            const eventsContainer = document.getElementById('profile-content-events');
            if (events.length > 0) {
                const eventHTML = await Promise.all(events.map(e => generateEventCardHTML(e)));
                eventsContainer.innerHTML = eventHTML.join('');
            } else {
                eventsContainer.innerHTML = '<p class="text-center text-gray-500 py-4">Вы не участвуете в мероприятиях.</p>';
            }
            document.getElementById('profile-tab-events').textContent = `Покатушки (${events.length})`;
        }
        
        // --- QR Code Modal ---
        function showQrModal() {
            tg.HapticFeedback.impactOccurred('light');
            const qrContainer = document.getElementById('qrcode');
            qrContainer.innerHTML = '';
            new QRCode(qrContainer, {
                text: `https://t.me/${BOT_USERNAME}?startapp=user_${telegramUser.id}`,
                width: 200, height: 200, colorDark : "#000000",
                colorLight : "#ffffff", correctLevel : QRCode.CorrectLevel.H
            });
            qrModal.classList.add('visible');
            document.body.classList.add('modal-open');
            tg.BackButton.show();
        }

        function hideQrModal() {
            qrModal.classList.remove('visible');
            document.body.classList.remove('modal-open');
            tg.BackButton.hide();
        }
        
        // --- Handle Start Param ---
        function handleStartParam() {
            const startParam = tg.initDataUnsafe.start_param;
            if (!startParam) return;

            const parts = startParam.split('_');
            const type = parts.length > 1 ? parts[0] : 'user';
            const id = parts.length > 1 ? parts[1] : startParam;
            const numericId = parseInt(id, 10);

            if (isNaN(numericId)) {
                console.warn("Invalid ID in start_param:", startParam);
                return;
            }

            setTimeout(() => {
                switch (type) {
                    case 'user': showDetailModal('user', numericId); break;
                    case 'post': showView('feed-view'); scrollToPostId = numericId; break;
                    case 'route': showDetailModal('route', numericId); break;
                    case 'spot': showDetailModal('spot', numericId); break;
                    case 'event': showDetailModal('event', numericId); break; // NEW
                    default:
                        console.warn("Unknown start_param type:", type);
                        if (/^\d+$/.test(startParam)) {
                            showDetailModal('user', parseInt(startParam));
                        }
                }
            }, 500); 
        }
        
        // --- Custom Alert/Confirm ---
        function showCustomAlert(message) { tg.showAlert(message); }
        function showCustomConfirm(message, callback) { tg.showConfirm(message, (ok) => { if (ok) callback(); }); }
        
        // =================================================================
        // --- НОВЫЙ ФУНКЦИОНАЛ: МЕРОПРИЯТИЯ (ПОКАТУШКИ) ---
        // =================================================================

        // --- Рендер ---
        async function renderFeedEvents() {
            const container = document.getElementById('feed-content-events');
            container.innerHTML = '<div class="text-center p-8"><svg class="animate-spin mx-auto h-8 w-8 text-gray-500" ...></svg></div>';
            
            try {
                const { data, error } = await supabase.from('events')
                    .select(`*, profiles(id, name, photo_url)`)
                    .order('event_time', { ascending: true });

                if (error) {
                    throw error;
                }
                if (data.length === 0) {
                    container.innerHTML = '<p class="text-center text-gray-500 py-8">Пока нет запланированных покатушек. Создайте первую!</p>';
                    return;
                }
                
                const eventsHTML = await Promise.all(data.map(event => generateEventCardHTML(event)));
                container.innerHTML = eventsHTML.join('');
                data.forEach(event => startCountdown(event.id, new Date(event.event_time)));

            } catch (error) {
                 console.error("Ошибка загрузки мероприятий:", error);
                 container.innerHTML = '<p class="text-center text-red-500 py-8">Не удалось загрузить мероприятия.</p>';
            }
        }
        
        async function renderFeedSpots() {
            const container = document.getElementById('feed-content-spots');
            container.innerHTML = '<div class="text-center p-8"><svg class="animate-spin mx-auto h-8 w-8 text-gray-500" ...></svg></div>';
            const { data, error } = await supabase.from('spots').select('*').order('created_at', { ascending: false }).limit(20);
            if(error) { container.innerHTML = '<p class="text-center text-red-500 py-8">Не удалось загрузить споты.</p>'; return; }
            if(data.length === 0) { container.innerHTML = '<p class="text-center text-gray-500 py-8">Спотов пока нет.</p>'; return; }
            container.innerHTML = data.map(s => generateMiniSpotHTML(s, true)).join('');
        }
        
        async function renderFeedRoutes() {
            const container = document.getElementById('feed-content-routes');
            container.innerHTML = '<div class="text-center p-8"><svg class="animate-spin mx-auto h-8 w-8 text-gray-500" ...></svg></div>';
            const { data, error } = await supabase.from('routes').select('*').order('created_at', { ascending: false }).limit(20);
            if(error) { container.innerHTML = '<p class="text-center text-red-500 py-8">Не удалось загрузить маршруты.</p>'; return; }
            if(data.length === 0) { container.innerHTML = '<p class="text-center text-gray-500 py-8">Маршрутов пока нет.</p>'; return; }
            container.innerHTML = data.map(generateMiniRouteHTML).join('');
        }

        async function generateEventCardHTML(event) {
            const author = event.profiles || { name: 'Аноним', photo_url: null };
            const avatar = author.photo_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${author.name.charAt(0)}`;
            const eventTime = new Date(event.event_time);
            
            let likes = [], participants = [];
            try {
                const { data: likesData } = await supabase.from('likes').select('user_id').eq('event_id', event.id);
                likes = likesData || [];
                const { data: participantsData } = await supabase.from('event_participants').select('user_id').eq('event_id', event.id);
                participants = participantsData || [];
            } catch (e) {
                console.error(`Failed to fetch activity for event ${event.id}`, e);
            }
            
            const userHasLiked = telegramUser && likes.some(l => l.user_id === telegramUser.id);
            const userIsParticipant = telegramUser && participants.some(p => p.user_id === telegramUser.id);

            const participantButton = userIsParticipant 
                ? `<button data-action="leave-event" data-id="${event.id}" class="w-full font-bold py-3 px-4 rounded-full transition-all text-white bg-red-500 hover:bg-red-600">Не пойду</button>`
                : `<button data-action="join-event" data-id="${event.id}" class="w-full font-bold py-3 px-4 rounded-full transition-all text-white bg-green-500 hover:bg-green-600">Участвую!</button>`;
            
            return `<div class="card-bg rounded-2xl shadow-lg overflow-hidden border border-transparent hover:border-blue-400 transition-all duration-300" id="event-${event.id}">
                        <div class="p-4">
                            <div id="event-timer-${event.id}" class="text-center font-bold text-lg mb-4 p-2 rounded-lg" style="background-color: var(--bg-color); color: var(--button-color);"></div>
                            <div class="flex items-center space-x-3 cursor-pointer mb-4" onclick="showDetailModal('user', ${author.id})">
                                <img src="${avatar}" class="w-10 h-10 rounded-full" alt="avatar">
                                <div><p class="font-bold">${escapeHTML(author.name)}</p><p class="text-xs" style="color: var(--hint-color);">Организатор</p></div>
                            </div>
                            <h3 class="text-xl font-bold cursor-pointer hover:text-blue-600" onclick="showDetailModal('event', '${event.id}')">${escapeHTML(event.title)}</h3>
                            <p class="mt-2 text-sm text-gray-600">${escapeHTML(event.description)}</p>
                            <div class="mt-4 p-3 rounded-lg" style="background-color: var(--bg-color);">
                                <div class="flex items-center space-x-3">
                                    <i class="fa-solid fa-calendar-alt w-5 text-center" style="color: var(--hint-color);"></i>
                                    <span class="text-sm font-semibold">${eventTime.toLocaleString('ru-RU', {dateStyle: 'long', timeStyle: 'short'})}</span>
                                </div>
                            </div>
                        </div>
                        <div class="p-4 border-t" style="border-color: var(--border-color);">
                            <div class="flex items-center justify-between mb-4">
                                <div class="flex items-center space-x-6" style="color: var(--hint-color);">
                                    <button class="like-btn flex items-baseline space-x-1 hover:text-red-500 transition ${userHasLiked ? 'liked' : ''}" data-action="like-event" data-id="${event.id}">
                                        <i class="fa-${userHasLiked ? 'solid' : 'regular'} fa-heart h-6 w-6"></i>
                                        <span data-likes-count>${likes.length}</span>
                                    </button>
                                    <button class="flex items-baseline space-x-1 hover:text-blue-500 transition" data-action="show-participants" data-id="${event.id}">
                                        <i class="fa-regular fa-user h-6 w-6"></i>
                                        <span data-participants-count>${participants.length}</span>
                                    </button>
                                </div>
                                <button class="flex items-center space-x-1 hover:text-blue-500 transition" onclick="shareContent('event', '${event.id}', ${author.id})" style="color: var(--hint-color);">
                                    <i class="fa-solid fa-arrow-up-from-bracket h-5 w-5"></i>
                                </button>
                            </div>
                            ${participantButton}
                        </div>
                    </div>`;
        }
        
        // --- Создание/Редактирование ---
        async function showEventCreationModal() {
            tg.HapticFeedback.impactOccurred('light');
            
            // Сброс формы
            document.getElementById('event-title').value = '';
            document.getElementById('event-description').value = '';
            document.getElementById('event-datetime').value = '';
            AppState.eventCreationContext = {};

            // Загрузка маршрутов пользователя
            const select = document.getElementById('event-route-select');
            select.innerHTML = '<option value="">Без маршрута</option>';
            const { data: routes, error } = await supabase.from('routes').select('id, name').eq('user_id', telegramUser.id);
            if (error) console.error("Ошибка загрузки маршрутов:", error);
            else routes.forEach(r => select.innerHTML += `<option value="${r.id}">${escapeHTML(r.name)}</option>`);
            
            eventCreationModal.classList.add('visible');
            document.body.classList.add('modal-open');
            tg.BackButton.show();

            // Инициализация карты для выбора точки
            setTimeout(initEventPickerMap, 100);
        }
        
        function hideEventCreationModal() {
            eventCreationModal.classList.remove('visible');
            document.body.classList.remove('modal-open');
            tg.BackButton.hide();
            if (eventPickerMap) {
                eventPickerMap.destroy();
                eventPickerMap = null;
            }
        }
        
        function initEventPickerMap() {
            if(eventPickerMap) eventPickerMap.destroy();
            const center = AppState.lastKnownLocation || [55.75, 37.62];
            eventPickerMap = new ymaps.Map('event-map-picker', { center: center, zoom: 12, controls: [] });
            
            let placemark;
            eventPickerMap.events.add('click', (e) => {
                const coords = e.get('coords');
                AppState.eventCreationContext.meetingPoint = `POINT(${coords[1]} ${coords[0]})`;
                if (placemark) {
                    placemark.geometry.setCoordinates(coords);
                } else {
                    placemark = new ymaps.Placemark(coords);
                    eventPickerMap.geoObjects.add(placemark);
                }
                document.getElementById('event-map-hint').textContent = 'Точка выбрана!';
                document.getElementById('event-map-hint').style.color = 'var(--success-color)';
            });
        }
        
        async function handleEventSave() {
            const title = document.getElementById('event-title').value.trim();
            const description = document.getElementById('event-description').value.trim();
            const event_time = document.getElementById('event-datetime').value;
            const route_id = document.getElementById('event-route-select').value || null;
            const meeting_point = AppState.eventCreationContext.meetingPoint;

            if (!title || !description || !event_time || !meeting_point) {
                showCustomAlert("Пожалуйста, заполните все поля и выберите точку сбора на карте.");
                return;
            }

            const { data, error } = await supabase.from('events').insert({
                creator_id: telegramUser.id,
                title, description, event_time, route_id, meeting_point
            }).select().single();
            
            if (error) {
                console.error("Ошибка создания мероприятия:", error);
                showCustomAlert("Не удалось создать мероприятие.");
            } else {
                // Автоматически добавляем создателя в участники
                await supabase.from('event_participants').insert({ event_id: data.id, user_id: telegramUser.id });
                showCustomAlert("Мероприятие успешно создано!");
                hideEventCreationModal();
                renderCurrentFeedTab();
            }
        }
        
        // --- Участие ---
        async function joinEvent(eventId) {
            tg.HapticFeedback.impactOccurred('light');
            const { error } = await supabase.from('event_participants').insert({ event_id: eventId, user_id: telegramUser.id });
            if (error) {
                console.error("Ошибка присоединения к мероприятию:", error);
                showCustomAlert("Не удалось присоединиться.");
            } else {
                updateEventCard(eventId);
            }
        }
        
        async function leaveEvent(eventId) {
            tg.HapticFeedback.impactOccurred('light');
            const { error } = await supabase.from('event_participants').delete().match({ event_id: eventId, user_id: telegramUser.id });
            if (error) {
                console.error("Ошибка выхода из мероприятия:", error);
                showCustomAlert("Не удалось отменить участие.");
            } else {
                updateEventCard(eventId);
            }
        }
        
        async function showParticipants(eventId) {
            tg.HapticFeedback.impactOccurred('light');
            const modalBody = document.getElementById('participants-modal-body');
            modalBody.innerHTML = '<div class="text-center p-8"><svg class="animate-spin mx-auto h-8 w-8 text-gray-500" ...></svg></div>';
            participantsModal.classList.add('visible');
            document.body.classList.add('modal-open');
            tg.BackButton.show();

            const { data, error } = await supabase.from('event_participants')
                .select('profiles(*)')
                .eq('event_id', eventId);
            
            if (error) {
                modalBody.innerHTML = '<p class="text-red-500">Не удалось загрузить список.</p>';
                return;
            }
            
            if (data.length === 0) {
                 modalBody.innerHTML = '<p class="text-gray-500">Пока никто не участвует.</p>';
                 return;
            }

            modalBody.innerHTML = data.map(p => {
                const user = p.profiles;
                const avatar = user.photo_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${user.name.charAt(0)}`;
                return `<div class="flex items-center space-x-3 cursor-pointer p-2 rounded-lg hover:bg-gray-100" onclick="showDetailModal('user', ${user.id})">
                            <img src="${avatar}" class="w-10 h-10 rounded-full">
                            <span class="font-semibold">${escapeHTML(user.name)}</span>
                        </div>`;
            }).join('');
        }
        
        function hideParticipantsModal() {
            participantsModal.classList.remove('visible');
            document.body.classList.remove('modal-open');
            // Do not hide back button if detail modal is underneath
            if (!detailModal.classList.contains('visible')) {
                tg.BackButton.hide();
            }
        }

        // --- Таймер ---
        function startCountdown(eventId, eventTime) {
            const timerElement = document.getElementById(`event-timer-${eventId}`);
            if (!timerElement) return;

            const updateTimer = () => {
                const now = new Date();
                const diff = eventTime.getTime() - now.getTime();

                if (diff <= 0) {
                    timerElement.textContent = "Мероприятие началось!";
                    timerElement.style.color = 'var(--success-color)';
                    const timerIndex = countdownTimers.findIndex(t => t.id === eventId);
                    if (timerIndex > -1) {
                        clearInterval(countdownTimers[timerIndex].interval);
                        countdownTimers.splice(timerIndex, 1);
                    }
                    return;
                }

                const d = Math.floor(diff / (1000 * 60 * 60 * 24));
                const h = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const m = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                const s = Math.floor((diff % (1000 * 60)) / 1000);

                let timerText = "До начала: ";
                if(d > 0) timerText += `${d}д `;
                timerText += `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
                timerElement.textContent = timerText;
            };

            updateTimer();
            const intervalId = setInterval(updateTimer, 1000);
            countdownTimers.push({ id: eventId, interval: intervalId });
        }

        function clearCountdownTimers() {
            countdownTimers.forEach(timer => clearInterval(timer.interval));
            countdownTimers = [];
        }
        
        // --- ПРИВЯЗКА ГЛОБАЛЬНЫХ ФУНКЦИЙ И ЗАПУСК ---
        window.showView = showView;
        window.switchFeedTab = switchFeedTab;
        window.hideDetailModal = hideDetailModal;
        window.toggleLike = toggleLike;
        window.showPostComments = showPostComments;
        window.hideCommentsModal = hideCommentsModal;
        window.setReplyMode = setReplyMode;
        window.cancelReply = cancelReply;
        window.postComment = postComment;
        window.showDetailModal = showDetailModal;
        window.switchProfileTab = switchProfileTab;
        window.switchMainProfileTab = switchMainProfileTab;
        window.navigateToMapObject = navigateToMapObject;
        window.hideSimplePostModal = hideSimplePostModal;
        window.handleSimplePostSave = handleSimplePostSave;
        window.hideCreationModal = hideCreationModal;
        window.postDetailComment = postDetailComment;
        window.setDetailReplyMode = setDetailReplyMode;
        window.cancelDetailReply = cancelDetailReply;
        window.hideQrModal = hideQrModal;
        window.shareContent = shareContent;
        // NEW
        window.showEventCreationModal = showEventCreationModal;
        window.hideEventCreationModal = hideEventCreationModal;
        window.handleEventSave = handleEventSave;
        window.joinEvent = joinEvent;
        window.leaveEvent = leaveEvent;
        window.showParticipants = showParticipants;
        window.hideParticipantsModal = hideParticipantsModal;
        
        document.addEventListener('DOMContentLoaded', () => ymaps.ready(runApp));
    </script>
</body>
</html>
```

Я обновил код. Теперь для сохранения спотов и маршрутов используются специальные функции в базе данных, что повышает надежность.

**Важный следующий шаг:**
Тебе нужно зайти в свой проект Supabase, открыть **SQL Editor** и выполнить два SQL-запроса, которые я добавил в виде комментариев внутри функций `saveSpot` и `saveRoute`. Это создаст необходимые функции `create_spot` и `create_route` в твоей базе данных.

После этого все должно работать коррект
