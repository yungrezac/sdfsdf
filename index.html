<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>TerraRun | Захват Территории</title>

    <!-- Подключение Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Подключение Leaflet JS и CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- Подключение Turf.js для гео-анализа -->
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
    
    <!-- Подключение плагина Leaflet.TextPath для текста вдоль линии -->
    <script src="https://unpkg.com/leaflet-textpath/leaflet.textpath.js"></script>
    
    <!-- Подключение Telegram Web App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- Подключение Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <style>
        body {
            overscroll-behavior: none;
            background-color: #f3f4f6; /* bg-gray-100 */
        }
        #map {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 80px; /* Оставляем место для навбара */
            z-index: 10;
            background-color: #f3f4f6; /* Светлый фон для карты на время загрузки */
        }
        .view {
            display: none;
            height: calc(100vh - 80px);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        .view.active {
            display: block;
        }
        .nav-btn.active svg, .nav-btn.active span {
            color: #3b82f6; /* Синий цвет для активной иконки */
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .btn-gradient {
            background-image: linear-gradient(to right, #3b82f6, #60a5fa);
        }
        .btn-gradient-red {
             background-image: linear-gradient(to right, #ef4444, #f87171);
        }
    </style>
</head>
<body class="font-sans antialiased overflow-hidden">

    <!-- Экран-заглушка, если открыто не в Telegram -->
    <div id="auth-screen" class="fixed inset-0 bg-gray-100 flex items-center justify-center p-4 z-50">
        <div class="text-center bg-white p-8 rounded-2xl shadow-lg">
            <h1 class="text-2xl font-bold text-gray-800 mb-4">Загрузка TerraRun...</h1>
            <p class="text-gray-600">Подключаемся к серверам и вашему профилю Telegram.</p>
        </div>
    </div>

    <!-- Основной контейнер приложения (скрыт по умолчанию) -->
    <div id="app-container" class="hidden">
        <!-- Вид 1: Карта -->
        <div id="map-view" class="view active">
            <div id="map"></div>
            <!-- Панель управления -->
            <div id="run-controls" class="fixed bottom-24 left-0 right-0 p-4 z-20">
                <div class="max-w-md mx-auto bg-white/80 backdrop-blur-md rounded-2xl shadow-xl p-4 flex items-center justify-between fade-in">
                    <div class="flex flex-col">
                        <span id="username-display" class="font-bold text-gray-800 text-lg">TerraRun</span>
                        <span id="area-display" class="text-sm text-gray-600">Площадь: 0 м²</span>
                    </div>
                    <button id="toggle-run-btn" class="btn-gradient text-white font-bold py-3 px-6 rounded-full transition-all duration-300 shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300">
                        Старт
                    </button>
                </div>
            </div>
        </div>

        <!-- Вид 2: Топ пользователей -->
        <div id="top-view" class="view bg-gray-50 p-4 fade-in">
            <h1 class="text-3xl font-bold text-gray-800 mb-6 px-2">Топ Бегунов</h1>
            <div id="leaderboard" class="space-y-3">
                <!-- Содержимое будет сгенерировано JS из Supabase -->
            </div>
        </div>

        <!-- Вид 3: Профиль -->
        <div id="profile-view" class="view bg-gray-50 p-4 fade-in">
            <h1 class="text-3xl font-bold text-gray-800 mb-6 px-2">Профиль</h1>
            <div class="bg-white rounded-2xl shadow-lg p-6 space-y-4">
                <div class="flex items-center space-x-4">
                    <div id="profile-avatar-wrapper" class="w-20 h-20 rounded-full border-4 flex-shrink-0">
                        <img src="https://placehold.co/80x80/E2E8F0/4A5568?text=?" id="profile-avatar-img" class="w-full h-full rounded-full object-cover" alt="avatar">
                    </div>
                    <div>
                        <h2 id="profile-name" class="text-2xl font-bold text-gray-800">Загрузка...</h2>
                        <p class="text-gray-500">Энтузиаст захвата территорий</p>
                    </div>
                </div>
                <div class="bg-blue-50 rounded-lg p-4">
                    <p class="text-sm text-blue-700">Общая площадь</p>
                    <p id="profile-area" class="text-3xl font-bold text-blue-800">0 м²</p>
                </div>

                <!-- AI Помощник -->
                <div class="bg-gray-50 rounded-lg p-4 mt-4">
                    <h3 class="font-bold text-gray-700 mb-2">✨ AI Помощник</h3>
                    <div id="gemini-output" class="text-gray-600 bg-gray-100 p-3 rounded-md min-h-[70px] mb-3 whitespace-pre-wrap">Нажмите на кнопки ниже, чтобы получить совет или придумать имя для ваших владений!</div>
                    <div id="gemini-loader" class="hidden items-center justify-center mb-3">
                        <svg class="animate-spin h-5 w-5 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                        <span class="ml-2 text-gray-500">Думаю...</span>
                    </div>
                    <div class="flex space-x-2">
                        <button id="get-advice-btn" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white text-sm font-bold py-2 px-3 rounded-lg transition-all">Получить совет</button>
                        <button id="get-name-btn" class="flex-1 bg-green-500 hover:bg-green-600 text-white text-sm font-bold py-2 px-3 rounded-lg transition-all">Придумать имя</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Нижний навбар (скрыт по умолчанию) -->
    <nav id="bottom-navbar" class="hidden fixed bottom-0 left-0 right-0 h-20 bg-white/80 backdrop-blur-md shadow-[0_-5px_20px_-5px_rgba(0,0,0,0.1)] flex justify-around items-center z-30">
        <button class="nav-btn active text-gray-500 flex flex-col items-center space-y-1" onclick="showView('map-view')"><svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" /><path stroke-linecap="round" stroke-linejoin="round" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" /></svg><span>Карта</span></button>
        <button class="nav-btn text-gray-500 flex flex-col items-center space-y-1" onclick="showView('top-view')"><svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 19v-6a2 2 0 012-2h2a2 2 0 012 2v6m-6-12h.01M9 3h6a2 2 0 012 2v6a2 2 0 01-2 2H9a2 2 0 01-2-2V5a2 2 0 012-2z" /></svg><span>Топ</span></button>
        <button class="nav-btn text-gray-500 flex flex-col items-center space-y-1" onclick="showView('profile-view')"><svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" /></svg><span>Профиль</span></button>
    </nav>
    
    <!-- Модальное окно -->
    <div id="message-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center hidden z-50"><div class="bg-white rounded-2xl shadow-2xl p-8 text-center max-w-sm w-full fade-in"><p id="modal-message" class="text-lg text-gray-700 mb-6"></p><button onclick="closeModal()" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-6 rounded-full transition-all">OK</button></div></div>

    <script type="module">
        // --- Глобальные переменные ---
        const tg = window.Telegram.WebApp;
        let map;
        let supabase;
        let telegramUser = null; // Пользователь Telegram
        let isRunning = false;
        let watchId = null;
        let currentRunPath = [];
        let currentPathPolyline = null;
        let userTerritory = null; // GeoJSON
        let userColor = '#3b82f6';
        
        let allTerritoriesLayers = {}; // Хранилище для слоев других игроков {userId: layer}

        // --- Элементы DOM ---
        const authScreen = document.getElementById('auth-screen');
        const appContainer = document.getElementById('app-container');
        const bottomNavbar = document.getElementById('bottom-navbar');
        const toggleRunBtn = document.getElementById('toggle-run-btn');
        const areaDisplay = document.getElementById('area-display');
        const usernameDisplay = document.getElementById('username-display');
        const profileAreaDisplay = document.getElementById('profile-area');
        const profileName = document.getElementById('profile-name');
        const profileAvatarImg = document.getElementById('profile-avatar-img');
        const profileAvatarWrapper = document.getElementById('profile-avatar-wrapper');
        const leaderboardDiv = document.getElementById('leaderboard');
        const modal = document.getElementById('message-modal');
        const modalMessage = document.getElementById('modal-message');
        const getAdviceBtn = document.getElementById('get-advice-btn');
        const getNameBtn = document.getElementById('get-name-btn');
        const geminiOutput = document.getElementById('gemini-output');
        const geminiLoader = document.getElementById('gemini-loader');

        // --- Функции UI ---
        function showView(viewId) {
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(viewId).classList.add('active');
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`button[onclick="showView('${viewId}')"]`).classList.add('active');
        }

        function showMessage(message) {
            modalMessage.textContent = message;
            modal.classList.remove('hidden');
        }
        function closeModal() {
            modal.classList.add('hidden');
        }

        function generateColorFromId(id) {
            const strId = String(id);
            let hash = 0;
            for (let i = 0; i < strId.length; i++) {
                hash = strId.charCodeAt(i) + ((hash << 5) - hash);
            }
            const h = hash % 360;
            return `hsl(${h}, 70%, 60%)`;
        }

        // --- Основная логика ---
        async function startApp() {
            tg.ready();
            tg.expand();
            
            if (!tg.initDataUnsafe?.user) {
                authScreen.innerHTML = `<div class="text-center bg-white p-8 rounded-2xl shadow-lg"><h1 class="text-2xl font-bold text-gray-800 mb-4">Ошибка</h1><p class="text-gray-600">Пожалуйста, откройте это приложение внутри Telegram.</p></div>`;
                return;
            }
            telegramUser = tg.initDataUnsafe.user;

            try {
                // Инициализация Supabase
                const SUPABASE_URL = 'https://jsnahjtoqwuwbjdmisuj.supabase.co';
                const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpzbmFoanRvcXd1d2JqZG1pc3VqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMzOTQxMDQsImV4cCI6MjA2ODk3MDEwNH0.M3TWsNJppj1f-Cmj6nGCAUswy1HZgBLW8yJZfTwkrpI';
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                
                console.log("Supabase client initialized.");
                await setupUser();

            } catch (error) {
                console.error("Supabase Initialization Error:", error);
                authScreen.innerHTML = `<div class="text-center bg-white p-8 rounded-2xl shadow-lg"><h1 class="text-2xl font-bold text-gray-800 mb-4">Ошибка подключения</h1><p class="text-gray-600">Не удалось подключиться к серверу. Попробуйте перезапустить приложение.</p></div>`;
            }
        }
        
        async function setupUser() {
            try {
                await upsertUserProfile();
                initMap();
                updateUI();
                listenToAllProfiles();
                
                authScreen.style.display = 'none';
                appContainer.classList.remove('hidden');
                bottomNavbar.classList.remove('hidden');
                console.log("Setup complete. Application is running.");
            } catch (error) {
                console.error("Error during user setup:", error);
                showMessage("Произошла ошибка при настройке вашего профиля.");
            }
        }

        function updateUI() {
            const name = telegramUser.first_name.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            profileName.textContent = name;
            usernameDisplay.textContent = name;
            
            if (telegramUser.photo_url) {
                profileAvatarImg.src = telegramUser.photo_url;
            } else {
                const initial = name.charAt(0).toUpperCase();
                profileAvatarImg.src = `https://placehold.co/80x80/E2E8F0/4A5568?text=${initial}`;
            }
            profileAvatarWrapper.style.borderColor = userColor;
            updateAreaDisplay();
        }

        function initMap() {
            if (map) return;
            map = L.map('map', { zoomControl: false, attributionControl: false }).setView([55.75, 37.61], 13);
            
            // Замена на светлую карту Mapbox
            const mapboxAccessToken = 'pk.eyJ1IjoieXVuZ3JlemFjIiwiYSI6ImNtOW10ZzJ6bDBjNHUyanI3ejc5eXo1d2MifQ._tryk9cXjfReUGLGnNkm6Q';
            L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/streets-v12/tiles/{z}/{x}/{y}?access_token={accessToken}', {
                maxZoom: 19,
                tileSize: 512,
                zoomOffset: -1,
                accessToken: mapboxAccessToken
            }).addTo(map);

            navigator.geolocation.getCurrentPosition(
                pos => {
                    map.setView([pos.coords.latitude, pos.coords.longitude], 16);
                    // Яркий маркер для светлой карты
                    L.circleMarker([pos.coords.latitude, pos.coords.longitude], {radius: 8, color: '#d946ef', fillColor: '#fff', fillOpacity: 1, weight: 3}).addTo(map);
                },
                () => showMessage('Не удалось определить геолокацию.'), { enableHighAccuracy: true }
            );
        }
        
        // --- Логика бега и территории ---
        function startRun() {
            isRunning = true;
            currentRunPath = [];
            toggleRunBtn.textContent = 'Стоп';
            toggleRunBtn.className = 'btn-gradient-red text-white font-bold py-3 px-6 rounded-full transition-all duration-300 shadow-lg focus:outline-none focus:ring-4 focus:ring-red-300';
            if (currentPathPolyline) map.removeLayer(currentPathPolyline);
            currentPathPolyline = L.polyline([], { color: '#ef4444', weight: 5, opacity: 0.9 }).addTo(map);
            watchId = navigator.geolocation.watchPosition(
                pos => {
                    const { latitude, longitude } = pos.coords;
                    currentRunPath.push([longitude, latitude]);
                    currentPathPolyline.addLatLng([latitude, longitude]);
                    map.panTo([latitude, longitude]);
                },
                () => { showMessage('Проблема с отслеживанием геолокации.'); stopRun(); },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        }

        function stopRun() {
            if (watchId) navigator.geolocation.clearWatch(watchId);
            watchId = null;
            const wasRunning = isRunning;
            isRunning = false;
            toggleRunBtn.textContent = 'Старт';
            toggleRunBtn.className = 'btn-gradient text-white font-bold py-3 px-6 rounded-full transition-all duration-300 shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300';
            if (currentRunPath.length > 3 && wasRunning) {
                processRunPath();
            } else if (wasRunning) {
                showMessage('Слишком короткий маршрут.');
            }
            if (currentPathPolyline) setTimeout(() => { if(currentPathPolyline) map.removeLayer(currentPathPolyline); currentPathPolyline = null; }, 2000);
        }

        function processRunPath() {
            const startPoint = currentRunPath[0];
            const endPoint = currentRunPath[currentRunPath.length - 1];
            const distance = turf.distance(turf.point(startPoint), turf.point(endPoint), { units: 'meters' });
            if (distance > 50) {
                showMessage('Маршрут не замкнут. Вернитесь к точке старта для захвата.');
                return;
            }
            currentRunPath.push(startPoint);
            const newPolygon = turf.polygon([currentRunPath]);
            if (turf.kinks(newPolygon).features.length > 0) {
                showMessage('Маршрут пересекает сам себя. Попробуйте нарисовать простую фигуру.');
                return;
            }
            updateTerritory(newPolygon);
        }
        
        async function updateTerritory(newCapture) {
            try {
                let combinedTerritory;
                if (!userTerritory) {
                    combinedTerritory = newCapture;
                } else {
                    if (turf.intersect(userTerritory, newCapture) || turf.booleanTouches(userTerritory, newCapture)) {
                        combinedTerritory = turf.union(userTerritory, newCapture);
                    } else {
                        showMessage('Новая территория должна соприкасаться с уже захваченной.');
                        return;
                    }
                }
                userTerritory = combinedTerritory;
                await saveUserData();
                updateAreaDisplay();
                showMessage('Территория успешно расширена!');
            } catch (error) {
                console.error("Ошибка объединения:", error);
                showMessage("Ошибка обработки территории. Форма слишком сложная.");
            }
        }
        
        // --- Supabase ---
        async function upsertUserProfile() {
            const { data, error } = await supabase
                .from('profiles')
                .select('*')
                .eq('id', telegramUser.id)
                .single();

            if (error && error.code !== 'PGRST116') { // PGRST116: "The result contains 0 rows"
                console.error('Error fetching profile:', error);
                throw error;
            } 
            
            if (data) {
                console.log("User found:", data);
                userColor = data.color;
                userTerritory = data.territory;
            } else {
                console.log("User not found, creating new profile...");
                userColor = generateColorFromId(telegramUser.id);
                const { error: insertError } = await supabase
                    .from('profiles')
                    .insert({
                        id: telegramUser.id,
                        name: telegramUser.first_name,
                        color: userColor,
                        area: 0,
                        photo_url: telegramUser.photo_url || null,
                        territory: null
                    });
                if (insertError) {
                    console.error('Error creating profile:', insertError);
                    throw insertError;
                }
            }
        }

        async function saveUserData() {
            if (!telegramUser) return;
            const area = userTerritory ? turf.area(userTerritory) : 0;
            
            const { error } = await supabase
                .from('profiles')
                .update({
                    territory: userTerritory,
                    area: area,
                    updated_at: new Date().toISOString()
                })
                .eq('id', telegramUser.id);

            if (error) {
                console.error('Error saving user data:', error);
            }
        }

        function listenToAllProfiles() {
            fetchAllProfilesAndDraw();
            supabase.channel('public:profiles')
              .on('postgres_changes', { event: '*', schema: 'public', table: 'profiles' }, payload => {
                console.log('Change received!', payload);
                fetchAllProfilesAndDraw();
              })
              .subscribe();
        }

        async function fetchAllProfilesAndDraw() {
            let { data: profiles, error } = await supabase
                .from('profiles')
                .select('*');

            if (error) {
                console.error("Error fetching profiles:", error);
                return;
            }
            
            for (const userId in allTerritoriesLayers) {
                if (allTerritoriesLayers[userId]) {
                    map.removeLayer(allTerritoriesLayers[userId]);
                }
            }
            allTerritoriesLayers = {};

            profiles.forEach(profile => {
                if (profile.territory) {
                    const territoryLayerGroup = L.layerGroup();
                    
                    L.geoJSON(profile.territory, { 
                        style: { color: profile.color, weight: 2, opacity: 0.8, fillColor: profile.color, fillOpacity: 0.4 } 
                    }).addTo(territoryLayerGroup);

                    if (profile.territory.geometry.coordinates.length > 0 && profile.territory.geometry.coordinates[0].length > 0) {
                        const perimeterCoords = profile.territory.geometry.coordinates[0].map(p => [p[1], p[0]]);
                        const label = L.polyline(perimeterCoords, {opacity: 0});
                        label.setText(`\u25BA ${profile.name} `, {
                            repeat: true, center: true,
                            attributes: { 
                                'font-weight': 'bold', 
                                'font-size': '14', 
                                'fill': '#000', // Черный текст для светлой карты
                                'text-shadow': '1px 1px 1px #fff, -1px -1px 1px #fff, 1px -1px 1px #fff, -1px 1px 1px #fff' // Белая тень
                            }
                        });
                        label.addTo(territoryLayerGroup);
                    }
                    
                    territoryLayerGroup.addTo(map);
                    allTerritoriesLayers[profile.id] = territoryLayerGroup;
                }
            });
            
            updateLeaderboard(profiles);
        }
        
        function updateLeaderboard(profiles) {
            profiles.sort((a, b) => (b.area || 0) - (a.area || 0));

            leaderboardDiv.innerHTML = profiles.map((u, index) => {
                const isCurrentUser = u.id === telegramUser.id;
                const name = isCurrentUser ? `${u.name} (Вы)` : u.name;
                const avatar = u.photo_url || `https://placehold.co/50x50/E5E7EB/4B5563?text=${u.name.charAt(0)}`;
                const areaKm = ((u.area || 0) / 1000000).toFixed(3);

                return `<div class="bg-white rounded-xl shadow-md p-4 flex items-center space-x-4 ${isCurrentUser ? 'ring-2 ring-blue-500' : ''}">
                    <span class="text-xl font-bold text-gray-400 w-8">${index + 1}</span>
                    <img src="${avatar}" class="w-12 h-12 rounded-full" alt="avatar">
                    <div class="flex-grow">
                        <p class="font-bold text-gray-800">${name}</p>
                        <p class="text-sm text-gray-500">${areaKm} км²</p>
                    </div>
                </div>`
            }).join('');
        }

        function updateAreaDisplay() {
            let area = userTerritory ? turf.area(userTerritory) : 0;
            const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${area.toFixed(0)} м²`;
            areaDisplay.textContent = `Площадь: ${formattedArea}`;
            if (document.getElementById('profile-view').classList.contains('active')) {
                updateProfileStats();
            }
        }
        
        function updateProfileStats() {
            let area = userTerritory ? turf.area(userTerritory) : 0;
            const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${area.toFixed(0)} м²`;
            profileAreaDisplay.textContent = formattedArea;
        }

        // --- Gemini API ---
        async function callGemini(prompt) {
            geminiOutput.classList.add('hidden');
            geminiLoader.style.display = 'flex';
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    geminiOutput.innerText = result.candidates[0].content.parts[0].text;
                } else {
                    geminiOutput.innerText = "Не удалось получить ответ от AI. Попробуйте еще раз.";
                }
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                geminiOutput.innerText = "Произошла ошибка при обращении к AI.";
            } finally {
                geminiLoader.style.display = 'none';
                geminiOutput.classList.remove('hidden');
            }
        }

        // --- Обработчики событий ---
        toggleRunBtn.addEventListener('click', () => { if (!isRunning) startRun(); else stopRun(); });
        
        getAdviceBtn.addEventListener('click', () => {
            const area = userTerritory ? turf.area(userTerritory) : 0;
            const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${area.toFixed(0)} м²`;
            const prompt = `Я пользователь приложения для бега TerraRun, где я захватываю территорию. Моя текущая площадь владений: ${formattedArea}. Дай мне короткий (2-3 предложения) мотивирующий совет на русском языке, чтобы я бегал больше и расширял свою территорию.`;
            callGemini(prompt);
        });

        getNameBtn.addEventListener('click', () => {
            const area = userTerritory ? turf.area(userTerritory) : 0;
            const formattedArea = area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${area.toFixed(0)} м²`;
            const prompt = `Я пользователь приложения для бега TerraRun. Моя захваченная территория составляет ${formattedArea}. Придумай 3-4 крутых, эпичных названия для моих владений на русском языке. Ответ дай в виде списка с маркерами.`;
            callGemini(prompt);
        });
        
        // --- Глобальные функции для HTML ---
        window.showView = showView;
        window.closeModal = closeModal;

        // Запускаем приложение после загрузки DOM
        document.addEventListener('DOMContentLoaded', startApp);
    </script>

</body>
</html>
