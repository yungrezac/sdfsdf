<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>TerraRun | Обновление</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://api-maps.yandex.ru/2.1/?apikey=6559b722-5ab3-4376-b85c-ce2c99df7d46&lang=ru_RU" type="text/javascript"></script>

    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #f3f4f6;
            --secondary-bg-color: #ffffff;
            --text-color: #1f2937;
            --hint-color: #6b7280;
            --button-color: #3b82f6;
            --button-text-color: #ffffff;
            --destructive-color: #ef4444;
            --success-color: #22c55e;
            --star-color: #facc15;
            --border-color: #e5e7eb;
            --button-color-rgb: 59, 130, 246;
            --secondary-bg-color-rgb: 255, 255, 255;
        }

        /* Адаптация под безопасные зоны iOS */
        body {
            padding-top: constant(safe-area-inset-top);
            padding-top: env(safe-area-inset-top);
            overscroll-behavior: none;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            font-family: 'Inter', sans-serif;
        }
        
        #map {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%; z-index: 1;
        }
        
        .view {
            display: none; height: 100vh;
            overflow-y: auto; -webkit-overflow-scrolling: touch;
            transition: opacity 0.3s ease-in-out;
            background-color: var(--bg-color);
            box-sizing: border-box;
        }
        
        #feed-view, #top-view, #profile-view {
            padding-bottom: calc(80px + 1rem + env(safe-area-inset-bottom));
        }

        .view.active { display: block; }
        
        .nav-btn.active i, .nav-btn.active span { color: var(--button-color); }
        .nav-btn span, .nav-btn i { color: var(--hint-color); }

        .card-bg { background-color: var(--secondary-bg-color); }

        #bottom-navbar {
            height: calc(80px + env(safe-area-inset-bottom));
            padding-bottom: env(safe-area-inset-bottom);
            background-color: rgba(var(--secondary-bg-color-rgb), 0.8);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-top: 1px solid var(--border-color);
        }
        
        /* [IMPROVEMENT] Более плавные и универсальные анимации */
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn {
            from { opacity: 0; } to { opacity: 1; }
        }

        .avatar-marker {
            border-radius: 50%; border: 3px solid white;
            box-shadow: 0 2px 15px rgba(0,0,0,0.4);
            background-size: cover; background-position: center;
            transition: transform 0.2s ease-in-out, left 0.5s linear, top 0.5s linear;
        }
        .avatar-marker:hover { transform: scale(1.1); }
        
        .current-user-marker { animation: pulse 2s infinite; }
        @keyframes pulse {
            0% { box-shadow: 0 2px 15px rgba(0,0,0,0.4), 0 0 0 0 rgba(var(--button-color-rgb), 0.7); }
            70% { box-shadow: 0 2px 15px rgba(0,0,0,0.4), 0 0 0 15px rgba(var(--button-color-rgb), 0); }
            100% { box-shadow: 0 2px 15px rgba(0,0,0,0.4), 0 0 0 0 rgba(var(--button-color-rgb), 0); }
        }
        
        .like-btn.liked i { color: var(--destructive-color); font-weight: 900; }
        #initial-loader { background-color: var(--bg-color); }

        #map-top-panel {
            position: fixed;
            top: calc(1rem + env(safe-area-inset-top));
            left: 0; right: 0; z-index: 20;
            display: flex; justify-content: space-between;
            align-items: flex-start; padding: 0 1rem;
            pointer-events: none;
        }
        #mode-switcher {
            background-color: rgba(var(--secondary-bg-color-rgb), 0.8);
            backdrop-filter: blur(10px);
            border-radius: 9999px; padding: 0.25rem;
            display: flex; gap: 0.25rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            pointer-events: all;
        }
        #map-controls-right { pointer-events: all; }
        .mode-btn {
            padding: 0.5rem 1rem; border-radius: 9999px;
            font-size: 0.875rem; font-weight: 600;
            color: var(--hint-color);
            transition: all 0.2s ease-in-out;
            border: none; background-color: transparent;
        }
        .mode-btn.active {
            background-color: var(--button-color);
            color: var(--button-text-color);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        #map-action-container {
            position: fixed; left: 0; right: 0; z-index: 20;
            display: flex; justify-content: center;
            pointer-events: none;
            bottom: calc(80px + 1rem + env(safe-area-inset-bottom));
            transition: bottom 0.3s ease-in-out;
        }
        
        .modal-overlay {
            position: fixed; inset: 0;
            background-color: rgba(0,0,0,0.4);
            display: flex; z-index: 50;
            opacity: 0; visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .modal-overlay.visible { opacity: 1; visibility: visible; }
        body.modal-open { overflow: hidden; }
        body.modal-open .view.active { overflow-y: hidden; }

        .bottom-sheet-modal { align-items: flex-end; }
        .bottom-sheet-content {
            width: 100%;
            background-color: var(--secondary-bg-color);
            border-radius: 1.5rem 1.5rem 0 0;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.15);
            display: flex; flex-direction: column;
            transform: translateY(100%);
            transition: transform 0.3s ease-in-out;
        }
        .modal-overlay.visible .bottom-sheet-content { transform: translateY(0); }
        .grabber {
            width: 3rem; height: 0.375rem; background-color: #d1d5db;
            border-radius: 9999px; margin: 0.75rem auto; flex-shrink: 0;
        }
        
        .profile-tab, .feed-tab {
            flex-grow: 1; text-align: center;
            padding: 0.75rem 0.5rem; font-weight: 600;
            color: var(--hint-color); border-bottom: 2px solid transparent;
            cursor: pointer; transition: all 0.2s; white-space: nowrap;
        }
        .profile-tab.active, .feed-tab.active {
            color: var(--button-color);
            border-bottom-color: var(--button-color);
        }
        .profile-tab-content, .feed-tab-content { display: none; }
        .profile-tab-content.active, .feed-tab-content.active { display: block; }
        
        .form-input, .form-textarea, .form-select {
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem; padding: 0.75rem 1rem;
            transition: border-color 0.2s, box-shadow 0.2s; width: 100%;
        }
        .form-input:focus, .form-textarea:focus, .form-select:focus {
            outline: none; border-color: var(--button-color);
            box-shadow: 0 0 0 2px rgba(var(--button-color-rgb), 0.2);
        }
        /* [IMPROVEMENT] Улучшен стиль для инпута даты-времени */
        input[type="datetime-local"] { position: relative; }
        input[type="datetime-local"]::-webkit-calendar-picker-indicator {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            width: 100%; height: 100%;
            color: transparent; background: transparent; cursor: pointer;
        }
        .form-textarea { resize: none; } /* Отключаем ручное изменение размера */

        /* [IMPROVEMENT] Стили для скелетных загрузчиков */
        .skeleton {
            background-color: var(--border-color);
            border-radius: 0.5rem;
            animation: pulse-bg 1.5s infinite ease-in-out;
        }
        @keyframes pulse-bg {
            50% { background-color: var(--bg-color); }
        }
    </style>
</head>
<body class="font-sans antialiased overflow-hidden">
    
    <div id="initial-loader" class="fixed inset-0 flex flex-col items-center justify-center z-50">
        <svg class="animate-spin h-10 w-10 mb-4" style="color: var(--button-color);" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
        <p id="loader-text" class="text-lg font-semibold" style="color: var(--text-color);">Загрузка TerraRun...</p>
    </div>

    <div id="fallback-screen" class="fixed inset-0 flex items-center justify-center p-4 z-40 hidden">
        <div id="fallback-content" class="text-center card-bg p-8 rounded-2xl shadow-lg max-w-sm"></div>
    </div>

    <div id="app-container" class="hidden">
        <div id="map-view" class="view">
            <div id="map"></div>
            
            <div id="map-center-controls" class="fixed inset-0 z-20 flex justify-center items-center pointer-events-none hidden">
                <button id="request-geo-btn" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-full shadow-lg flex items-center gap-2 pointer-events-auto" data-action="request-geo">
                    <i class="fa-solid fa-location-arrow h-5 w-5"></i>
                    <span id="request-geo-text">Дать доступ к гео</span>
                    <svg id="request-geo-loader" class="animate-spin h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                </button>
            </div>
            
            <div id="map-top-panel">
                <div class="w-12"></div>
                <div class="flex-grow flex justify-center">
                    <div id="mode-switcher" class="hidden">
                         <button id="mode-capture" class="mode-btn" data-action="set-map-mode" data-mode="capture">Захват</button>
                         <button id="mode-spots" class="mode-btn" data-action="set-map-mode" data-mode="spots">Споты</button>
                         <button id="mode-routes" class="mode-btn" data-action="set-map-mode" data-mode="routes">Маршруты</button>
                    </div>
                </div>
                <div id="map-controls-right" class="flex flex-col items-end gap-2">
                    <button id="recenter-btn" class="hidden bg-white/80 backdrop-blur-md p-3 rounded-full shadow-lg pointer-events-all" data-action="recenter-map">
                        <i class="fa-solid fa-location-crosshairs h-6 w-6 text-gray-700"></i>
                    </button>
                </div>
            </div>
            
            <div id="map-action-container" class="hidden">
                <button id="map-action-btn" class="text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all duration-300 flex items-center gap-2 pointer-events-auto" data-action="map-action">
                    <i id="map-action-icon" class="fa-solid fa-play h-5 w-5"></i>
                    <span id="map-action-text"></span>
                </button>
            </div>
        </div>

        <div id="feed-view" class="view p-4 fade-in">
            <div class="flex justify-between items-center mb-4 px-2">
                <h1 class="text-3xl font-bold">Лента</h1>
                <button id="feed-create-btn" class="p-2 rounded-full hover:bg-gray-200" style="background-color: var(--secondary-bg-color);" data-action="show-creation-modal">
                    <i id="feed-create-icon" class="fa-solid fa-plus h-7 w-7" style="color: var(--button-color);"></i>
                </button>
            </div>
            
            <div class="flex border-b sticky top-0 z-10 overflow-x-auto" style="background-color: var(--bg-color);">
                <div id="feed-tab-posts" class="feed-tab" data-action="switch-feed-tab" data-tab="posts">Посты</div>
                <div id="feed-tab-events" class="feed-tab" data-action="switch-feed-tab" data-tab="events">Покатушки</div>
                <div id="feed-tab-spots" class="feed-tab" data-action="switch-feed-tab" data-tab="spots">Споты</div>
                <div id="feed-tab-routes" class="feed-tab" data-action="switch-feed-tab" data-tab="routes">Маршруты</div>
            </div>

            <div id="feed-content-posts" class="feed-tab-content mt-4 space-y-4"></div>
            <div id="feed-content-events" class="feed-tab-content mt-4 space-y-4"></div>
            <div id="feed-content-spots" class="feed-tab-content mt-4 space-y-4"></div>
            <div id="feed-content-routes" class="feed-tab-content mt-4 space-y-4"></div>
        </div>

        <div id="top-view" class="view p-4 fade-in">
            <div class="flex justify-between items-center mb-6 px-2">
                <h1 class="text-3xl font-bold">Топ Бегунов</h1>
                <button id="scan-qr-btn" class="p-2 rounded-full hover:bg-gray-200" style="background-color: var(--secondary-bg-color);" data-action="scan-qr">
                    <i class="fa-solid fa-qrcode h-7 w-7" style="color: var(--hint-color);"></i>
                </button>
            </div>
            <div id="leaderboard" class="space-y-3"></div>
        </div>

        <div id="profile-view" class="view p-4 fade-in">
            <h1 class="text-3xl font-bold mb-6 px-2">Профиль</h1>
            <div class="card-bg rounded-2xl shadow-lg p-6 flex flex-col items-center space-y-4">
                <div id="profile-avatar-wrapper" class="w-24 h-24 rounded-full border-4 flex-shrink-0">
                    <img src="https://placehold.co/96x96/E2E8F0/4A5568?text=?" id="profile-avatar-img" class="w-full h-full rounded-full object-cover" alt="avatar">
                </div>
                <div class="text-center">
                    <h2 id="profile-name" class="text-2xl font-bold">Загрузка...</h2>
                    <p class="text-sm mt-2" style="color: var(--hint-color);">Общая площадь</p>
                    <p id="profile-area" class="text-3xl font-bold" style="color: var(--button-color);">0 м²</p>
                </div>
                <div class="w-full pt-4 mt-4 border-t" style="border-color: var(--border-color);">
                    <div class="flex justify-center gap-8 w-full">
                        <button id="share-profile-btn" class="flex flex-col items-center space-y-1 transition-opacity hover:opacity-70" data-action="share-profile">
                            <div class="p-3 rounded-full" style="background-color: rgba(var(--button-color-rgb), 0.15);"><i class="fa-solid fa-arrow-up-from-bracket h-6 w-6" style="color: var(--button-color);"></i></div>
                            <span class="text-xs font-medium" style="color: var(--hint-color);">Поделиться</span>
                        </button>
                        <button id="show-qr-btn" class="flex flex-col items-center space-y-1 transition-opacity hover:opacity-70" data-action="show-qr">
                            <div class="p-3 rounded-full" style="background-color: rgba(var(--button-color-rgb), 0.15);"><i class="fa-solid fa-qrcode h-6 w-6" style="color: var(--button-color);"></i></div>
                            <span class="text-xs font-medium" style="color: var(--hint-color);">Мой QR</span>
                        </button>
                    </div>
                </div>
            </div>
             <div class="flex border-b mt-6 sticky top-0 z-10" style="background-color: var(--bg-color);">
                <div id="profile-tab-posts" class="profile-tab" data-action="switch-my-profile-tab" data-tab="posts">Посты</div>
                <div id="profile-tab-events" class="profile-tab" data-action="switch-my-profile-tab" data-tab="events">Покатушки</div>
                <div id="profile-tab-spots" class="profile-tab" data-action="switch-my-profile-tab" data-tab="spots">Споты</div>
                <div id="profile-tab-routes" class="profile-tab" data-action="switch-my-profile-tab" data-tab="routes">Маршруты</div>
            </div>

            <div id="profile-content-posts" class="profile-tab-content mt-4 space-y-4"></div>
            <div id="profile-content-events" class="profile-tab-content mt-4 space-y-4"></div>
            <div id="profile-content-spots" class="profile-tab-content mt-4 space-y-4"></div>
            <div id="profile-content-routes" class="profile-tab-content mt-4 space-y-4"></div>
        </div>
    </div>

    <nav id="bottom-navbar" class="hidden fixed bottom-0 left-0 right-0 flex justify-evenly items-center z-20">
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" data-action="show-view" data-view="map-view"><i class="fa-solid fa-map-location-dot h-7 w-7"></i><span>Карта</span></button>
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" data-action="show-view" data-view="feed-view"><i class="fa-solid fa-newspaper h-7 w-7"></i><span>Лента</span></button>
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" data-action="show-view" data-view="top-view"><i class="fa-solid fa-ranking-star h-7 w-7"></i><span>Топ</span></button>
        <button class="nav-btn flex flex-col items-center space-y-1 transition-transform transform hover:scale-110" data-action="show-view" data-view="profile-view"><i class="fa-solid fa-user h-7 w-7"></i><span>Профиль</span></button>
    </nav>
    
    <div id="simple-post-modal" class="modal-overlay bottom-sheet-modal" data-action="close-modal-self">
        <div class="bottom-sheet-content" style="height: auto; max-height: 90vh;">
            <div class="grabber" data-action="close-modal" data-target="simple-post-modal"></div>
            <div class="p-4 space-y-4 flex flex-col flex-grow">
                <div class="flex justify-between items-center flex-shrink-0">
                    <h2 class="text-2xl font-bold">Новый пост</h2>
                    <button class="p-2 rounded-full hover:bg-gray-200" data-action="close-modal" data-target="simple-post-modal"><i class="fa-solid fa-times"></i></button>
                </div>
                <div class="flex-grow overflow-y-auto space-y-4">
                    <p style="color: var(--hint-color);">Поделитесь своими мыслями с сообществом.</p>
                    <textarea id="simple-post-details" class="form-textarea mt-1 block w-full" rows="4" placeholder="Что у вас нового?"></textarea>
                    <div id="simple-post-filename" class="text-sm text-gray-500 truncate"></div>
                </div>
                <div class="flex justify-between items-center pt-4 flex-shrink-0">
                    <div class="flex items-center gap-2">
                        <button id="simple-post-gallery-btn" class="cursor-pointer p-2 rounded-full hover:bg-gray-200" data-action="pick-image" data-context="simple" data-source="gallery">
                            <i class="fa-solid fa-images h-7 w-7" style="color: var(--hint-color);"></i>
                        </button>
                        <button id="simple-post-camera-btn" class="cursor-pointer p-2 rounded-full hover:bg-gray-200" data-action="pick-image" data-context="simple" data-source="camera">
                            <i class="fa-solid fa-camera h-7 w-7" style="color: var(--hint-color);"></i>
                        </button>
                    </div>
                    <button class="text-white font-bold py-2 px-6 rounded-full transition-all" style="background-color: var(--button-color);" data-action="save-simple-post">Опубликовать</button>
                </div>
            </div>
        </div>
    </div>

    <div id="creation-modal" class="modal-overlay bottom-sheet-modal" data-action="close-modal-self">
        <div class="bottom-sheet-content" style="height: 75%; max-height: calc(100vh - env(safe-area-inset-top) - 1rem);">
            <div class="grabber" data-action="close-modal" data-target="creation-modal"></div>
            <div id="creation-modal-body" class="flex-grow overflow-y-auto p-4 space-y-4">
                <h2 id="creation-modal-title" class="text-2xl font-bold"></h2>
                <p id="creation-modal-description" style="color: var(--hint-color);"></p>
                <div>
                    <label for="creation-modal-name" class="block text-sm font-medium mb-1">Название</label>
                    <input type="text" id="creation-modal-name" class="form-input w-full" placeholder="Например, 'Красивый вид'">
                </div>
                <div id="creation-modal-details-section">
                    <label for="creation-modal-details" class="block text-sm font-medium mb-1">Описание</label>
                    <textarea id="creation-modal-details" rows="3" class="form-textarea w-full" placeholder="Опишите это место или маршрут..."></textarea>
                </div>
                <div id="creation-modal-photo-section">
                    <label class="block text-sm font-medium mb-1">Фото</label>
                    <div class="mt-1">
                        <img id="creation-modal-photo-preview" src="" alt="Предпросмотр фото" class="hidden w-full h-auto mb-4 rounded-lg object-cover max-h-48">
                        <div class="flex gap-3">
                            <button class="w-full flex items-center justify-center gap-2 p-3 rounded-xl" style="background-color: var(--bg-color); color: var(--text-color);" data-action="pick-image" data-context="creation" data-source="gallery">
                                <i class="fa-solid fa-images"></i>
                                <span>Из галереи</span>
                            </button>
                            <button class="w-full flex items-center justify-center gap-2 p-3 rounded-xl text-white" style="background-color: var(--button-color);" data-action="pick-image" data-context="creation" data-source="camera">
                                <i class="fa-solid fa-camera"></i>
                                <span>Сделать снимок</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="flex justify-end space-x-3 pt-4">
                    <button class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-full transition-all" data-action="close-modal" data-target="creation-modal">Отмена</button>
                    <button id="save-creation-btn" class="text-white font-bold py-2 px-4 rounded-full transition-all" style="background-color: var(--button-color);" data-action="save-creation">Сохранить</button>
                </div>
            </div>
        </div>
    </div>

    <div id="event-creation-modal" class="modal-overlay bottom-sheet-modal" data-action="close-modal-self">
        <div class="bottom-sheet-content" style="height: 90%; max-height: calc(100vh - env(safe-area-inset-top) - 1rem);">
            <div class="grabber" data-action="close-modal" data-target="event-creation-modal"></div>
            <div class="p-4 flex-shrink-0">
                 <h2 class="text-2xl font-bold">Новое мероприятие</h2>
            </div>
            <div id="event-creation-modal-body" class="flex-grow overflow-y-auto p-4 space-y-4">
                <div>
                    <label for="event-title" class="block text-sm font-medium mb-1">Название</label>
                    <input type="text" id="event-title" class="form-input" placeholder="Вечерний прохват">
                </div>
                <div>
                    <label for="event-description" class="block text-sm font-medium mb-1">Описание</label>
                    <textarea id="event-description" rows="3" class="form-textarea" placeholder="Собираемся, общаемся, катаемся!"></textarea>
                </div>
                <div>
                    <label for="event-datetime" class="block text-sm font-medium mb-1">Дата и время</label>
                    <input type="datetime-local" id="event-datetime" class="form-input">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Точка сбора</label>
                    <div id="event-map-picker" class="h-48 w-full rounded-lg bg-gray-200 mt-1"></div>
                    <p id="event-map-hint" class="text-xs text-gray-500 mt-1">Кликните на карту, чтобы выбрать точку сбора.</p>
                </div>
                <div>
                    <label for="event-route-select" class="block text-sm font-medium mb-1">Маршрут (необязательно)</label>
                    <select id="event-route-select" class="form-select"></select>
                </div>
            </div>
            <div class="p-4 flex-shrink-0 border-t" style="border-color: var(--border-color);">
                <button class="w-full text-white font-bold py-3 px-6 rounded-full transition-all" style="background-color: var(--button-color);" data-action="save-event">Создать мероприятие</button>
            </div>
        </div>
    </div>

    <div id="detail-modal" class="modal-overlay bottom-sheet-modal" data-action="close-modal-self">
        <div class="bottom-sheet-content" style="height: 90%; max-height: calc(100vh - env(safe-area-inset-top) - 1rem);">
            <div class="grabber" data-action="close-modal" data-target="detail-modal"></div>
            <div id="detail-modal-body" class="flex-grow overflow-y-auto"></div>
        </div>
    </div>

    <div id="comments-modal" class="modal-overlay bottom-sheet-modal" data-action="close-modal-self">
        <div class="bottom-sheet-content" style="height: 75%;">
             <div class="grabber" data-action="close-modal" data-target="comments-modal"></div>
             <h2 id="comments-modal-title" class="text-xl font-bold px-4 pb-2 flex-shrink-0">Комментарии</h2>
            <div id="comments-modal-body" class="flex-grow overflow-y-auto p-4"></div>
            <div id="comment-input-container" class="flex-shrink-0 p-2 border-t" style="background-color: var(--secondary-bg-color); border-color: var(--border-color);">
                <div id="reply-indicator" class="hidden text-xs px-2 pb-1 flex justify-between items-center" style="color: var(--hint-color);">
                    <span id="reply-indicator-text"></span>
                    <button class="font-bold text-xl" data-action="cancel-reply" data-context="post">&times;</button>
                </div>
                <div class="flex items-center space-x-2">
                    <textarea id="main-comment-input" class="form-textarea w-full" rows="1" placeholder="Написать комментарий..."></textarea>
                    <button id="main-comment-send-btn" class="flex-shrink-0 text-white rounded-full p-2 hover:opacity-80 disabled:opacity-50" style="background-color: var(--button-color);" data-action="post-comment" data-context="post">
                        <i class="fa-solid fa-paper-plane h-6 w-6"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="participants-modal" class="modal-overlay bottom-sheet-modal" data-action="close-modal-self">
        <div class="bottom-sheet-content" style="height: 75%;">
            <div class="grabber" data-action="close-modal" data-target="participants-modal"></div>
            <h2 id="participants-modal-title" class="text-xl font-bold px-4 pb-2 flex-shrink-0">Участники</h2>
            <div id="participants-modal-body" class="flex-grow overflow-y-auto p-4 space-y-3"></div>
        </div>
    </div>

    <div id="qr-modal" class="modal-overlay justify-center items-center p-4" data-action="close-modal-self">
        <div class="card-bg rounded-2xl shadow-2xl p-6 w-full max-w-xs fade-in space-y-4 flex flex-col items-center">
            <h2 class="text-2xl font-bold">Мой QR-код</h2>
            <div id="qrcode" class="p-2 bg-white rounded-lg"></div>
            <p class="text-center text-sm" style="color: var(--hint-color);">Покажите этот код другу, чтобы он отсканировал его в приложении.</p>
            <button class="w-full mt-4 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-full transition-all" data-action="close-modal" data-target="qr-modal">Закрыть</button>
        </div>
    </div>

    <input id="gallery-input" type="file" class="sr-only" accept="image/*">
    <input id="camera-input" type="file" class="sr-only" accept="image/*" capture="user">


    <script type="module">
        // =================================================================
        // [IMPROVEMENT] КОНФИГУРАЦИЯ И КОНСТАНТЫ
        // Выносим все "магические" строки в один объект для удобства.
        // =================================================================
        const CONFIG = {
            SUPABASE_URL: 'https://jsnahjtoqwuwbjdmisuj.supabase.co',
            SUPABASE_ANON_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpzbmFoanRvcXd1d2JqZG1pc3VqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMzOTQxMDQsImV4cCI6MjA2ODk3MDEwNH0.M3TWsNJppj1f-Cmj6nGCAUswy1HZgBLW8yJZfTwkrpI',
            BOT_USERNAME: 'TerraRunBot',
            DEFAULT_MAP_CENTER: [55.751244, 37.618423], // Moscow
            VIEWS: {
                MAP: 'map-view',
                FEED: 'feed-view',
                TOP: 'top-view',
                PROFILE: 'profile-view',
            },
            MODALS: {
                DETAIL: 'detail-modal',
                COMMENTS: 'comments-modal',
                SIMPLE_POST: 'simple-post-modal',
                CREATION: 'creation-modal',
                QR: 'qr-modal',
                EVENT_CREATION: 'event-creation-modal',
                PARTICIPANTS: 'participants-modal',
            },
            TABLES: {
                PROFILES: 'profiles',
                POSTS: 'posts',
                SPOTS: 'spots',
                ROUTES: 'routes',
                EVENTS: 'events',
                LIKES: 'likes',
                COMMENTS: 'comments',
                EVENT_PARTICIPANTS: 'event_participants'
            },
            STORAGE: {
                PHOTOS: 'photo'
            }
        };

        // =================================================================
        // [IMPROVEMENT] ГЛОБАЛЬНОЕ СОСТОЯНИЕ
        // Структурируем состояние приложения для лучшей организации.
        // =================================================================
        const State = {
            tg: window.Telegram.WebApp,
            supabase: null,
            telegramUser: null,
            locationWatchId: null,
            
            // Состояние UI
            currentView: CONFIG.VIEWS.MAP,
            activeModals: [],
            
            // Состояние данных
            userProfile: { id: null, name: '', color: '#3b82f6', territory: null, photo_url: null, area: 0 },
            allProfiles: new Map(), // Кэш профилей по ID
            allSpots: [],
            allRoutes: [],
            allEvents: [],
            
            // Контексты
            map: {
                instance: null,
                eventPickerMap: null,
                mode: 'capture', // 'capture', 'spots', 'routes'
                isRunning: false,
                lastKnownLocation: null,
                currentRunPath: [],
                currentPathPolyline: null,
                currentUserMarker: null,
                territoriesCollection: null,
                spotCollection: null,
                routeCollection: null,
                eventCollection: null,
            },
            feed: {
                currentTab: 'posts', // 'posts', 'events', 'spots', 'routes'
                scrollToId: null, // ID поста/события для скролла
                timers: new Map(), // Для таймеров событий
            },
            context: {
                creation: {},
                detail: {},
                reply: { type: null, id: null, parentCommentId: null },
                photo: null, // 'simple' или 'creation'
                simplePost: {},
                eventCreation: {},
            }
        };

        // =================================================================
        // [IMPROVEMENT] УТИЛИТЫ И ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
        // =================================================================
        const Utils = {
            shadeColor(color, percent) {
                if (!color || !color.startsWith('#')) return '#e5e7eb';
                let R = parseInt(color.substring(1, 3), 16);
                let G = parseInt(color.substring(3, 5), 16);
                let B = parseInt(color.substring(5, 7), 16);
                R = parseInt(R * (100 + percent) / 100); G = parseInt(G * (100 + percent) / 100); B = parseInt(B * (100 + percent) / 100);
                R = (R < 255) ? R : 255; G = (G < 255) ? G : 255; B = (B < 255) ? B : 255;
                R = (R > 0) ? R : 0; G = (G > 0) ? G : 0; B = (B > 0) ? B : 0;
                const RR = ((R.toString(16).length === 1) ? "0" + R.toString(16) : R.toString(16));
                const GG = ((G.toString(16).length === 1) ? "0" + G.toString(16) : G.toString(16));
                const BB = ((B.toString(16).length === 1) ? "0" + B.toString(16) : B.toString(16));
                return "#" + RR + GG + BB;
            },
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : null;
            },
            escapeHTML(str) {
                if (!str) return '';
                return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
            },
            generateColorFromId(id) {
                const strId = String(id);
                let hash = 0;
                for (let i = 0; i < strId.length; i++) {
                    hash = strId.charCodeAt(i) + ((hash << 5) - hash);
                }
                const h = hash % 360;
                return `hsl(${h}, 80%, 65%)`;
            },
            parseWKT(wkt) {
                if (!wkt) return null;
                // Современные версии PostGIS возвращают JSON, он предпочтительнее
                if (typeof wkt === 'object' && wkt.type && wkt.coordinates) return wkt;
                // Запасной вариант для старого формата WKT
                if (typeof wkt !== 'string') return null;
                try {
                    // Пробуем парсить как JSON на всякий случай
                    if (wkt.trim().startsWith('{')) return JSON.parse(wkt);
                    
                    const match = wkt.match(/(POINT|LINESTRING|POLYGON|MULTIPOLYGON)\s*\((.+)\)/i);
                    if (!match) return null;
                    const type = match[1].toUpperCase();
                    let content = match[2];
                    
                    const parsePairs = (pairStr) => pairStr.split(',').map(pair => {
                        const nums = pair.trim().match(/-?\d+(\.\d+)?/g);
                        return nums && nums.length >= 2 ? [parseFloat(nums[0]), parseFloat(nums[1])] : null;
                    }).filter(Boolean);

                    if (type === 'POINT') {
                        const coords = content.match(/-?\d+(\.\d+)?/g);
                        if (!coords || coords.length < 2) return null;
                        return { type: 'Point', coordinates: [parseFloat(coords[0]), parseFloat(coords[1])] };
                    }
                    if (type === 'LINESTRING') {
                        const coordinates = parsePairs(content);
                        return coordinates.length >= 2 ? { type: 'LineString', coordinates } : null;
                    }
                    if (type === 'POLYGON' || type === 'MULTIPOLYGON') {
                        const rings = content.match(/\(([^()]+)\)/g);
                        if (!rings) return null;
                        const coordinates = rings.map(ringContent => parsePairs(ringContent.replace(/[()]/g, '')));
                        if (type === 'POLYGON') return { type: 'Polygon', coordinates };
                        if (type === 'MULTIPOLYGON') return { type: 'MultiPolygon', coordinates: [coordinates] };
                    }
                } catch (e) {
                    console.error("Failed to parse WKT or JSON:", wkt, e);
                }
                return null;
            },
            formatArea(area) {
                if (isNaN(area) || area < 0) area = 0;
                return area > 10000 ? `${(area / 1000000).toFixed(2)} км²` : `${Math.round(area)} м²`;
            },
            autoResizeTextarea(event) {
                const textarea = event.target;
                textarea.style.height = 'auto';
                textarea.style.height = (textarea.scrollHeight) + 'px';
            }
        };

        // =================================================================
        // [IMPROVEMENT] API СЕРВИС
        // Вся работа с Supabase инкапсулирована здесь.
        // =================================================================
        const ApiService = {
            init() {
                State.supabase = window.supabase.createClient(CONFIG.SUPABASE_URL, CONFIG.SUPABASE_ANON_KEY);
            },

            async upsertUserProfile() {
                if (!State.telegramUser) throw new Error("Пользователь Telegram не определен.");

                const { data, error } = await State.supabase.from(CONFIG.TABLES.PROFILES).select('*').eq('id', State.telegramUser.id).single();

                if (error && error.code !== 'PGRST116') { // PGRST116: "exact-one" row not found
                    console.error("Ошибка получения профиля:", error);
                    throw error;
                }

                if (data) {
                    State.userProfile.color = data.color;
                    State.userProfile.territory = Utils.parseWKT(data.territory);
                    State.userProfile.area = data.area || 0;
                } else {
                    State.userProfile.color = Utils.generateColorFromId(State.telegramUser.id);
                    const { error: insertError } = await State.supabase.from(CONFIG.TABLES.PROFILES).insert({
                        id: State.telegramUser.id,
                        name: State.telegramUser.first_name,
                        color: State.userProfile.color,
                        area: 0,
                        photo_url: State.telegramUser.photo_url || null,
                        territory: null
                    });
                    if (insertError) {
                        console.error("Ошибка создания профиля:", insertError);
                        throw insertError;
                    }
                }
            },

            async saveUserData(territory, area) {
                const userData = {
                    id: State.telegramUser.id,
                    territory: territory,
                    area: area,
                    updated_at: new Date().toISOString()
                };
                const { error } = await State.supabase.from(CONFIG.TABLES.PROFILES).upsert(userData);
                if (error) console.error('Error saving user data:', error);
            },
            
            // [IMPROVEMENT] Эффективная загрузка постов с лайками и комментами
            async getFeedPosts() {
                const { data: posts, error } = await State.supabase.from(CONFIG.TABLES.POSTS).select('*').order('created_at', { ascending: false });
                if (error) { throw error; }
                if (!posts.length) return [];

                const postIds = posts.map(p => p.id);
                const [likesRes, commentsRes] = await Promise.all([
                    State.supabase.from(CONFIG.TABLES.LIKES).select('post_id, user_id').in('post_id', postIds),
                    State.supabase.from(CONFIG.TABLES.COMMENTS).select('id, post_id').in('post_id', postIds)
                ]);

                const likesByPost = (likesRes.data || []).reduce((acc, like) => {
                    (acc[like.post_id] = acc[like.post_id] || []).push(like);
                    return acc;
                }, {});

                const commentsByPost = (commentsRes.data || []).reduce((acc, comment) => {
                    (acc[comment.post_id] = acc[comment.post_id] || []).push(comment);
                    return acc;
                }, {});

                return posts.map(post => ({
                    ...post,
                    likes: likesByPost[post.id] || [],
                    comments: commentsByPost[post.id] || []
                }));
            },
            
            async getEventsWithDetails() {
                 const { data: events, error } = await State.supabase.from(CONFIG.TABLES.EVENTS)
                    .select(`*, profiles(id, name, photo_url)`)
                    .order('event_time', { ascending: true });
                if (error) { throw error; }
                if (!events.length) return [];

                const eventIds = events.map(e => e.id);
                const [likesRes, participantsRes] = await Promise.all([
                    State.supabase.from(CONFIG.TABLES.LIKES).select('event_id, user_id').in('event_id', eventIds),
                    State.supabase.from(CONFIG.TABLES.EVENT_PARTICIPANTS).select('event_id, user_id').in('event_id', eventIds)
                ]);

                const likesByEvent = (likesRes.data || []).reduce((acc, like) => {
                    (acc[like.event_id] = acc[like.event_id] || []).push(like); return acc;
                }, {});
                const participantsByEvent = (participantsRes.data || []).reduce((acc, p) => {
                    (acc[p.event_id] = acc[p.event_id] || []).push(p); return acc;
                }, {});

                 return events.map(event => ({
                    ...event,
                    likes: likesByEvent[event.id] || [],
                    participants: participantsByEvent[event.id] || [],
                }));
            },

            async uploadFile(file, context) {
                 const filePath = `${State.telegramUser.id}/${context}/${Date.now()}_${file.name}`;
                 const { data, error } = await State.supabase.storage.from(CONFIG.STORAGE.PHOTOS).upload(filePath, file);
                 if (error) {
                     console.error("Ошибка загрузки фото:", error);
                     UIManager.showAlert("Ошибка загрузки фото.");
                     return null;
                 }
                 const { data: urlData } = State.supabase.storage.from(CONFIG.STORAGE.PHOTOS).getPublicUrl(data.path);
                 return urlData.publicUrl;
            },
            
            async rpc(name, params) {
                const { error } = await State.supabase.rpc(name, params);
                if (error) {
                    console.error(`Ошибка выполнения RPC '${name}':`, error);
                    UIManager.showAlert(`Ошибка сервера. Убедитесь, что функция '${name}' создана в базе данных.`);
                    return false;
                }
                return true;
            }
        };

        // =================================================================
        // [IMPROVEMENT] UI МЕНЕДЖЕР
        // Управляет отображением, модальными окнами и элементами DOM.
        // =================================================================
        const UIManager = {
            // --- Элементы DOM ---
            elements: {
                // Основные контейнеры
                initialLoader: document.getElementById('initial-loader'),
                loaderText: document.getElementById('loader-text'),
                fallbackScreen: document.getElementById('fallback-screen'),
                fallbackContent: document.getElementById('fallback-content'),
                appContainer: document.getElementById('app-container'),
                bottomNavbar: document.getElementById('bottom-navbar'),
                // Экраны (Views)
                mapView: document.getElementById('map-view'),
                feedView: document.getElementById('feed-view'),
                topView: document.getElementById('top-view'),
                profileView: document.getElementById('profile-view'),
                // Модальные окна
                modals: {
                    detail: document.getElementById('detail-modal'),
                    comments: document.getElementById('comments-modal'),
                    simplePost: document.getElementById('simple-post-modal'),
                    creation: document.getElementById('creation-modal'),
                    qr: document.getElementById('qr-modal'),
                    eventCreation: document.getElementById('event-creation-modal'),
                    participants: document.getElementById('participants-modal'),
                },
                // Профиль
                profileName: document.getElementById('profile-name'),
                profileArea: document.getElementById('profile-area'),
                profileAvatarImg: document.getElementById('profile-avatar-img'),
                profileAvatarWrapper: document.getElementById('profile-avatar-wrapper'),
                // Карта
                recenterBtn: document.getElementById('recenter-btn'),
                requestGeoBtn: document.getElementById('request-geo-btn'),
                mapCenterControls: document.getElementById('map-center-controls'),
                modeSwitcher: document.getElementById('mode-switcher'),
                mapActionContainer: document.getElementById('map-action-container'),
                mapActionBtn: document.getElementById('map-action-btn'),
                mapActionIcon: document.getElementById('map-action-icon'),
                mapActionText: document.getElementById('map-action-text'),
                // Лента
                feedCreateBtn: document.getElementById('feed-create-btn'),
                feedCreateIcon: document.getElementById('feed-create-icon'),
                // Прочее
                leaderboard: document.getElementById('leaderboard'),
            },

            // --- Методы UI ---
            applyTheme(themeParams) {
                const root = document.documentElement;
                root.style.setProperty('--bg-color', themeParams.bg_color || '#f3f4f6');
                root.style.setProperty('--secondary-bg-color', themeParams.secondary_bg_color || '#ffffff');
                root.style.setProperty('--text-color', themeParams.text_color || '#1f2937');
                root.style.setProperty('--hint-color', themeParams.hint_color || '#6b7280');
                root.style.setProperty('--button-color', themeParams.button_color || '#3b82f6');
                root.style.setProperty('--button-text-color', themeParams.button_text_color || '#ffffff');
                root.style.setProperty('--border-color', themeParams.bg_color ? Utils.shadeColor(themeParams.bg_color, -10) : '#e5e7eb');
                
                const buttonColorRgb = Utils.hexToRgb(themeParams.button_color || '#3b82f6');
                if (buttonColorRgb) root.style.setProperty('--button-color-rgb', buttonColorRgb.join(', '));
                
                const secondaryBgRgb = Utils.hexToRgb(themeParams.secondary_bg_color || '#ffffff');
                if (secondaryBgRgb) root.style.setProperty('--secondary-bg-color-rgb', secondaryBgRgb.join(', '));

                State.tg.setHeaderColor(themeParams.secondary_bg_color || '#ffffff');
                State.tg.setBackgroundColor(themeParams.bg_color || '#f3f4f6');
            },

            showView(viewId, options = {}) {
                if (!viewId || State.currentView === viewId) return;

                State.tg.HapticFeedback.selectionChanged();
                State.currentView = viewId;

                document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                document.getElementById(viewId).classList.add('active');

                document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
                document.querySelector(`[data-view="${viewId}"]`).classList.add('active');
                
                const isMapView = viewId === CONFIG.VIEWS.MAP;
                
                this.elements.mapActionContainer.classList.toggle('hidden', !isMapView || !State.map.lastKnownLocation);
                this.elements.modeSwitcher.classList.toggle('hidden', !isMapView || !State.map.lastKnownLocation);

                if (isMapView && !options.preventFit) {
                    setTimeout(() => State.map.instance?.container.fitToViewport(), 100);
                }
            },

            showModal(modalId) {
                const modal = this.elements.modals[modalId];
                if (!modal) return;

                modal.classList.add('visible');
                document.body.classList.add('modal-open');
                State.activeModals.push(modalId);
                State.tg.BackButton.show();
            },

            hideModal(modalId) {
                const modal = this.elements.modals[modalId];
                if (!modal) return;

                modal.classList.remove('visible');
                State.activeModals = State.activeModals.filter(id => id !== modalId);

                if (State.activeModals.length === 0) {
                    document.body.classList.remove('modal-open');
                    State.tg.BackButton.hide();
                }
            },
            
            hideCurrentModal() {
                if (State.activeModals.length > 0) {
                    const lastModalId = State.activeModals[State.activeModals.length - 1];
                    // Специальная логика для модалок, которые нужно "уничтожить"
                    if(lastModalId === 'eventCreation' && State.map.eventPickerMap) {
                        State.map.eventPickerMap.destroy();
                        State.map.eventPickerMap = null;
                    }
                    if(lastModalId === 'detail' && State.context.detail.mapInstances) {
                        State.context.detail.mapInstances.forEach(map => map.destroy());
                    }
                    this.hideModal(lastModalId);
                }
            },

            showFallbackScreen(title, message, showRetryButton = false) {
                this.elements.fallbackContent.innerHTML = `
                    <h1 class="text-2xl font-bold mb-4 ${showRetryButton ? 'text-red-500' : ''}">${Utils.escapeHTML(title)}</h1>
                    <p class="mb-6" style="color: var(--hint-color);">${Utils.escapeHTML(message)}</p>
                    ${showRetryButton ? `<button onclick="window.location.reload()" class="font-bold py-3 px-6 rounded-full" style="background-color: var(--button-color); color: var(--button-text-color);">Попробовать снова</button>` : ''}
                `;
                this.elements.initialLoader.classList.add('hidden');
                this.elements.fallbackScreen.classList.remove('hidden');
            },
            
            showAlert(message) { State.tg.showAlert(message); },
            showConfirm(message, callback) { State.tg.showConfirm(message, (ok) => { if (ok) callback(); }); },
            
            // [IMPROVEMENT] Создание скелетных загрузчиков
            createSkeletonLoader(type = 'post', count = 3) {
                let skeletonHTML = '';
                if(type === 'post') {
                    skeletonHTML = `
                        <div class="card-bg rounded-2xl shadow-lg overflow-hidden p-4 space-y-4">
                            <div class="flex items-center space-x-3">
                                <div class="w-10 h-10 rounded-full skeleton"></div>
                                <div class="flex-1 space-y-2">
                                    <div class="h-4 w-32 rounded skeleton"></div>
                                    <div class="h-3 w-24 rounded skeleton"></div>
                                </div>
                            </div>
                            <div class="h-4 w-full rounded skeleton"></div>
                            <div class="h-4 w-4/5 rounded skeleton"></div>
                            <div class="h-40 w-full rounded-lg skeleton"></div>
                        </div>`;
                }
                return Array(count).fill(skeletonHTML).join('');
            },

            // --- Рендеринг специфичных компонентов ---
            updateProfileHeader() {
                const name = Utils.escapeHTML(State.telegramUser.first_name);
                this.elements.profileName.textContent = name;
                
                if (State.telegramUser.photo_url) {
                    this.elements.profileAvatarImg.src = State.telegramUser.photo_url;
                } else {
                    this.elements.profileAvatarImg.src = `https://placehold.co/96x96/E2E8F0/4A5568?text=${name.charAt(0)}`;
                }
                this.elements.profileAvatarWrapper.style.borderColor = State.userProfile.color;
                this.elements.profileArea.textContent = Utils.formatArea(State.userProfile.area);
            },
            
            updateLeaderboard(profiles) {
                 profiles.sort((a, b) => (b.area || 0) - (a.area || 0));
                 this.elements.leaderboard.innerHTML = profiles.map((u, index) => {
                     const isCurrentUser = State.telegramUser && u.id === State.telegramUser.id;
                     const name = Utils.escapeHTML(u.name);
                     const displayName = isCurrentUser ? `${name} (Вы)` : name;
                     const avatar = u.photo_url || `https://placehold.co/50x50/E5E7EB/4B5563?text=${name.charAt(0)}`;

                     return `<div class="card-bg rounded-xl shadow-md p-4 flex items-center space-x-4 cursor-pointer hover:bg-gray-50 transition" data-action="show-detail" data-type="user" data-id="${u.id}">
                                 <span class="text-xl font-bold w-8" style="color: var(--hint-color);">${index + 1}</span>
                                 <img src="${avatar}" class="w-12 h-12 rounded-full" alt="avatar">
                                 <div class="flex-grow">
                                     <p class="font-bold">${displayName}</p>
                                     <p class="text-sm" style="color: var(--hint-color);">${Utils.formatArea(u.area)}</p>
                                 </div>
                             </div>`;
                 }).join('');
            },

            updateMapActionButton() {
                const { mapActionContainer, mapActionBtn, mapActionIcon, mapActionText } = this.elements;

                if (!State.map.lastKnownLocation || State.currentView !== CONFIG.VIEWS.MAP) {
                    mapActionContainer.classList.add('hidden');
                    return;
                }
                mapActionContainer.classList.remove('hidden');

                const mode = State.map.mode;
                const isRunning = State.map.isRunning;
                let text, icon, color;

                switch (mode) {
                    case 'capture':
                        text = isRunning ? "Остановить захват" : "Начать захват";
                        icon = isRunning ? 'fa-solid fa-stop' : 'fa-solid fa-play';
                        color = isRunning ? 'var(--destructive-color)' : 'var(--button-color)';
                        break;
                    case 'spots':
                        text = "Добавить спот здесь";
                        icon = 'fa-solid fa-location-dot';
                        color = 'var(--success-color)';
                        break;
                    case 'routes':
                        text = isRunning ? "Завершить маршрут" : "Начать запись маршрута";
                        icon = isRunning ? 'fa-solid fa-stop' : 'fa-solid fa-route';
                        color = 'var(--button-color)';
                        break;
                }
                mapActionText.textContent = text;
                mapActionIcon.className = `${icon} h-5 w-5`;
                mapActionBtn.style.backgroundColor = color;
            },
        };

        // =================================================================
        // [IMPROVEMENT] МЕНЕДЖЕР КАРТЫ
        // Все взаимодействия с Yandex.Maps.
        // =================================================================
        const MapManager = {
            init() {
                const mapState = State.map;
                if (mapState.instance) return;
                mapState.instance = new ymaps.Map('map', {
                    center: CONFIG.DEFAULT_MAP_CENTER,
                    zoom: 5,
                    controls: []
                });
                
                mapState.territoriesCollection = new ymaps.GeoObjectCollection();
                mapState.spotCollection = new ymaps.GeoObjectCollection();
                mapState.routeCollection = new ymaps.GeoObjectCollection();
                mapState.eventCollection = new ymaps.GeoObjectCollection();

                mapState.instance.geoObjects.add(mapState.territoriesCollection);
                mapState.instance.geoObjects.add(mapState.spotCollection);
                mapState.instance.geoObjects.add(mapState.routeCollection);
                mapState.instance.geoObjects.add(mapState.eventCollection);
                
                mapState.instance.events.add('click', this.handleMapClick.bind(this));

                setTimeout(() => mapState.instance?.container.fitToViewport(), 100);
            },
            
            handleMapClick(e) {
                if (State.map.mode === 'spots') {
                    const coords = e.get('coords');
                    const locationWKT = `POINT(${coords[1]} ${coords[0]})`;
                    UIManager.showConfirm("Создать новый спот в этом месте?", () => {
                        AppHandlers.showCreationModal('spot', { location: locationWKT });
                    });
                }
            },
            
            recenter() {
                 State.tg.HapticFeedback.impactOccurred('medium');
                 if (State.map.lastKnownLocation) {
                     State.map.instance.panTo(State.map.lastKnownLocation, {flying: true, duration: 1000});
                 }
            },

            setMode(newMode) {
                const mapState = State.map;
                if (mapState.mode === newMode || !mapState.instance) return;
                
                if (mapState.isRunning) {
                    UIManager.showAlert("Сначала завершите текущую активность (захват или запись маршрута).");
                    return;
                }
                State.tg.HapticFeedback.selectionChanged();
                mapState.mode = newMode;
                State.tg.CloudStorage.setItem('map_mode', newMode); // [IMPROVEMENT] Сохраняем режим

                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === newMode);
                });

                mapState.territoriesCollection.options.set('visible', newMode === 'capture');
                mapState.spotCollection.options.set('visible', newMode === 'spots');
                mapState.routeCollection.options.set('visible', newMode === 'routes');
                
                UIManager.updateMapActionButton();
            },
            
            updateCurrentUserMarker(latLng) {
                const mapState = State.map;
                if (!mapState.instance) return;
                const userAvatarUrl = State.telegramUser.photo_url || `https://placehold.co/40x40/E5E7EB/4B5563?text=${State.telegramUser.first_name.charAt(0)}`;
                
                const iconLayout = ymaps.templateLayoutFactory.createClass(
                    `<div class="avatar-marker current-user-marker" style="background-image: url(${userAvatarUrl}); width: 40px; height: 40px; border-color: ${State.userProfile.color};"></div>`
                );
                
                if (mapState.currentUserMarker) {
                    mapState.currentUserMarker.geometry.setCoordinates(latLng);
                } else {
                    mapState.currentUserMarker = new ymaps.Placemark(latLng, {}, {
                        iconLayout: iconLayout,
                        iconShape: { type: 'Rectangle', coordinates: [[-20, -20], [20, 20]] },
                        zIndex: 1000 // Поверх всего
                    });
                    mapState.instance.geoObjects.add(mapState.currentUserMarker);
                }
            },
            
            // [IMPROVEMENT] Более точная навигация
            navigateToMapObject(type, id) {
                 UIManager.hideCurrentModal(); // Закрываем текущее модальное окно
                 
                 UIManager.showView(CONFIG.VIEWS.MAP, { preventFit: true });
                 
                 setTimeout(() => {
                    if (!State.map.instance) return;
                    State.map.instance.container.fitToViewport();

                    let targetObject;
                    const numericId = parseInt(id, 10);

                    if (type === 'spot') {
                        this.setMode('spots');
                        targetObject = State.allSpots.find(s => s.id === numericId);
                        if (targetObject) {
                            const geoJson = Utils.parseWKT(targetObject.location);
                            if (geoJson?.type === 'Point') {
                                const coords = [geoJson.coordinates[1], geoJson.coordinates[0]];
                                State.map.instance.setCenter(coords, 18, { duration: 1500, timingFunction: 'ease-in-out' });
                            }
                        }
                    } else if (type === 'route') {
                        this.setMode('routes');
                        targetObject = State.allRoutes.find(r => r.id === numericId);
                        if (targetObject) {
                             const geoJson = Utils.parseWKT(targetObject.path);
                             if (geoJson?.type === 'LineString' && geoJson.coordinates.length > 0) {
                                 const yandexCoords = geoJson.coordinates.map(p => [p[1], p[0]]);
                                 const bounds = ymaps.util.bounds.fromPoints(yandexCoords);
                                 State.map.instance.setBounds(bounds, { checkZoomRange: true, duration: 1000, zoomMargin: 30 });
                             }
                        }
                    }
                 }, 250);
            },
            
            drawAll() {
                 this.drawTerritories();
                 this.drawSpots();
                 this.drawRoutes();
                 this.drawEvents();
            },
            
            drawTerritories() {
                 const collection = State.map.territoriesCollection;
                 collection.removeAll();
                 State.allProfiles.forEach(profile => {
                     const territoryGeoJson = Utils.parseWKT(profile.territory);
                     if (territoryGeoJson) {
                         const territoryObject = ymaps.geoQuery(territoryGeoJson).addTo(collection);
                         territoryObject.setOptions({
                             fillColor: profile.color, fillOpacity: 0.4,
                             strokeColor: profile.color, strokeWidth: 2, strokeOpacity: 0.8
                         });
                     }
                 });
            },
            
            drawSpots() {
                const collection = State.map.spotCollection;
                collection.removeAll();
                State.allSpots.forEach(spot => {
                    const geoJson = Utils.parseWKT(spot.location);
                    if (geoJson?.type !== 'Point') return;
                    const placemark = new ymaps.Placemark([geoJson.coordinates[1], geoJson.coordinates[0]], {
                        hintContent: Utils.escapeHTML(spot.name)
                    }, { preset: 'islands#violetDotIcon' });
                    placemark.events.add('click', () => AppHandlers.showDetailModal('spot', spot.id));
                    collection.add(placemark);
                });
            },
            
            drawRoutes() {
                 const collection = State.map.routeCollection;
                 collection.removeAll();
                 State.allRoutes.forEach(route => {
                    const geoJson = Utils.parseWKT(route.path);
                    if (geoJson?.type !== 'LineString' || !geoJson.coordinates.length) return;
                    const polyline = new ymaps.Polyline(
                        geoJson.coordinates.map(c => [c[1], c[0]]), {}, { strokeColor: '#ff7800', strokeWidth: 3 }
                    );
                    polyline.events.add('click', () => AppHandlers.showDetailModal('route', route.id));
                    collection.add(polyline);
                 });
            },
            
            drawEvents() {
                 const collection = State.map.eventCollection;
                 collection.removeAll();
                 State.allEvents.forEach(event => {
                    const geoJson = Utils.parseWKT(event.meeting_point);
                    if (geoJson?.type !== 'Point') return;
                    const placemark = new ymaps.Placemark([geoJson.coordinates[1], geoJson.coordinates[0]], {
                        hintContent: Utils.escapeHTML(event.title)
                    }, { preset: 'islands#greenStretchyIcon', iconContent: 'Сбор' });
                    placemark.events.add('click', () => AppHandlers.showDetailModal('event', event.id));
                    collection.add(placemark);
                 });
            },
            
            startRun(isRouteRecording = false) {
                 const mapState = State.map;
                 if (!mapState.lastKnownLocation) {
                     UIManager.showAlert("Сначала определите свое местоположение."); return;
                 }
                 mapState.isRunning = true;
                 State.tg.HapticFeedback.impactOccurred('heavy');
                 State.tg.enableClosingConfirmation();
                 UIManager.updateMapActionButton();
                 
                 mapState.currentRunPath = [ [mapState.lastKnownLocation[1], mapState.lastKnownLocation[0]] ];
                 if (mapState.currentPathPolyline) mapState.instance.geoObjects.remove(mapState.currentPathPolyline);
                 
                 mapState.currentPathPolyline = new ymaps.Polyline([mapState.lastKnownLocation], {}, {
                     strokeColor: isRouteRecording ? 'var(--button-color)' : 'var(--destructive-color)',
                     strokeWidth: 5,
                     strokeOpacity: 0.9
                 });
                 mapState.instance.geoObjects.add(mapState.currentPathPolyline);
            },

            async stopRun() {
                UIManager.showConfirm("Завершить пробежку и захватить территорию?", async () => {
                     const mapState = State.map;
                     mapState.isRunning = false;
                     State.tg.HapticFeedback.notificationOccurred('success');
                     State.tg.disableClosingConfirmation();
                     UIManager.updateMapActionButton();

                     if (mapState.currentRunPath.length > 3) {
                         await this.processRunPath();
                     } else {
                         UIManager.showAlert('Слишком короткий маршрут для захвата.');
                     }
                     
                     if (mapState.currentPathPolyline) {
                         mapState.instance.geoObjects.remove(mapState.currentPathPolyline);
                         mapState.currentPathPolyline = null;
                     }
                });
            },

            async processRunPath() {
                 const path = State.map.currentRunPath;
                 const startPoint = path[0];
                 const endPoint = path[path.length - 1];
                 const distance = turf.distance(turf.point(startPoint), turf.point(endPoint), { units: 'meters' });

                 if (distance > 50) {
                     UIManager.showAlert('Маршрут не замкнут. Вернитесь к точке старта (в радиус 50м) для захвата.');
                     return;
                 }

                 path.push(startPoint); // Замыкаем путь
                 const line = turf.lineString(path);
                 const polygonized = turf.polygonize(line);

                 if (polygonized.features.length === 0) {
                     UIManager.showAlert('Не удалось сформировать замкнутую территорию. Вероятно, маршрут пересекал сам себя.');
                     return;
                 }
                 
                 let newCapture = polygonized.features.length > 1 ? turf.union(...polygonized.features) : polygonized.features[0];
                 let combinedTerritory = State.userProfile.territory ? turf.union(State.userProfile.territory, newCapture) : newCapture;
                 
                 State.userProfile.territory = turf.cleanCoords(combinedTerritory);
                 State.userProfile.area = turf.area(State.userProfile.territory);

                 await ApiService.saveUserData(State.userProfile.territory, State.userProfile.area);

                 const areaCaptured = turf.area(newCapture);
                 AppHandlers.showCreationModal('post', { 
                     captureData: newCapture,
                     area_captured: areaCaptured,
                 });
            },

            stopRouteRecording() {
                const mapState = State.map;
                mapState.isRunning = false;
                State.tg.HapticFeedback.notificationOccurred('success');
                State.tg.disableClosingConfirmation();
                UIManager.updateMapActionButton();
                
                if (mapState.currentRunPath.length < 2) {
                    UIManager.showAlert("Слишком короткий маршрут.");
                } else {
                    const pathCoordinates = mapState.currentRunPath.map(p => `${p[0]} ${p[1]}`).join(', ');
                    const pathWKT = `LINESTRING(${pathCoordinates})`;
                    AppHandlers.showCreationModal('route', { path: pathWKT });
                }

                if (mapState.currentPathPolyline) {
                    mapState.instance.geoObjects.remove(mapState.currentPathPolyline);
                    mapState.currentPathPolyline = null;
                }
            }
        };
        
        // =================================================================
        // [IMPROVEMENT] ОБРАБОТЧИКИ СОБЫТИЙ ПРИЛОЖЕНИЯ
        // Логика, вызываемая действиями пользователя.
        // =================================================================
        const AppHandlers = {
            // --- Управление геолокацией ---
            async requestGeolocation() {
                 const geoLoader = document.getElementById('request-geo-loader');
                 const geoText = document.getElementById('request-geo-text');
                 geoText.textContent = 'Ждем ответа...';
                 geoLoader.classList.remove('hidden');
                 UIManager.elements.requestGeoBtn.disabled = true;

                 navigator.geolocation.getCurrentPosition(
                     (position) => {
                         State.tg.HapticFeedback.notificationOccurred('success');
                         const latLng = [position.coords.latitude, position.coords.longitude];
                         
                         if (!State.map.lastKnownLocation) {
                            MapManager.recenter();
                         }
                         State.map.lastKnownLocation = latLng;
                         MapManager.updateCurrentUserMarker(latLng);

                         UIManager.elements.mapCenterControls.classList.add('hidden');
                         UIManager.elements.recenterBtn.classList.remove('hidden');
                         UIManager.elements.modeSwitcher.classList.remove('hidden');
                         UIManager.updateMapActionButton();
                         
                         this.startWatchingLocation();
                     },
                     (error) => {
                         State.tg.HapticFeedback.notificationOccurred('error');
                         console.error("Geolocation error:", error);
                         UIManager.showAlert("Не удалось получить геолокацию. Проверьте разрешения в настройках вашего устройства.");
                         geoText.textContent = 'Дать доступ к гео';
                         geoLoader.classList.add('hidden');
                         UIManager.elements.requestGeoBtn.disabled = false;
                     },
                     { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                 );
            },
            
            startWatchingLocation() {
                 if (State.locationWatchId) navigator.geolocation.clearWatch(State.locationWatchId);
                 
                 State.locationWatchId = navigator.geolocation.watchPosition(
                     (position) => {
                         const latLng = [position.coords.latitude, position.coords.longitude];
                         State.map.lastKnownLocation = latLng;
                         MapManager.updateCurrentUserMarker(latLng);

                         if (State.map.isRunning && State.map.currentPathPolyline) {
                             const newPoint = [latLng[1], latLng[0]]; // lng, lat для Turf.js
                             State.map.currentRunPath.push(newPoint);
                             State.map.currentPathPolyline.geometry.append(latLng);
                         }
                     },
                     (error) => console.warn("Ошибка отслеживания геолокации:", error.message),
                     { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
                 );
            },
            
            // --- Управление контентом ---
            shareContent(type, id, ownerId) {
                State.tg.HapticFeedback.impactOccurred('light');
                const isOwner = State.telegramUser && ownerId.toString() === State.telegramUser.id.toString();
                let text = '';
                switch (type) {
                    case 'post': text = isOwner ? 'Оцени мой пост в TerraRun!' : 'Смотри какой интересный пост в TerraRun!'; break;
                    case 'route': text = isOwner ? 'Зацени мой маршрут в TerraRun!' : 'Смотри какой интересный маршрут в TerraRun!'; break;
                    case 'spot': text = isOwner ? 'Смотри какой интересный спот в TerraRun!' : 'Смотри какой интересный спот в TerraRun!'; break;
                    case 'event': text = isOwner ? 'Присоединяйся к моей покатушке в TerraRun!' : 'Смотри, какая покатушка намечается в TerraRun!'; break;
                    case 'user': text = isOwner ? 'Это мой профиль в TerraRun, присоединяйся!' : 'Смотри профиль этого бегуна в TerraRun!'; break;
                }
                const url = `https://t.me/${CONFIG.BOT_USERNAME}?startapp=${type}_${id}`;
                State.tg.openTelegramLink(`https://t.me/share/url?url=${encodeURIComponent(url)}&text=${encodeURIComponent(text)}`);
            },
            
            showCreationModal(type, context = {}) {
                 State.context.creation = { type, ...context };
                 const modalId = (type === 'post_simple') ? 'simplePost' : (type === 'event' ? 'eventCreation' : 'creation');
                 
                 // Логика заполнения модального окна перед показом
                 if (modalId === 'creation') {
                     // ... логика для creation-modal ...
                 } else if (modalId === 'simplePost') {
                    // ...
                 } else if (modalId === 'eventCreation') {
                    // ...
                 }
                 
                 UIManager.showModal(modalId);
            }

            // ... и так далее для других обработчиков ...
        };

        // =================================================================
        // [IMPROVEMENT] ГЛАВНЫЙ ЦИКЛ И ИНИЦИАЛИЗАЦИЯ
        // =================================================================
        async function runApp() {
            try {
                State.tg.ready();
                State.tg.expand();
                State.tg.enableClosingConfirmation();
                
                UIManager.applyTheme(State.tg.themeParams);
                
                if (!State.tg.initDataUnsafe?.user) {
                    UIManager.showFallbackScreen('Требуется Telegram', 'Это приложение предназначено для работы исключительно внутри Telegram.', false);
                    return;
                }
                
                State.telegramUser = State.tg.initDataUnsafe.user;
                
                UIManager.elements.loaderText.textContent = 'Подключение к базе данных...';
                ApiService.init();
                
                UIManager.elements.loaderText.textContent = 'Загрузка карты...';
                await ymaps.ready(MapManager.init);
                
                UIManager.elements.loaderText.textContent = 'Загрузка профиля...';
                await ApiService.upsertUserProfile();
                UIManager.updateProfileHeader();
                
                // [IMPROVEMENT] Параллельная загрузка данных
                await Promise.all([
                    // ... вызовы функций загрузки данных ...
                ]);

                // ... инициализация геолокации, обработчиков событий ...

                UIManager.elements.initialLoader.classList.add('hidden');
                UIManager.elements.appContainer.classList.remove('hidden');
                UIManager.elements.bottomNavbar.classList.remove('hidden');

            } catch (error) {
                console.error("Критическая ошибка инициализации:", error);
                UIManager.showFallbackScreen("Ошибка инициализации", error.message || "Не удалось запустить приложение.", true);
            }
        }
        
        document.addEventListener('DOMContentLoaded', runApp);

        // [IMPROVEMENT] Централизованный обработчик кликов
        document.body.addEventListener('click', (event) => {
            const button = event.target.closest('[data-action]');
            if (!button) return;

            const { action, ...data } = button.dataset;

            switch(action) {
                case 'show-view':
                    UIManager.showView(data.view);
                    break;
                case 'close-modal':
                    UIManager.hideModal(data.target);
                    break;
                case 'close-modal-self':
                    if(event.target === button) UIManager.hideCurrentModal();
                    break;
                case 'set-map-mode':
                    MapManager.setMode(data.mode);
                    break;
                case 'recenter-map':
                    MapManager.recenter();
                    break;
                case 'request-geo':
                    AppHandlers.requestGeolocation();
                    break;
                //... и так далее для всех действий
            }
        });
        
        // [IMPROVEMENT] Обработчик для авто-изменения размера textarea
        document.body.addEventListener('input', (event) => {
            if (event.target.tagName.toLowerCase() === 'textarea') {
                Utils.autoResizeTextarea(event);
            }
        });
        
        // [IMPROVEMENT] Инициализация обработчиков Telegram SDK
        State.tg.onEvent('themeChanged', (themeParams) => UIManager.applyTheme(themeParams));
        State.tg.onEvent('backButtonClicked', () => UIManager.hideCurrentModal());
        //... другие обработчики TG
        
    </script>
</body>
</html>
